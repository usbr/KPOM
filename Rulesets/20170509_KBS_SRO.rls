# RiverWare_Ruleset 7.1.1 Patch
# Created 13:28 September 8, 2017
# 
RULESET
NAME "KBS_SRO";
AGENDA_ORDER ASCENDING;
DESCRIPTION "";
PRECISION   8;
NOTES "";
BEGIN

  POLICY_GROUP   "Distribute Energy To On Peak and Off Peak";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Total Energy";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.OffPeakEnergy" [] := $ "ReservoirOperations.OffPeakEnergy" [@"t", "Boyle"] + $ "ReservoirOperations.OffPeakEnergy" [@"t", "Copco 1"] + $ "ReservoirOperations.OffPeakEnergy" [@"t", "Copco 2"] + $ "ReservoirOperations.OffPeakEnergy" [@"t", "Iron Gate"];

      $ "ReservoirOperations.OnPeakEnergy" [] := $ "ReservoirOperations.OnPeakEnergy" [@"t", "Boyle"] + $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 1"] + $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 2"] + $ "ReservoirOperations.OnPeakEnergy" [@"t", "Iron Gate"];

    END;

    RULE                 "Off Peak Distribution";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.OffPeakEnergy" [@"t", "Boyle"] := $ "JC Boyle Power Plant.Energy" [] - $ "ReservoirOperations.OnPeakEnergy" [@"t", "Boyle"];

      $ "ReservoirOperations.OffPeakEnergy" [@"t", "Copco 1"] := $ "Copco 1 Reservoir.Energy" [] - $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 1"];

      $ "ReservoirOperations.OffPeakEnergy" [@"t", "Copco 2"] := $ "Copco 2 Power Plant.Energy" [] - $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 2"];

      $ "ReservoirOperations.OffPeakEnergy" [@"t", "Iron Gate"] := $ "Iron Gate Reservoir.Energy" [] - $ "ReservoirOperations.OnPeakEnergy" [@"t", "Iron Gate"];

    END;

    RULE                 "On Peak Distribution";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.OnPeakEnergy" [@"t", "Boyle"] := IF ( @"t" == @"Sunday" )
 THEN
  0.00000000 "MWH"
 ELSE
  WITH NUMERIC peakVolume = "Min"( 0.66666660 * "FlowToVolume"( $ "ReservoirData.TurbineCapacities" ["Boyle", "Flow"], @"t" ), "FlowToVolume"( $ "JC Boyle Power Plant.Outflow" [], @"t" ) ) DO
   IF ( $ "JC Boyle Power Plant.Outflow" [] <= 0.00000000 "cms" )
   THEN
    0.00000000 "MWH"
   ELSE
    $ "JC Boyle Power Plant.Energy" [] * ( peakVolume / "FlowToVolume"( $ "JC Boyle Power Plant.Outflow" [], @"t" ) )
   ENDIF
  ENDWITH
 ENDIF;

      $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 1"] := IF ( @"t" == @"Sunday" )
 THEN
  0.00000000 "MWH"
 ELSE
  0.66666660 * $ "Copco 1 Reservoir.Energy" []
 ENDIF;

      $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 2"] := IF ( @"t" == @"Sunday" )
 THEN
  0.00000000 "MWH"
 ELSE
  0.66666660 * $ "Copco 2 Power Plant.Energy" []
 ENDIF;

      $ "ReservoirOperations.OnPeakEnergy" [@"t", "Iron Gate"] := IF ( @"t" == @"Sunday" )
 THEN
  0.00000000 "MWH"
 ELSE
  0.66666660 * $ "Iron Gate Reservoir.Energy" []
 ENDIF;

    END;

  END;

  POLICY_GROUP   "Power Reservoir Operations";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Iron Gate Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Iron Gate Reservoir.Outflow" [] := "IronGateCapacityCheck"( "MaxMinElevationCheck"( % "Iron Gate Reservoir", "Iron Gate Reservoir", $ "ReservoirOperations.Iron Gate Constrained Release" [] ) );

    END;

    RULE                 "Iron Gate Constrained Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Iron Gate Constrained Release" [] := IF ( @"t" < "OffsetDate"( @"Start Timestep", 2.00000000, "1 Days" ) )
 THEN
  $ "ReservoirOperations.Iron Gate Unconstrained Release" []
 ELSE
  "Max"( $ "ReservoirOperations.Iron Gate Hatchery Release" [], WITH NUMERIC flowChange = $ "ReservoirOperations.Iron Gate Unconstrained Release" [] - $ "Iron Gate Reservoir.Outflow" [@"t - 1"] DO
   "Max"( $ "ReservoirOperations.Iron Gate ENV Release" [] + $ "ReservoirOperations.Iron Gate Hatchery Release" [], IF ( flowChange < 0.00000000 "cms" AND NOT ( "IronGatePreviousUnregulated"( @"t - 1" ) >= 0.00000000 "cfs" AND "IronGatePreviousUnregulated"( @"t - 2" ) >= 0.00000000 "cfs" ) )
   THEN
    ( $ "Iron Gate Reservoir.Outflow" [@"t - 1"] - "Min"( - 1.00000000 * flowChange, IF ( $ "ReservoirOperations.Iron Gate Unconstrained Release" [] <= ( $ "ReservoirData.Iron Gate Ramping Criteria" ["Threshold", "Middle Descending"] + $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Middle Descending"] ) AND $ "ReservoirOperations.Iron Gate Unconstrained Release" [] > ( $ "ReservoirData.Iron Gate Ramping Criteria" ["Threshold", "Low Descending"] + $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"] ) )
    THEN
     $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Middle Descending"]
    ELSE
     IF ( $ "ReservoirOperations.Iron Gate Unconstrained Release" [] <= ( $ "ReservoirData.Iron Gate Ramping Criteria" ["Threshold", "Low Descending"] + $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"] ) )
     THEN
      $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"]
     ELSE
      $ "ReservoirOperations.Iron Gate Unconstrained Release" []
     ENDIF
    ENDIF ) ) COMMENTED_BY "Descening limit is, <br>  if (proposed flow > 3000) then rate of decline is net UKL inflow + Keno to IG accretions<br>  else if (1750 < flow <= 3000) then rate of decline is 300 cfs<br>  else if (flow <= 1750) then rate of decline is 150 cfs"
   ELSE
    $ "ReservoirOperations.Iron Gate Unconstrained Release" [] COMMENTED_BY "Ascending ramping is not restricted"
   ENDIF )
  ENDWITH )
 ENDIF COMMENTED_BY "Respect ascending and descending criteria while meeting instream flow requirement.";

    END;

    RULE                 "Iron Gate Unconstrained Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Iron Gate Unconstrained Release" [] := "MaxItem"( { $ "ReservoirOperations.IFRRelease" [@"t", "Iron Gate"] , $ "ReservoirOperations.Iron Gate ENV Release" [] , $ "ReservoirOperations.TargetPowerRelease" [@"t", "Iron Gate"] , $ "ReservoirOperations.TargetRelease" [@"t", "Iron Gate"] } ) COMMENTED_BY "Release that we want to make without ascending and descending criteria." + $ "ReservoirOperations.Iron Gate Hatchery Release" [];

    END;

    RULE                 "Iron Gate Target Power Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetPowerRelease" [@"t", "Iron Gate"] := "Min"( $ "ReservoirData.TurbineCapacities" ["Iron Gate", "Flow"], "Max"( "Min"( "Max"( $ "ReservoirOperations.TargetRelease" [@"t", "Iron Gate"] + ( $ "ReservoirOperations.Iron Gate Hatchery Release" [] + $ "ReservoirOperations.IFRRelease" [@"t", "Iron Gate"] ), "SolveOutflow"( % "Iron Gate Reservoir", $ "Iron Gate Reservoir.Inflow" [], "ElevationToStorage"( % "Iron Gate Reservoir", $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] ), "PreviousStorage"( % "Iron Gate Reservoir" ), @"t" ) ), "SolveOutflow"( % "Iron Gate Reservoir", $ "Iron Gate Reservoir.Inflow" [], "ElevationToStorage"( % "Iron Gate Reservoir", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ), "PreviousStorage"( % "Iron Gate Reservoir" ), @"t" ) COMMENTED_BY "Check for low reservoir conditons" ) - $ "ReservoirOperations.Iron Gate Hatchery Release" [], 0.00000000 "cms" ) );

    END;

    RULE                 "Iron Gate IFR Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Iron Gate"] := "Max"( "Min"( $ "ReservoirOperations.Iron Gate ENV Release" [] - $ "ReservoirOperations.Iron Gate Hatchery Release" [], "SolveOutflow"( % "Iron Gate Reservoir", $ "Iron Gate Reservoir.Inflow" [], "ElevationToStorage"( % "Iron Gate Reservoir", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Iron Gate"] ), "PreviousStorage"( % "Iron Gate Reservoir" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

    END;

    RULE                 "Iron Gate Fish Hatchery Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Iron Gate Hatchery Release" [] := "Max"( "Min"( $ "ReservoirData.Iron Gate Hatchery Request" [], "SolveOutflow"( % "Iron Gate Reservoir", $ "Iron Gate Reservoir.Inflow" [], "ElevationToStorage"( % "Iron Gate Reservoir", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Iron Gate"] ), "PreviousStorage"( % "Iron Gate Reservoir" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), IF ( $ "Iron Gate Reservoir.Pool Elevation" [@"t - 1"] > $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] )
 THEN
  "TableInterpolation"( $ "Iron Gate Reservoir.Bypass Table", 0.00000000, 1.00000000, $ "Iron Gate Reservoir.Pool Elevation" [@"t - 1"], @"t" )
 ELSE
  0.00000000 "cms"
 ENDIF );

    END;

    RULE                 "Iron Gate Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Iron Gate"] := "DailyTargetStorageRelease"( % "Iron Gate Reservoir", "Iron Gate Reservoir", @"t", "PreviousStorage"( % "Iron Gate Reservoir" ), $ "Iron Gate Reservoir.Inflow" [] );

    END;

    RULE                 "Copco 2 Power Diversion";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "Copco 2 Reservoir.Diversion" [] := $ "ReservoirOperations.TargetPowerRelease" [@"t", "Copco 2"];

    END;

    RULE                 "Copco 2 Target Power Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetPowerRelease" [@"t", "Copco 2"] := "Min"( $ "ReservoirData.TurbineCapacities" ["Copco 2", "Flow"], "Max"( 0.00000000 "cms", $ "Copco 2 Reservoir.Inflow" [] - $ "ReservoirOperations.IFRRelease" [@"t", "Copco 1"] ) );

    END;

    RULE                 "Copco 1 Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Copco 1 Reservoir.Outflow" [] := "Min"( "MaxMinElevationCheck"( % "Copco 1 Reservoir", "Copco 1 Reservoir", "MaxItem"( { $ "ReservoirOperations.IFRRelease" [@"t", "Copco 1"] , $ "ReservoirOperations.TargetPowerRelease" [@"t", "Copco 1"] , $ "ReservoirOperations.TargetRelease" [@"t", "Copco 1"] , $ "ReservoirOperations.Copco To Iron Gate Pass Thru" [] } ) ), "Max"( 0.00000000 "cms", "GetMaxOutflowGivenInflow"( % "Copco 1 Reservoir", $ "Copco 1 Reservoir.Inflow" [], @"t" ) ) );

    END;

    RULE                 "Copco 1 Target Power Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetPowerRelease" [@"t", "Copco 1"] := "Min"( $ "ReservoirData.TurbineCapacities" ["Copco 1", "Flow"], "Max"( "Min"( "Max"( "Max"( $ "ReservoirOperations.TargetRelease" [@"t", "Copco 1"] + $ "ReservoirOperations.IFRRelease" [@"t", "Copco 1"], $ "ReservoirOperations.Copco To Iron Gate Pass Thru" [] ), "SolveOutflow"( % "Copco 1 Reservoir", $ "Copco 1 Reservoir.Inflow" [], "ElevationToStorage"( % "Copco 1 Reservoir", $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Copco 1"] ), "PreviousStorage"( % "Copco 1 Reservoir" ), @"t" ) ), "SolveOutflow"( % "Copco 1 Reservoir", $ "Copco 1 Reservoir.Inflow" [], "ElevationToStorage"( % "Copco 1 Reservoir", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"] ), "PreviousStorage"( % "Copco 1 Reservoir" ), @"t" ) COMMENTED_BY "Check for low reservoir condiitons" ), 0.00000000 "cms" ) );

    END;

    RULE                 "Copco Iron Gate Pass Thru IFR Release";
    DESCRIPTION          "Releases water intended for Pass Thru Iron Gate IFR requirement.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Copco To Iron Gate Pass Thru" [] := "Min"( $ "ReservoirData.TurbineCapacities" ["Copco 1", "Flow"], "Max"( "Min"( "Max"( $ "ReservoirOperations.Iron Gate ENV Release" COMMENTED_BY "Iron Gate IFR minus downstream gains" [] - $ "Copco to Iron Gate Gain.Local Inflow" [], $ "ReservoirOperations.IFRRelease" COMMENTED_BY "Copco IFR minus downstream gains" [@"t", "Copco 1"] - $ "Copco to Iron Gate Gain.Local Inflow" [] ), "SolveOutflow"( % "Copco 1 Reservoir", $ "Copco 1 Reservoir.Inflow" [], "ElevationToStorage"( % "Copco 1 Reservoir", 0.50000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Copco 1"] + $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"] ) ), "PreviousStorage"( % "Copco 1 Reservoir" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions" ), 0.00000000 "cms" ) );

    END;

    RULE                 "Copco IFR Release";
    DESCRIPTION          "Compute local IFR (fish bypass) (as opposed to water needed for Iron Gate Pass Thru IFR.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Copco 1"] := "Max"( "Min"( "Min"( $ "Copco 1 Reservoir.Inflow" [], "Min"( $ "ReservoirData.MinRelease" [@"t", "Copco 1 Reservoir"], "GetMaxReleaseGivenInflow"( % "Copco 1 Reservoir", $ "Copco 1 Reservoir.Inflow" [], @"t" ) ) ), "SolveOutflow"( % "Copco 1 Reservoir", $ "Copco 1 Reservoir.Inflow" [], "ElevationToStorage"( % "Copco 1 Reservoir", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Copco 1"] ), "PreviousStorage"( % "Copco 1 Reservoir" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

    END;

    RULE                 "Copco 1 Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Copco 1"] := "DailyTargetStorageRelease"( % "Copco 1 Reservoir", "Copco 1 Reservoir", @"t", "PreviousStorage"( % "Copco 1 Reservoir" ), $ "Copco 1 Reservoir.Inflow" [] );

    END;

    RULE                 "Boyle Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "JC Boyle Reservoir.Regulated Spill" [] := "Max"( 0.00000000 "cms", "Min"( "MaxMinElevationCheck"( % "JC Boyle Reservoir", "JC Boyle Reservoir", "Max"( "Max"( 0.00000000 "cms", $ "ReservoirOperations.TargetRelease" [@"t", "Boyle"] + $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"] - $ "JC Boyle Reservoir.Diversion" [] ) COMMENTED_BY "Target release plus IFR release minus power diversion", "Max"( 0.00000000 "cms", $ "ReservoirOperations.Boyle To Iron Gate Pass Thru" [] - $ "JC Boyle Reservoir.Diversion" [] ) COMMENTED_BY "Pass Thru Keno IFR minus power diversion and fish release" ) ), "GetMaxOutflowGivenInflow"( % "JC Boyle Reservoir", $ "JC Boyle Reservoir.Inflow" [], @"t" ) ) - "Min"( $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"], "GetMaxReleaseGivenInflow"( % "JC Boyle Reservoir", $ "JC Boyle Reservoir.Inflow" [], @"t" ) ) COMMENTED_BY "IFR fish bypass" );

      $ "JC Boyle Reservoir.Release" [] := "Min"( $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"], "GetMaxReleaseGivenInflow"( % "JC Boyle Reservoir", $ "JC Boyle Reservoir.Inflow" [], @"t" ) );

    END;

    RULE                 "Boyle Power Diversion";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "JC Boyle Reservoir.Diversion" [] := $ "ReservoirOperations.TargetPowerRelease" [@"t", "Boyle"];

    END;

    RULE                 "Boyle Target Power Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetPowerRelease" [@"t", "Boyle"] := "Min"( $ "ReservoirData.TurbineCapacities" ["Boyle", "Flow"], "Max"( "Min"( "Max"( "Max"( $ "ReservoirOperations.TargetRelease" [@"t", "Boyle"] + $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"], $ "ReservoirOperations.Boyle To Iron Gate Pass Thru" COMMENTED_BY "Pass Thru Keno IFR" [] ), "SolveOutflow"( % "JC Boyle Reservoir", $ "JC Boyle Reservoir.Inflow" [], "ElevationToStorage"( % "JC Boyle Reservoir", $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Boyle"] ), "PreviousStorage"( % "JC Boyle Reservoir" ), @"t" ) ), "SolveOutflow"( % "JC Boyle Reservoir", $ "JC Boyle Reservoir.Inflow" [], "ElevationToStorage"( % "JC Boyle Reservoir", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"] ), "PreviousStorage"( % "JC Boyle Reservoir" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions" ) - $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"], 0.00000000 "cms" ) );

    END;

    RULE                 "Boyle Iron Gate Pass Thru IFR Release";
    DESCRIPTION          "Releases water intended for Pass Thru Iron Gate IFR requirement.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Boyle To Iron Gate Pass Thru" [] := "Max"( "Min"( "Max"( ( $ "ReservoirOperations.Iron Gate ENV Release" COMMENTED_BY "Iron Gate IFR minus downstream gains" [] - ( $ "Boyle Bypass Reach.Local Inflow" [] + $ "Boyle Gage to Copco Gain.Local Inflow" [] + $ "Copco to Iron Gate Gain.Local Inflow" [] ) ) COMMENTED_BY "Iron Gate IFR minus downstream gains", $ "ReservoirOperations.IFRRelease" COMMENTED_BY "Boyle IFR minus downstream gains" [@"t", "Boyle"] - ( $ "Boyle Bypass Reach.Local Inflow" [] + $ "Boyle Gage to Copco Gain.Local Inflow" [] ) ), "SolveOutflow"( % "JC Boyle Reservoir", $ "JC Boyle Reservoir.Inflow" [], "ElevationToStorage"( % "JC Boyle Reservoir", 0.50000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Boyle"] + $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"] ) ), "PreviousStorage"( % "JC Boyle Reservoir" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions" ), 0.00000000 "cms" );

    END;

    RULE                 "Boyle IFR Release";
    DESCRIPTION          "Compute local IFR (fish bypass) (as opposed to Pass Thru IFR at Keno that is needed for Iron Gate Pass Thru IFR.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"] := "Max"( "Min"( "Min"( $ "JC Boyle Reservoir.Inflow" [], "Min"( $ "ReservoirData.MinRelease" [@"t", "JC Boyle Reservoir"] - "Min"( $ "Boyle Bypass Reach.Local Inflow" [], 0.00000000 "cms" ), "GetMaxOutflowGivenInflow"( % "JC Boyle Reservoir", $ "JC Boyle Reservoir.Inflow" [], @"t" ) ) ), "SolveOutflow"( % "JC Boyle Reservoir", $ "JC Boyle Reservoir.Inflow" [], "ElevationToStorage"( % "JC Boyle Reservoir", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Boyle"] ), "PreviousStorage"( % "JC Boyle Reservoir" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

    END;

    RULE                 "Boyle Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Boyle"] := "DailyTargetStorageRelease"( % "JC Boyle Reservoir", "JC Boyle Reservoir", @"t", "PreviousStorage"( % "JC Boyle Reservoir" ), $ "JC Boyle Reservoir.Inflow" [] );

    END;

    RULE                 "Power Reservoirs Target Elevation Releases";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Boyle"] := "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "JC Boyle Reservoir", "JC Boyle Reservoir", $ "Keno To Iron Gate Routing.Outflow", @"t", "DateMin"( @"t + 2", "RunEndDate"(  ) ) ), @"t", "DateMin"( @"t + 2", "RunEndDate"(  ) ) );

      $ "ReservoirOperations.TargetRelease" [@"t", "Copco 1"] := "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "Copco 1 Reservoir", "Copco 1 Reservoir", $ "Keno To Iron Gate Routing.Outflow", @"t", "DateMin"( @"t + 6", "RunEndDate"(  ) ) ), @"t", "DateMin"( @"t + 6", "RunEndDate"(  ) ) );

      $ "ReservoirOperations.TargetRelease" [@"t", "Iron Gate"] := "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "Iron Gate Reservoir", "Iron Gate Reservoir", $ "Keno To Iron Gate Routing.Outflow", @"t", "DateMin"( @"t + 6", "RunEndDate"(  ) ) ), @"t", "DateMin"( @"t + 6", "RunEndDate"(  ) ) );

    END;

    RULE                 "Power Reservoirs Target Elevations";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetElevation" [@"t", "JC Boyle Reservoir"] := IF ( "SumFlowsToVolumeSkipNaN"( $ "Upper Klamath Lake To Keno Routing.Outflow", "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 2", "RunEndDate"(  ) ) ) - "SumFlowValueToVolume"( "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 2", "RunEndDate"(  ) ), $ "ReservoirData.TurbineCapacities" ["Boyle", "Flow"] ) > "Max"( 0.00000000 "m3", "PreviousStorage"( % "JC Boyle Reservoir" ) - "ElevationToStorage"( % "JC Boyle Reservoir", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"] ) ) )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"]
 ELSE
  $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Boyle"]
 ENDIF;

      $ "ReservoirOperations.TargetElevation" [@"t", "Copco 1 Reservoir"] := IF ( "SumFlowsToVolumeSkipNaN"( $ "Upper Klamath Lake To Keno Routing.Outflow", "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 6", "RunEndDate"(  ) ) ) - "SumFlowValueToVolume"( "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 6", "RunEndDate"(  ) ), $ "ReservoirData.TurbineCapacities" ["Copco 1", "Flow"] ) > "Max"( 0.00000000 "m3", "PreviousStorage"( % "Copco 1 Reservoir" ) - "ElevationToStorage"( % "Copco 1 Reservoir", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"] ) ) )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"]
 ELSE
  $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Copco 1"]
 ENDIF;

      $ "ReservoirOperations.TargetElevation" [@"t", "Iron Gate Reservoir"] := IF ( "SumFlowsToVolumeSkipNaN"( $ "Keno To Iron Gate Routing.Outflow", "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 6", "RunEndDate"(  ) ) ) - "SumFlowValueToVolume"( "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 6", "RunEndDate"(  ) ), $ "ReservoirData.TurbineCapacities" ["Iron Gate", "Flow"] ) > "Max"( 0.00000000 "m3", "PreviousStorage"( % "Iron Gate Reservoir" ) - "ElevationToStorage"( % "Iron Gate Reservoir", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) ) )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"]
 ELSE
  $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"]
 ENDIF;

    END;

    RULE                 "Power Reservoirs Target Elevations No Forecast";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetElevation" [@"t", "JC Boyle Reservoir"] := IF ( $ "JC Boyle Reservoir.Pool Elevation" [@"t - 1"] > $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Boyle"] OR $ "Iron Gate Reservoir.Unregulated Spill" [@"t - 1"] > 0.00000000 "cms" )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"]
 ELSE
  IF ( $ "Upper Klamath Lake.Spill" [@"t"] > 0.00000000 "cms" )
  THEN
   $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"]
  ELSE
   $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Boyle"]
  ENDIF
 ENDIF;

      $ "ReservoirOperations.TargetElevation" [@"t", "Copco 1 Reservoir"] := IF ( $ "Copco 1 Reservoir.Pool Elevation" [@"t - 1"] > $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Copco 1"] OR $ "Iron Gate Reservoir.Unregulated Spill" [@"t - 1"] > 0.00000000 "cms" )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"]
 ELSE
  IF ( $ "Upper Klamath Lake.Spill" [@"t"] > 0.00000000 "cms" )
  THEN
   $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"]
  ELSE
   $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Copco 1"]
  ENDIF
 ENDIF;

      $ "ReservoirOperations.TargetElevation" [@"t", "Iron Gate Reservoir"] := IF ( $ "Iron Gate Reservoir.Pool Elevation" [@"t - 1"] > $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] OR $ "Iron Gate Reservoir.Unregulated Spill" [@"t - 1"] > 0.00000000 "cms" OR $ "Iron Gate Reservoir.Unregulated Spill" [@"t - 2"] > 0.00000000 "cms" )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"]
 ELSE
  IF ( $ "Upper Klamath Lake.Spill" [@"t"] > 0.00000000 "cms" )
  THEN
   $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"]
  ELSE
   $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"]
  ENDIF
 ENDIF;

    END;

    RULE                 "Set Keno Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Keno Dam.Outflow" [] := "MaxMinElevationCheck"( % "Keno Dam", "Keno Reservoir", "MaxItem"( { $ "ReservoirOperations.TargetRelease" [@"t", "Keno"] , $ "ReservoirOperations.Keno To Iron Gate Pass Thru" [] , $ "ReservoirOperations.IFRRelease" [@"t", "Keno"] } ) );

    END;

    RULE                 "Keno Dam Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Keno"] := "DailyTargetStorageRelease"( % "Keno Dam", "Keno Reservoir", @"t", "PreviousStorage"( % "Keno Dam" ), $ "Keno Dam.Inflow" [] );

    END;

    RULE                 "Keno Dam Iron Gate Pass Thru IFR Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Keno To Iron Gate Pass Thru" [] := "Max"( "Min"( "Max"( ( $ "ReservoirOperations.Iron Gate ENV Release" COMMENTED_BY "Iron Gate IFR minus downstream gains" [] - $ "Keno To Iron Gate Gain.Local Inflow" [] ), $ "ReservoirOperations.IFRRelease" [@"t", "Keno"] COMMENTED_BY "Keno IFR minus downstream gains" - $ "Keno to Boyle Gain.Local Inflow" [] ), "SolveOutflow"( % "Keno Dam", $ "Keno Dam.Inflow" [], "ElevationToStorage"( % "Keno Dam", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Keno Dam"] ), "PreviousStorage"( % "Keno Dam" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions" ), 0.00000000 "cms" );

    END;

    RULE                 "Keno Dam Instream Flow Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Keno"] := "Max"( "Min"( "Min"( $ "Keno Dam.Inflow" [], "Min"( $ "ReservoirData.MinRelease" [@"t", "Keno Reservoir"], "GetMaxReleaseGivenInflow"( % "Keno Dam", $ "Keno Dam.Inflow" [], @"t" ) ) ), "SolveOutflow"( % "Keno Dam", $ "Keno Dam.Inflow" [], "ElevationToStorage"( % "Keno Dam", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Keno Dam"] ), "PreviousStorage"( % "Keno Dam" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

    END;

  END;

  POLICY_GROUP   "Klamath Project Operations";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Compute Lagged Refuge Returns";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "LaggedRefugePermanentWetlandsReturns.Inflow" [] := 0.00000000 "cms";

      $ "LaggedRefugePermanentWetlandsReturns.Inflow" [] := $ "RefugeData.AccumulatedSupplies" [@"t", "Permanent Wetlands"] * ( $ "RefugeData.KBPMRefugeReturnFractions" [@"t", "Permanent Wetlands"] / "GetDaysInMonth"( @"t" ) );

      $ "LaggedRefugeSeasonalWetlandsReturns.Return Flow" [] := $ "RefugeData.AccumulatedSupplies" [@"t", "Seasonal Wetlands"] * ( $ "RefugeData.KBPMRefugeReturnFractions" [@"t", "Seasonal Wetlands"] / "GetDaysInMonth"( @"t" ) );

      $ "LaggedRefugeOpenWaterReturns.Return Flow" [] := $ "RefugeData.AccumulatedSupplies" [@"t", "Open Water"] * ( $ "RefugeData.KBPMRefugeReturnFractions" [@"t", "Open Water"] / "GetDaysInMonth"( @"t" ) );

      $ "LaggedRefugeCropReturns.Return Flow" [] := $ "RefugeData.AccumulatedSupplies" [@"t", "Crops"] * ( $ "RefugeData.KBPMRefugeReturnFractions" [@"t", "Crops"] / "GetDaysInMonth"( @"t" ) );

    END;

    RULE                 "Accumulate Refuge Supplies";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "RefugeData.AccumulatedSupplies" [@"t", "Permanent Wetlands"] := IF ( @"t" == @"Start Timestep" )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( @"t" == "NumberToDate"( $ "RefugeData.DeliveryFactors" ["Permanent Wetlands", "Supply Rollover Date"] ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "RefugeData.AccumulatedSupplies" [@"t - 1", "Permanent Wetlands"] + "FlowToVolume"( $ "Refuge:Permanent Wetlands.Diversion" [], @"t" )
  ENDIF
 ENDIF;

      $ "RefugeData.AccumulatedSupplies" [@"t", "Seasonal Wetlands"] := IF ( @"t" == @"Start Timestep" )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( @"t" == "NumberToDate"( $ "RefugeData.DeliveryFactors" ["Seasonal Wetlands", "Supply Rollover Date"] ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "RefugeData.AccumulatedSupplies" [@"t - 1", "Seasonal Wetlands"] + "FlowToVolume"( $ "Refuge:Seasonal Wetlands.Diversion" [], @"t" )
  ENDIF
 ENDIF;

      $ "RefugeData.AccumulatedSupplies" [@"t", "Open Water"] := IF ( @"t" == @"Start Timestep" )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( @"t" == "NumberToDate"( $ "RefugeData.DeliveryFactors" ["Open Water", "Supply Rollover Date"] ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "RefugeData.AccumulatedSupplies" [@"t - 1", "Open Water"] + "FlowToVolume"( $ "Refuge:Open Water.Diversion" [], @"t" )
  ENDIF
 ENDIF;

      $ "RefugeData.AccumulatedSupplies" [@"t", "Crops"] := IF ( @"t" == @"Start Timestep" )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( @"t" == "NumberToDate"( $ "RefugeData.DeliveryFactors" ["Crops", "Supply Rollover Date"] ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "RefugeData.AccumulatedSupplies" [@"t - 1", "Crops"] + "FlowToVolume"( $ "Refuge:Crops.Diversion" [], @"t" )
  ENDIF
 ENDIF;

    END;

    RULE                 "Accumulate Area 2 Diversion Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.AccumulatedArea2Supply" [] := IF ( @"t" == @"24:00:00 October 1, Current Year" )
 THEN
  "FlowToVolume"( $ "ProjectData.IrrigationSupplies" [@"t", "Area2"], @"t" )
 ELSE
  $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"] + "FlowToVolume"( $ "ProjectData.IrrigationSupplies" [@"t", "Area2"], @"t" )
 ENDIF;

    END;

    RULE                 "Set Available to Area2";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Area2 Supply.Outflow" [] := "Min"( $ "Area2.Diversion Requested" [], "Max"( "VolumeToFlow"( "PreviousStorage"( % "Area2 Supply" ) - "ElevationToStorage"( % "Area2 Supply", $ "InitialConditions.Area 2 Supply" [] ), @"t" ) + $ "North Canal.Diversion" [] + $ "Ady Canal.Diversion" [] - $ "Refuge.Total Available Water" [], 0.00000000 "cms" ) );

    END;

    RULE                 "Reconcile Total Supplies";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "KDDWaterRight"] := $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"];

      $ "ProjectData.KDDWaterRightSupply" [] := $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"];

      $ "ProjectData.IrrigationSupplies" [@"t", "Area1"] := $ "Klamath River To Area1.Diversion" [] + $ "A Canal.Diversion" [] + $ "Lost River To Area1.Diversion" [];

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1"] := $ "Klamath River To Area1.Diversion" [] + $ "A Canal.Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"];

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectViaUKL"] := $ "A Canal.Available For Diversion" [] + $ "Klamath River To Area1.Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"];

      $ "ProjectData.LostToArea2SpringSummer" [] := $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"];

      $ "ProjectData.IrrigationSupplies" [@"t", "Project"] := $ "A Canal.Available For Diversion" [] + $ "Klamath River To Area1.Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"] + ( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] );

      $ "ProjectData.IrrigationSupplies" [@"t", "IrrigationTotal"] := $ "A Canal.Available For Diversion" [] + $ "Klamath River To Area1.Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + ( $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] ) + ( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectIrrigation"] := $ "A Canal.Available For Diversion" [] + $ "Klamath River To Area1.Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"];

    END;

    RULE                 "Reconcile Supplies";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "NorthCanal"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "NorthCanal"] COMMENTED_BY "Initial North Supply" - $ "North Canal.Diversion Shortage" [] COMMENTED_BY "North Shortage", 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "AdyCanal"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "AdyCanal"] COMMENTED_BY "Initial Ady Supply" - $ "Ady Canal.Diversion Shortage" [] COMMENTED_BY "Ady Shortage", 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] COMMENTED_BY "Initial Supply" - $ "North Canal.Diversion Shortage" [] COMMENTED_BY "Shortage", 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] COMMENTED_BY "Initial Supply" - $ "Ady Canal.Diversion Shortage" [] COMMENTED_BY "Shortage", 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "Area2"] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"], 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] COMMENTED_BY "Initial Supply" - $ "North Canal.Diversion Shortage" [] COMMENTED_BY "Shortage", 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] COMMENTED_BY "Initial Supply" - $ "Klamath River To Area1.Diversion Shortage" [] COMMENTED_BY "Shortage", 0.00000000 "cms" );

    END;

    RULE                 "Set Available To Refuge";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC RefugeShortage = "Min"( $ "ProjectData.IrrigationSupplies" [@"t", "Refuge"], $ "Ady Canal.Diversion Shortage" [] )) DO
            $ "ProjectData.RefugeSupplyShortage" [] := RefugeShortage;

            $ "Refuge.Total Available Water" [] := "MinItem"( { $ "Refuge.Total Diversion Requested" [] , $ "ProjectData.IrrigationSupplies" [@"t", "Refuge"] - RefugeShortage , "VolumeToFlow"( "PreviousStorage"( % "Area2 Supply" ), @"t" ) } );

            $ "ProjectData.IrrigationSupplies" [@"t", "Refuge"] := $ "ProjectData.IrrigationSupplies" [@"t", "Refuge"] - RefugeShortage;

            $ "ProjectData.AdyToArea2SupplyShortage" [] := $ "Ady Canal.Diversion Shortage" [] - RefugeShortage;

            $ "ProjectData.IrrigationSupplies" [@"t", "Area2"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "Area2"] COMMENTED_BY "Initial Area 2 Supply" - ( $ "North Canal.Diversion Shortage" [] + ( $ "Ady Canal.Diversion Shortage" [] - RefugeShortage COMMENTED_BY "Refuge Shortage" ) ) COMMENTED_BY "Area 2 Shortage", 0.00000000 "cms" );

            $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] COMMENTED_BY "Initial Supply" - $ "North Canal.Diversion Shortage" [] COMMENTED_BY "Shortage", 0.00000000 "cms" );

            $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] COMMENTED_BY "Initial Supply" - ( $ "Ady Canal.Diversion Shortage" [] - RefugeShortage COMMENTED_BY "Refuge Shortage" ) COMMENTED_BY "Shortage", 0.00000000 "cms" );

      END_WITH_STATEMENT;

    END;

    RULE                 "Set Available to Ady Canal";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Ady Canal.Available For Diversion" [] := "MinItem"( { $ "ProjectData.IrrigationSupplies" [@"t", "AdyCanal"] , "Max"( $ "Diversion To Ady.Inflow" [] - "Max"( $ "ReservoirOperations.UKL To Iron Gate Total IFR Pass Thru" [], $ "ReservoirOperations.UKL To Keno IFR Pass Thru" [] ), 0.00000000 "cms" ) , $ "Ady Canal.Max Diversion" [0.00000000, 0.00000000] } );

      $ "Ady Canal.Diversion Request" [] := $ "ProjectData.IrrigationSupplies" [@"t", "AdyCanal"];

    END;

    RULE                 "Set Available to North Canal";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "North Canal.Available For Diversion" [] := "MinItem"( { $ "ProjectData.IrrigationSupplies" [@"t", "NorthCanal"] , "Max"( $ "Diversion To North.Inflow" [] - "Max"( $ "ReservoirOperations.UKL To Iron Gate Total IFR Pass Thru" [], $ "ReservoirOperations.UKL To Keno IFR Pass Thru" [] ), 0.00000000 "cms" ) , $ "North Canal.Max Diversion" [0.00000000, 0.00000000] } );

      $ "North Canal.Diversion Request" [] := $ "ProjectData.IrrigationSupplies" [@"t", "NorthCanal"];

    END;

    RULE                 "Set Available to Area 1 via Klamath River";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Klamath River To Area1.Available For Diversion" [] := "MinItem"( { $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] , "Max"( $ "Klamath Diversion To Area1.Inflow" [] - "Max"( $ "ReservoirOperations.UKL To Iron Gate Total IFR Pass Thru" [], $ "ReservoirOperations.UKL To Keno IFR Pass Thru" [] ), 0.00000000 "cms" ) , $ "Klamath River To Area1.Max Diversion" [0.00000000, 0.00000000] } );

      $ "Klamath River To Area1.Diversion Request" [] := $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"];

    END;

    RULE                 "Route UKL To Iron Gate Pass Thru Water";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "UKL To Keno Gain.Inflow" [] := $ "ReservoirOperations.UKL To Iron Gate Total IFR Pass Thru" [];

      $ "UKL To Keno Gain.Local Inflow" [] := $ "Lost River To Klamath River.Inflow2" [] + $ "Lake Ewuana Gain.Local Inflow" [] - $ "ProjectData.LostToArea2SpringSummer" [];

    END;

    RULE                 "Compute EWA Used";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.EWAUsed" [] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( @"t" == @"24:00:00 March 1, Current Year" )
  THEN
   "FlowToVolume"( $ "ReservoirOperations.UKL Environmental Release" [], @"t" ) + "FlowToVolume"( $ "ReservoirOperations.UKL Incremental Excess Water" COMMENTED_BY "C1_EXC" [], @"t" )
  ELSE
   $ "ProjectData.EWAUsed" [@"t - 1"] + "FlowToVolume"( $ "ReservoirOperations.UKL Environmental Release" [], @"t" ) + "FlowToVolume"( $ "ReservoirOperations.UKL Incremental Excess Water" COMMENTED_BY "C1_EXC" [], @"t" ) - "FlowToVolume"( $ "ProjectData.ProjectReleaseForIronGateMin" [], @"t" )
  ENDIF
 ENDIF;

    END;

    RULE                 "Set UKL Incremental Excess Water";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Incremental Excess Water" [] := "Max"( 0.00000000 "cms", $ "Upper Klamath Lake.Outflow" [@"t"] - $ "ReservoirOperations.UKL Environmental Release" [@"t"] - $ "ReservoirOperations.UKL Demand Release" [@"t"] );

    END;

    RULE                 "Set UKL Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Upper Klamath Lake.Outflow" [] := "MinItem"( { $ "ReservoirData.MaxRelease" [@"t", "Upper Klamath Lake"] , "MaxMinElevationCheck"( % "Upper Klamath Lake", "Upper Klamath Lake", $ "ReservoirOperations.UKL Tentative Release" [] ) , "GetMaxOutflowGivenInflow"( % "Upper Klamath Lake", $ "Upper Klamath Lake.Inflow" [], @"t" ) } );

    END;

    RULE                 "UKL Tenative Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Tentative Release" [] := "MaxItem"( { $ "ReservoirOperations.UKL Excess Water Release" [] , ( $ "ReservoirOperations.UKL Demand Release" [] + $ "ReservoirOperations.UKL Environmental Release" [] ) , $ "ReservoirOperations.IFRRelease" [@"t", "Upper Klamath"] } );

    END;

    RULE                 "UKL Demand Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Demand Release" [] := ( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"] + $ "ProjectData.KDDWaterRightSupply" [] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] ) COMMENTED_BY "Committed deliveries" - "Min"( $ "Lake Ewuana Gain.Local Inflow" [@"t - 1"], 0.00000000 "cms" ) COMMENTED_BY "Protect demands from negative gains";

    END;

    RULE                 "Set Total Supplies";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "NorthCanal"] := $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"];

      $ "ProjectData.IrrigationSupplies" [@"t", "AdyCanal"] := $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"];

      $ "ProjectData.IrrigationSupplies" [@"t", "Refuge"] := $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"];

      $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] := "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "ACanal"] := $ "A Canal.Available For Diversion" [];

      $ "ProjectData.LostToArea2SpringSummer" [] := $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"];

      $ "ProjectData.IrrigationSupplies" [@"t", "Area1ViaUKL"] := $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + $ "A Canal.Diversion" [];

      $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"] := "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] );

      $ "ProjectData.IrrigationSupplies" [@"t", "Area1"] := $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + $ "A Canal.Diversion" [] + $ "Lost River To Area1.Diversion" [];

      $ "ProjectData.IrrigationSupplies" [@"t", "Area2"] := $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDWaterRight"] + ( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1"] := $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + $ "A Canal.Diversion" [] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectViaLRDC"] := "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" ) + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"];

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectViaUKL"] := $ "A Canal.Available For Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ) + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"];

      $ "ProjectData.IrrigationSupplies" [@"t", "Project"] := $ "A Canal.Available For Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ) + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"] + ( "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" ) COMMENTED_BY "LRDC to Area1" + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] );

      $ "ProjectData.IrrigationSupplies" [@"t", "IrrigationTotal"] := $ "A Canal.Available For Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ) + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDWaterRight"] + ( "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" ) COMMENTED_BY "LRDC to Area1" + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectIrrigation"] := $ "A Canal.Available For Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ) + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + ( "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" ) COMMENTED_BY "LRDC to Area1" + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] );

    END;

    RULE                 "Compute Project Refuge Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"] := WITH NUMERIC canalCapacity = "Max"( $ "Diversion To Ady.Diversion Capacity" [] - ( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] ), 0.00000000 "cms" ) DO
  WITH NUMERIC remainingWaterSupply = "Max"( IF ( "NovemberThruFebruary"(  ) )
  THEN
   $ "ProjectData.FallWinterAvailableWater" []
  ELSE
   $ "ProjectData.SpringSummerAvailableWater" []
  ENDIF - ( ( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + $ "A Canal.Diversion" [] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ) ) COMMENTED_BY "Project to Area 1" + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"] ), 0.00000000 "cms" ) DO
   WITH NUMERIC kbpmSupply = IF ( "MarchThruJuly"(  ) AND NOT "ProjectIsFull"(  ) )
   THEN
    0.00000000 "cms"
   ELSE
    IF ( "AugustThruNovember"(  ) AND NOT "ProjectIsFull"(  ) )
    THEN
     $ "Refuge.Total Diversion Requested" [@"t"] COMMENTED_BY "should be refuge target volume divided by number of days..."
    ELSE
     IF ( "JuneThruNovember"(  ) AND "ProjectIsFull"(  ) AND $ "Upper Klamath Lake.Pool Elevation" [@"t - 1"] > $ "KBPMOperationsData.UKL_refuge_upper_thresh" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] )
     THEN
      $ "Refuge.Total Diversion Requested" [@"t"] COMMENTED_BY "should be refuge demand"
     ELSE
      IF ( "AugustThruNovember"(  ) AND "ProjectIsFull"(  ) AND $ "Upper Klamath Lake.Pool Elevation" [@"t - 1"] <= $ "KBPMOperationsData.UKL_refuge_upper_thresh" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] )
      THEN
       "Min"( $ "Refuge.Total Diversion Requested" [@"t"], "VolumeToFlow"( "RemainingProjectSupply"( @"t" ) * "AugNovRefugeProportion"( "RemainingProjectSupply"( @"t" ) ) * ( 1.00000000 - "Min"( $ "KBPMOperationsData.UKLAugNovAdjusttThreshold" [], "Max"( $ "KBPMOperationsData.UKL_refuge_adjust_thresh" [@"t"] - $ "Upper Klamath Lake.Pool Elevation" [@"t - 1"], 0.00000000 "m" ) ) / $ "KBPMOperationsData.UKLAugNovAdjusttThreshold" [] ), @"t" ) ) COMMENTED_BY "KBPM is refuge target volume divided by number of days"
      ELSE
       IF ( "DecemberThruFebruary"(  ) )
       THEN
        "Min"( $ "Refuge.Total Diversion Requested" [@"t"], $ "ProjectData.FallWinterAvailableWater" [@"t"] * $ "KBPMOperationsData.PercentRefugeSurFW" [] ) COMMENTED_BY "should be min of refuge demand and FWavail*pctRfgsurFW"
       ELSE
        0.00000000 "cms"
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF DO
    "MinItem"( { canalCapacity , remainingWaterSupply , kbpmSupply } )
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    RULE                 "Distribute Project To North and Ady";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC ProjectToNorth = IF ( "OctoberThruFebruary"(  ) )
 THEN
  "Min"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"], $ "Diversion To North.Diversion Capacity" [] )
 ELSE
  "Min"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"], "Max"( $ "Diversion To North.Diversion Capacity" [] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToNorth"], 0.00000000 "cms" ) )
 ENDIF) DO
            $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] := ProjectToNorth;

            $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"] - ProjectToNorth, 0.00000000 "cms" ), "Max"( $ "Diversion To Ady.Diversion Capacity" [] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToAdy"], 0.00000000 "cms" ) )
 ENDIF;

      END_WITH_STATEMENT;

    END;

    RULE                 "Project Supply To Area2";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  IF ( "SumFlowsToVolumeSkipNaN"( $ "ProjectData.KDDWaterRightSupply", IF ( "OctoberThruDecember"(  ) )
  THEN
   @"24:00:00 October 1, Current Year"
  ELSE
   @"24:00:00 October 1, Previous Year"
  ENDIF, @"t" ) >= $ "ProjectData.KDDVolumeRight" [] )
  THEN
   "MinItem"( { $ "ProjectData.FallWinterAvailableWater" [] , $ "Diversion To North.Diversion Capacity" [] + $ "Diversion To Ady.Diversion Capacity" [] , $ "ProjectData.DistributedArea2HeadgateDemand" [] } )
  ELSE
   0.00000000 "cms"
  ENDIF
 ELSE
  "MinItem"( { "Max"( $ "ProjectData.SpringSummerAvailableWater" [] - ( $ "A Canal.Available For Diversion" [] + $ "Klamath River To Area1.Available For Diversion" [] ) COMMENTED_BY "Area 1 Project Supply", 0.00000000 "cms" ) , $ "Diversion To North.Diversion Capacity" [] + $ "Diversion To Ady.Diversion Capacity" [] , "Max"( ( $ "ProjectData.DistributedArea2HeadgateDemand" [] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] ), 0.00000000 "cms" ) } )
 ENDIF;

    END;

    RULE                 "Area1 Project Supply From UKL Via Klamath River";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] := IF ( "DecemberThruFebruary"(  ) OR $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] > 0.00000000 "cms" OR $ "Area1:A1SouthOfLRDC.Supplemental Use Request" [] <= 0.00000000 "cms" )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( $ "Klamath River To Area1.Max Diversion" [0.00000000, 0.00000000], WITH NUMERIC remainingArea1Demand = "Max"( $ "Area1.Total Diversion Requested" [] - $ "Lost River To Area1.Diversion" [], 0.00000000 "cms" ) DO
   WITH NUMERIC remainingProjectDemand = remainingArea1Demand + "Max"( $ "ProjectData.DistributedArea2HeadgateDemand" [] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"], 0.00000000 "cms" ) DO
    IF ( remainingProjectDemand == 0.00000000 "cms" )
    THEN
     0.00000000 "cms"
    ELSE
     "Min"( "Max"( remainingArea1Demand / remainingProjectDemand * IF ( "MarchThruSeptember"(  ) )
     THEN
      $ "ProjectData.SpringSummerAvailableWater" []
     ELSE
      $ "ProjectData.FallWinterAvailableWater" []
     ENDIF - $ "A Canal.Diversion" [], 0.00000000 "cms" ), $ "Area1:A1SouthOfLRDC.Supplemental Use Request" [] )
    ENDIF
   ENDWITH
  ENDWITH COMMENTED_BY "Maintain Area 1 portion of project supply used for A Canal allocation." )
 ENDIF;

    END;

    RULE                 "A Canal Project Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "A Canal.Diversion Request" [] := $ "Area1.Total Diversion Requested" [];

      $ "A Canal.Available For Diversion" [] := "Min"( $ "A Canal.Max Diversion" [0.00000000, 0.00000000], WITH NUMERIC remainingArea1Demand = "Max"( $ "Area1.Total Diversion Requested" [] - $ "Lost River To Area1.Diversion" [], 0.00000000 "cms" ) DO
  WITH NUMERIC remainingProjectDemand = IF ( "MarchThruSeptember"(  ) )
  THEN
   remainingArea1Demand + "Max"( $ "ProjectData.DistributedArea2HeadgateDemand" [] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"], 0.00000000 "cms" )
  ELSE
   remainingArea1Demand
  ENDIF DO
   IF ( remainingProjectDemand == 0.00000000 "cms" )
   THEN
    0.00000000 "cms"
   ELSE
    "Min"( remainingArea1Demand / remainingProjectDemand * $ "ProjectData.SpringSummerAvailableWater" [], $ "Area1.Total Diversion Requested" [] - $ "Lost River To Area1.Diversion" [] )
   ENDIF
  ENDWITH
 ENDWITH );

      $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] := "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" );

    END;

    RULE                 "Distribute LRDC To North and Ady";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC LRDCToNorth = IF ( "OctoberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"], $ "Diversion To North.Diversion Capacity" [] )
 ENDIF) DO
            $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToNorth"] := LRDCToNorth;

            $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToAdy"] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] - LRDCToNorth, 0.00000000 "cms" ), $ "Diversion To Ady.Diversion Capacity" [] )
 ENDIF;

      END_WITH_STATEMENT;

    END;

    RULE                 "LRDC To Area2";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "MinItem"( { $ "Lost Diversion To Area1.Outflow" [] , $ "Diversion To North.Diversion Capacity" [] + $ "Diversion To Ady.Diversion Capacity" [] , $ "ProjectData.DistributedArea2HeadgateDemand" [] } )
 ENDIF;

    END;

    RULE                 "Distribute KDD Supply To North and Ady";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "KDDWaterRight"] := $ "ProjectData.KDDWaterRightSupply" [];

      WITH_STATEMENT (NUMERIC KDDToNorth = IF ( "OctoberThruFebruary"(  ) )
 THEN
  "Min"( $ "ProjectData.KDDWaterRightSupply" [], $ "Diversion To North.Diversion Capacity" [] )
 ELSE
  0.00000000 "cms"
 ENDIF) DO
            $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] := KDDToNorth;

            $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  "Min"( "Max"( $ "ProjectData.KDDWaterRightSupply" [] - KDDToNorth, 0.00000000 "cms" ), $ "Diversion To Ady.Diversion Capacity" [] )
 ELSE
  0.00000000 "cms"
 ENDIF;

      END_WITH_STATEMENT;

    END;

    RULE                 "Adjust Area 2 Demands After KDD Is Supplied";
    DESCRIPTION          "Reduces Area 2 canal demands after KDD is supplied so that not too much project water is diverted in winter.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.DistributedArea2HeadgateDemand" [] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  IF ( "SumFlowsToVolumeSkipNaN"( $ "ProjectData.KDDWaterRightSupply", IF ( "OctoberThruDecember"(  ) )
  THEN
   @"24:00:00 October 1, Current Year"
  ELSE
   @"24:00:00 October 1, Previous Year"
  ENDIF, @"t" ) >= $ "ProjectData.KDDVolumeRight" [] )
  THEN
   $ "Area2.Diversion Requested" []
  ELSE
   $ "ProjectData.DistributedArea2HeadgateDemand" []
  ENDIF
 ENDIF;

    END;

    RULE                 "KDD Water Right Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.KDDWaterRightSupply" [] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  "MinItem"( { "Max"( $ "Upper Klamath Lake.Inflow" [@"t - 1"] - ( ( $ "A Canal.Available For Diversion" [@"t - 1"] + $ "ReservoirOperations.UKL Demand Release" [@"t - 1"] ) COMMENTED_BY "yesterday deliveries" + IF ( @"t" == "RunStartDate"(  ) )
  THEN
   0.00000000 "cms"
  ELSE
   "VolumeToFlow"( $ "Upper Klamath Lake.Evaporation" [@"t - 1"] - $ "Upper Klamath Lake.Precipitation Volume" [@"t - 1"], @"t - 1" )
  ENDIF COMMENTED_BY "net evaporation" ), 0.00000000 "cms" ) COMMENTED_BY "Using this in lieu of a distributed historical supply" , "Min"( "Max"( $ "ProjectData.KDDFlowLimit" [], $ "Area2.Diversion Requested" [] ) COMMENTED_BY "Max of a reasonable daily limit and ET diversion request to avoid inadvertant shortages.", $ "ProjectData.KDDFlowRight" COMMENTED_BY "Min of actual daily water right" [] ) , "VolumeToFlow"( "Max"( $ "ProjectData.KDDVolumeRight" [] - IF ( @"t" == @"24:00:00 October 1, Current Year" )
  THEN
   0.00000000 "m3"
  ELSE
   "SumFlowsToVolumeSkipNaN"( $ "ProjectData.KDDWaterRightSupply", IF ( "OctoberThruDecember"(  ) )
   THEN
    @"24:00:00 October 1, Current Year"
   ELSE
    @"24:00:00 October 1, Previous Year"
   ENDIF, @"t - 1" )
  ENDIF, 0.00000000 "m3" ), @"t" ) , $ "Diversion To North.Diversion Capacity" [] + $ "Diversion To Ady.Diversion Capacity" [] } )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    RULE                 "KDD Water Right Supply NM1";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.KDDWaterRightSupply" [] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  "MinItem"( { "Max"( $ "Upper Klamath Lake.Inflow" [@"t - 1"] - ( 0.50000000 * ( $ "ReservoirOperations.UKL Environmental Release" [] + "MaxItem"( { $ "ProjectData.SpringSummerAvailableWater" [] , $ "ProjectData.FallWinterAvailableWater" [] , IF ( "OctoberThruNovember"(  ) )
  THEN
   "AverageDailyFlowForVolume"( "RemainingProjectSupply"( @"t" ), @"t", "GetDate"( "November 30, Current Year" ) )
  ELSE
   0.00000000 "cms"
  ENDIF } ) ) + IF ( @"t" == "RunStartDate"(  ) )
  THEN
   0.00000000 "cms"
  ELSE
   "VolumeToFlow"( $ "Upper Klamath Lake.Evaporation" [@"t - 1"] - $ "Upper Klamath Lake.Precipitation Volume" [@"t - 1"], @"t - 1" )
  ENDIF COMMENTED_BY "net evaporation" ), 0.00000000 "cms" ) COMMENTED_BY "Using this in lieu of a distributed historical supply" , "Min"( "Max"( $ "ProjectData.KDDFlowLimit" [], $ "Area2.Diversion Requested" [] ) COMMENTED_BY "Max of a reasonable daily limit and ET diversion request to avoid inadvertant shortages.", $ "ProjectData.KDDFlowRight" COMMENTED_BY "Min of actual daily water right" [] ) , "VolumeToFlow"( "Max"( $ "ProjectData.KDDVolumeRight" [] - IF ( @"t" == @"24:00:00 October 1, Current Year" )
  THEN
   0.00000000 "m3"
  ELSE
   "SumFlowsToVolumeSkipNaN"( $ "ProjectData.KDDWaterRightSupply", IF ( "OctoberThruDecember"(  ) )
   THEN
    @"24:00:00 October 1, Current Year"
   ELSE
    @"24:00:00 October 1, Previous Year"
   ENDIF, @"t - 1" )
  ENDIF, 0.00000000 "m3" ), @"t" ) , $ "Diversion To North.Diversion Capacity" [] + $ "Diversion To Ady.Diversion Capacity" [] } )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    RULE                 "Set Available Fall Winter Water";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.FallWinterAvailableWater" [] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  "MinItem"( { "Max"( $ "Upper Klamath Lake.Inflow" [@"t - 1"] - ( $ "ReservoirOperations.UKL Environmental Release" [] + $ "ReservoirOperations.UKLFillingFlow" [] + IF ( @"t" == "RunStartDate"(  ) )
  THEN
   0.00000000 "cms"
  ELSE
   "VolumeToFlow"( $ "Upper Klamath Lake.Evaporation" [@"t - 1"] - $ "Upper Klamath Lake.Precipitation Volume" [@"t - 1"], @"t - 1" )
  ENDIF COMMENTED_BY "net evaporation" ), 0.00000000 "cms" ) , $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] , "Max"( "SolveOutflow"( % "Upper Klamath Lake", $ "Upper Klamath Lake.Inflow" [], "ElevationToStorage"( % "Upper Klamath Lake", $ "KBPMOperationsData.MinFishElevation" [@"t", "Minimum"] ), "PreviousStorage"( % "Upper Klamath Lake" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions.", 0.00000000 "cms" ) } )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    RULE                 "Set UKL Filling Flow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKLFillingFlow" [] := IF ( "OctoberThruDecember"(  ) )
 THEN
  "MaxItem"( { "AverageDailyFlowForVolume"( "ElevationToStorage"( % "Upper Klamath Lake", $ "ReservoirOperations.TargetElevation" [@"24:00:00 December 31, Current Year", "Upper Klamath Lake"] ) - "PreviousStorage"( % "Upper Klamath Lake" ), @"t", @"24:00:00 December 31, Current Year" ) , "AverageDailyFlowForVolume"( "ElevationToStorage"( % "Upper Klamath Lake", $ "KBPMOperationsData.UKL_Fill_Target" [] ) - "PreviousStorage"( % "Upper Klamath Lake" ), @"t", @"24:00:00 February Max DayOfMonth, Next Year" ) , 0.00000000 "cms" } )
 ELSE
  IF ( "JanuaryThruFebruary"(  ) )
  THEN
   IF ( "EstimatedUKLInflow"( "GetDate"( "March 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) >= $ "KBPMOperationsData.UKLHighForecastThreshold" [] )
   THEN
    0.00000000 "cms"
   ELSE
    "MaxItem"( { "AverageDailyFlowForVolume"( "ElevationToStorage"( % "Upper Klamath Lake", $ "ReservoirOperations.TargetElevation" [@"24:00:00 April 30, Current Year", "Upper Klamath Lake"] ) - "PreviousStorage"( % "Upper Klamath Lake" ), @"t", @"24:00:00 April 30, Current Year" COMMENTED_BY "End date" ) , "AverageDailyFlowForVolume"( "ElevationToStorage"( % "Upper Klamath Lake", $ "KBPMOperationsData.UKL_Fill_Target" [] ) - "PreviousStorage"( % "Upper Klamath Lake" ), @"t", @"24:00:00 February Max DayOfMonth, Current Year" ) , 0.00000000 "cms" } )
   ENDIF
  ELSE
   0.00000000 "cms"
  ENDIF
 ENDIF;

    END;

    RULE                 " Set Today Spring Summer Available Water";
    DESCRIPTION          "This setup produces too many shortages.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.SpringSummerAvailableWater" [] := IF ( "DecemberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( WITH NUMERIC remainingProjectSupply = "RemainingProjectSupply"( @"t" ) DO
   "Min"( WITH NUMERIC remainingDemand = IF ( "MarchThruSeptember"(  ) )
   THEN
    "SumFlowsToVolume"( $ "Area1.Total Diversion Requested", @"t", "DateMin"( @"24:00:00 November 30, Current Year", "RunEndDate"(  ) ) ) + "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"t", "DateMin"( @"24:00:00 November 30, Current Year", "RunEndDate"(  ) ) )
   ELSE
    "SumFlowsToVolume"( $ "Area1.Total Diversion Requested", @"t", "DateMin"( @"24:00:00 November 30, Current Year", "RunEndDate"(  ) ) )
   ENDIF DO
    WITH NUMERIC todaysDemand = IF ( "MarchThruSeptember"(  ) )
    THEN
     $ "Area1.Total Diversion Requested" [] + $ "Area2.Diversion Requested" []
    ELSE
     $ "Area1.Total Diversion Requested" []
    ENDIF DO
     "Max"( IF ( remainingDemand == 0.00000000 "m3" )
     THEN
      todaysDemand
     ELSE
      remainingProjectSupply / remainingDemand * todaysDemand
     ENDIF, "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "DateMin"( @"24:00:00 November 30, Current Year", "RunEndDate"(  ) ) ) )
    ENDWITH
   ENDWITH, $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] )
  ENDWITH, "Max"( "SolveOutflow"( % "Upper Klamath Lake", $ "Upper Klamath Lake.Inflow" [], "ElevationToStorage"( % "Upper Klamath Lake", $ "KBPMOperationsData.MinFishElevation" [@"t", "Minimum"] ), "PreviousStorage"( % "Upper Klamath Lake" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions.", 0.00000000 "cms" ) )
 ENDIF;

    END;

    RULE                 " Set Today Spring Summer Available Water V4";
    DESCRIPTION          "This setup produces too many shortages.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.SpringSummerAvailableWater" [] := IF ( "DecemberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  WITH NUMERIC remainingProjectSupply = "RemainingProjectSupply"( @"t" ) DO
   "Min"( WITH NUMERIC remainingDistPercent = IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
   THEN
    1.00000000
   ELSE
    ( 1.00000000 - "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", "GetDate"( "March 1, Current Year" ), @"t - 1" ) )
   ENDIF DO
    "Max"( IF ( remainingDistPercent == 0.00000000 )
    THEN
     "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" )
    ELSE
     IF ( "OctoberThruNovember"(  ) )
     THEN
      "VolumeToFlow"( remainingProjectSupply / remainingDistPercent * $ "ProjectData.ProjectSupplyDailyDistribution" [], @"t" )
     ELSE
      "VolumeToFlow"( remainingProjectSupply / remainingDistPercent * ( $ "ProjectData.ProjectSupplyDailyDistribution" [] / "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", @"24:00:00 March 1, Current Year", @"24:00:00 September 30, Current Year" ) ), @"t" )
     ENDIF
    ENDIF, "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ) )
   ENDWITH, $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] )
  ENDWITH
 ENDIF;

    END;

    RULE                 " Set Today Spring Summer Available Water V2";
    DESCRIPTION          "This setup produces too many shortages.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.SpringSummerAvailableWater" [] := IF ( "DecemberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  WITH NUMERIC remainingProjectSupply = "RemainingProjectSupply"( @"t" ) DO
   "Min"( WITH NUMERIC remainingDistPercent = IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
   THEN
    1.00000000
   ELSE
    ( 1.00000000 - "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", "GetDate"( "March 1, Current Year" ), @"t - 1" ) )
   ENDIF DO
    "Max"( IF ( remainingDistPercent == 0.00000000 )
    THEN
     "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" )
    ELSE
     "VolumeToFlow"( remainingProjectSupply / remainingDistPercent * $ "ProjectData.ProjectSupplyDailyDistribution" [], @"t" )
    ENDIF, "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ) )
   ENDWITH, $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] )
  ENDWITH
 ENDIF;

    END;

    RULE                 " Set Today Spring Summer Available Water V2";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.SpringSummerAvailableWater" [] := IF ( "DecemberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  WITH NUMERIC remainingProjectSupply = "RemainingProjectSupply"( @"t" ) DO
   "Min"( IF ( "OctoberThruNovember"(  ) )
   THEN
    "Max"( "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ), "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" ) )
   ELSE
    WITH NUMERIC remainingDistPercent = IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
    THEN
     1.00000000
    ELSE
     ( 1.00000000 - "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", "GetDate"( "March 1, Current Year" ), @"t - 1" ) )
    ENDIF DO
     "Max"( IF ( remainingDistPercent == 0.00000000 )
     THEN
      "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" )
     ELSE
      "VolumeToFlow"( remainingProjectSupply / remainingDistPercent * $ "ProjectData.ProjectSupplyDailyDistribution" [], @"t" )
     ENDIF, "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ) )
    ENDWITH
   ENDIF, $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] )
  ENDWITH
 ENDIF;

    END;

    RULE                 " Set Today Spring Summer Available Water V1";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.SpringSummerAvailableWater" [] := IF ( "DecemberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  WITH NUMERIC remainingProjectSupply = "RemainingProjectSupply"( @"t" ) DO
   "Min"( IF ( "OctoberThruNovember"(  ) )
   THEN
    "Max"( "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ), "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" ) )
   ELSE
    WITH NUMERIC MarchSeptDistribution = "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", @"24:00:00 March 1, Current Year", @"24:00:00 September 30, Current Year" ) DO
     WITH NUMERIC remainingDistPercent = IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
     THEN
      1.00000000
     ELSE
      ( 1.00000000 - "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", "GetDate"( "March 1, Current Year" ), @"t - 1" ) )
     ENDIF DO
      "Max"( IF ( remainingDistPercent == 0.00000000 )
      THEN
       "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" )
      ELSE
       "VolumeToFlow"( remainingProjectSupply / remainingDistPercent * ( $ "ProjectData.ProjectSupplyDailyDistribution" [] / MarchSeptDistribution ), @"t" )
      ENDIF, "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ) )
     ENDWITH
    ENDWITH
   ENDIF, $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] )
  ENDWITH
 ENDIF;

    END;

    RULE                 "Accumulate UKL Project Deliveries";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.CumAgSpringSummerDelivery" [] := IF ( @"t" == @"Start Timestep" )
 THEN
  $ "ProjectData.CumAgSpringSummerDelivery" [@"t - 1"]
 ELSE
  IF ( "MarchThruSeptember"(  ) )
  THEN
   IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
   THEN
    0.00000000 "m3"
   ELSE
    $ "ProjectData.CumAgSpringSummerDelivery" [@"t - 1"] + "Max"( "FlowToVolume"( $ "ProjectData.IrrigationSupplies" [@"t - 1", "ProjectViaUKL"] - $ "ProjectData.IrrigationSupplies" [@"t - 1", "ProjectToRefuge"], @"t - 1" ), 0.00000000 "m3" )
   ENDIF
  ELSE
   $ "ProjectData.CumAgSpringSummerDelivery" [@"t - 1"]
  ENDIF
 ENDIF;

      $ "ProjectData.CumAgMarchThruFebruaryDelivery" [] := IF ( @"t" == @"Start Timestep" )
 THEN
  $ "ProjectData.CumAgMarchThruFebruaryDelivery" [@"t - 1"]
 ELSE
  IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "ProjectData.CumAgMarchThruFebruaryDelivery" [@"t - 1"] + "FlowToVolume"( $ "ProjectData.IrrigationSupplies" [@"t - 1", "ProjectViaUKL"], @"t - 1" )
  ENDIF
 ENDIF;

      $ "ProjectData.CumAgMarchThruNovDelivery" [] := IF ( @"t" == @"Start Timestep" )
 THEN
  $ "ProjectData.CumAgMarchThruNovDelivery" [@"t - 1"]
 ELSE
  IF ( "MarchThruNovember"(  ) )
  THEN
   IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
   THEN
    0.00000000 "m3"
   ELSE
    $ "ProjectData.CumAgSpringSummerDelivery" [@"t - 1"] + "FlowToVolume"( $ "ProjectData.IrrigationSupplies" [@"t - 1", "ProjectViaUKL"], @"t - 1" )
   ENDIF
  ELSE
   $ "ProjectData.CumAgSpringSummerDelivery" [@"t - 1"]
  ENDIF
 ENDIF;

    END;

    RULE                 "UKL Cumulative Excess Water Resease Volume";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Cumulative Excess Water Release Volume" [] := IF ( "MarchThruSeptember"(  ) )
 THEN
  IF ( "GetMonth"( @"t" ) == 3.00000000 AND "GetUnitlessDayOfMonth"( @"t" ) == 1.00000000 )
  THEN
   "FlowToVolume"( $ "ReservoirOperations.UKL Excess Water Release" [], @"t" )
  ELSE
   $ "ReservoirOperations.UKL Cumulative Excess Water Release Volume" [@"t - 1"] + "FlowToVolume"( $ "ReservoirOperations.UKL Excess Water Release" [], @"t" ) - "FlowToVolume"( $ "ProjectData.ProjectReleaseForIronGateMin" [], @"t" )
  ENDIF
 ELSE
  0.00000000 "m3"
 ENDIF;

    END;

    RULE                 "UKL Excess Water Release";
    DESCRIPTION          "This variable is intended to represent KBPM's C1_EXC variable.  It is water above release need to meet demands and Iron Gate and Keno instream flow requirements.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Excess Water Release" [] := "Min"( $ "ReservoirData.MaxRelease" [@"t", "Upper Klamath Lake"], "Max"( $ "ReservoirData.UKL ExcessRelease Adjustment" [@"t", "Upper Klamath Lake"] * $ "ReservoirOperations.TargetRelease" [@"t", "Upper Klamath"] + $ "ReservoirOperations.UKL Demand Release" ["DateMax"( "RunStartDate"(  ), @"t - 1" )] + $ "ReservoirOperations.UKL Environmental Release" [], $ "ReservoirOperations.UKL Flood Control Release" [] ) );

    END;

    RULE                 "UKL Flood Control Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Flood Control Release" [] := IF ( "JanuaryThruApril"(  ) )
 THEN
  WITH NUMERIC coeFloodControl = "DailyFloodControlRelease"( % "Upper Klamath Lake", "Upper Klamath Lake", "GetDate"( "April 30, Current Year" ), $ "ReservoirData.MaxRelease" [@"t", "Upper Klamath Lake"], "EstimatedUKLInflow"( @"t", "GetDate"( "April 30, Current Year" ) ) ) DO
   "MaxItem"( { coeFloodControl , "DailyMaximumStorageRelease"( % "Upper Klamath Lake", "Upper Klamath Lake", @"t", "PreviousStorage"( % "Upper Klamath Lake" ), 0.50000000 * ( $ "Upper Klamath Lake.Inflow" [] + $ "Upper Klamath Lake.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ) , "DailyFloodControlRelease"( % "Upper Klamath Lake", "Upper Klamath Lake", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ), $ "ReservoirData.MaxRelease" [@"t", "Upper Klamath Lake"], "SumFlowsToVolumeSkipNaN"( $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) ) } )
  ENDWITH
 ELSE
  "Max"( "DailyMaximumStorageRelease"( % "Upper Klamath Lake", "Upper Klamath Lake", @"t", "PreviousStorage"( % "Upper Klamath Lake" ), 0.50000000 * ( $ "Upper Klamath Lake.Inflow" [] + $ "Upper Klamath Lake.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ), "DailyFloodControlRelease"( % "Upper Klamath Lake", "Upper Klamath Lake", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ), $ "ReservoirData.MaxRelease" [@"t", "Upper Klamath Lake"], "SumFlowsToVolumeSkipNaN"( $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) ) )
 ENDIF;

    END;

    RULE                 "UKL Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Upper Klamath"] := IF ( "DecisionDate"( @"t", $ "ReservoirData.DecisionDates", "Normal" ) OR $ "Upper Klamath Lake.Pool Elevation" [@"t - 1"] > 0.50000000 * ( $ "ReservoirOperations.TargetElevation" [@"t", "Upper Klamath Lake"] + $ "ReservoirData.MaxElevation" [@"t", "Upper Klamath Lake"] ) OR $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"] > 0.00000000 "cms" )
 THEN
  "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "Upper Klamath Lake", "Upper Klamath Lake", $ "UKLShortTermForecast.Local Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
 ELSE
  $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"]
 ENDIF;

    END;

    RULE                 "UKL Target Release Jan thru April Forecast";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Upper Klamath"] := IF ( "DecisionDate"( @"t", $ "ReservoirData.DecisionDates", "Normal" ) OR $ "Upper Klamath Lake.Pool Elevation" [@"t - 1"] > 0.50000000 * ( $ "ReservoirOperations.TargetElevation" [@"t", "Upper Klamath Lake"] + $ "ReservoirData.MaxElevation" [@"t", "Upper Klamath Lake"] ) OR $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"] > 0.00000000 "cms" )
 THEN
  IF ( "OctoberThruDecember"(  ) )
  THEN
   "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "Upper Klamath Lake", "Upper Klamath Lake", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
  ELSE
   IF ( "JanuaryThruApril"(  ) )
   THEN
    "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "Upper Klamath Lake", "Upper Klamath Lake", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
   ELSE
    "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "Upper Klamath Lake", "Upper Klamath Lake", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "May through September"
   ENDIF
  ENDIF
 ELSE
  $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"]
 ENDIF;

    END;

    RULE                 "UKL Target Release With June thru Sept Forecast";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Upper Klamath"] := IF ( "DecisionDate"( @"t", $ "ReservoirData.DecisionDates", "Normal" ) OR $ "Upper Klamath Lake.Pool Elevation" [@"t - 1"] > $ "ReservoirOperations.TargetElevation" [@"t", "Upper Klamath Lake"] OR $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"] > 0.00000000 "cms" )
 THEN
  IF ( "OctoberThruDecember"(  ) )
  THEN
   "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "Upper Klamath Lake", "Upper Klamath Lake", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
  ELSE
   IF ( "JanuaryThruApril"(  ) )
   THEN
    "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "Upper Klamath Lake", "Upper Klamath Lake", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
   ELSE
    "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "Upper Klamath Lake", "Upper Klamath Lake", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "May through September"
   ENDIF
  ENDIF
 ELSE
  $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"]
 ENDIF;

    END;

    RULE                 "Initial UKL Demand Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      IF_STATEMENT (@"t" == "RunStartDate"(  )) THEN
            $ "ReservoirOperations.UKL Demand Release" [] := 1.00000000 "cfs";

      END_IF_STATEMENT;

    END;

    RULE                 "UKL Environmental Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Environmental Release" [] := "Min"( "MaxItem"( { $ "ReservoirOperations.IFRRelease" [@"t", "Upper Klamath"] , $ "ReservoirOperations.UKL To Iron Gate Total IFR Pass Thru" [] , $ "ReservoirOperations.UKL To Keno IFR Pass Thru" [] } ), "Max"( "SolveOutflow"( % "Upper Klamath Lake", $ "Upper Klamath Lake.Inflow" [], "ElevationToStorage"( % "Upper Klamath Lake", $ "KBPMOperationsData.MinFishElevation" [@"t", "Minimum"] ), "PreviousStorage"( % "Upper Klamath Lake" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions.", 0.00000000 "cms" ) );

    END;

    RULE                 "UKL Instream Flow Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Upper Klamath"] := "Min"( IF ( "OctoberThruFebruary"(  ) )
 THEN
  "Max"( ( $ "Williamson Near Chiloquin.Gage Inflow" [@"t - 1"] * "LinkDamIFRWilliamsonProportion"( $ "Williamson Near Chiloquin.Gage Inflow" [@"t - 1"] ) * "LinkDamIFRAccretionAdjustment"( "UKLToIronGateNetAccretion"( @"t - 1", @"t - 1" ) ) * "FillRateAdjustment"( @"t" ) ) COMMENTED_BY "KBPM's FallWinterRelease" + IF ( "OctoberThruNovember"(  ) )
  THEN
   "AverageDailyFlowForVolume"( ( $ "ProjectData.EWARiver" ["GetDate"( "September 30, Current Year" )] - $ "ProjectData.EWAUsed" ["GetDate"( "September 30, Current Year" )] ), "GetDate"( "October 1, Current Year" ), "GetDate"( "November 30, Current Year" ) )
  ELSE
   0.00000000 "cms"
  ENDIF COMMENTED_BY "KMPM Oct Nov Augmentation Water", $ "ReservoirData.MinRelease" [@"t", "Upper Klamath Lake"] )
 ELSE
  $ "ReservoirData.MinRelease" [@"t", "Upper Klamath Lake"]
 ENDIF, "Max"( "SolveOutflow"( % "Upper Klamath Lake", $ "Upper Klamath Lake.Inflow" [], "ElevationToStorage"( % "Upper Klamath Lake", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Upper Klamath Lake"] COMMENTED_BY "Using minimum fish elevation here caused problems for temperature model." ), "PreviousStorage"( % "Upper Klamath Lake" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions.", 0.00000000 "cms" ) );

    END;

    RULE                 "Compute Total UKL To Iron Gate IFR Pass Thru Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL To Iron Gate Total IFR Pass Thru" [] := $ "ReservoirOperations.UKL To Iron Gate IFR Pass Thru" [] + $ "ReservoirOperations.Iron Gate Supplemental Water" [] + $ "ReservoirOperations.Boyle Supplemental Water" [];

    END;

    RULE                 "Compute Iron Gate Supplemental Water Release ZERO";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Iron Gate Supplemental Water" [] := 0.00000000 "cms";

    END;

    RULE                 "Boyle Supplemental Water";
    DESCRIPTION          "Water to compensate Boyle for negative downstream gains case.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      BREAKPOINT BEFORE_EXEC TRUE;
      $ "ReservoirOperations.Boyle Supplemental Water" [] := IF ( @"t" > "RunStartDate"(  ) )
 THEN
  "Max"( $ "ReservoirOperations.IFRRelease" [@"t - 1", "Boyle"] - $ "ReservoirData.MinRelease" [@"t - 1", "JC Boyle Reservoir"], 0.00000000 "cms" )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    RULE                 "Debug";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      PRINT $ "ReservoirData.MaxElevation" [@"t", 0.00000000];

      PRINT IF ( @"t" > "RunStartDate"(  ) )
 THEN
  "Max"( $ "ReservoirOperations.IFRRelease" [@"t - 1", "Boyle"] - $ "ReservoirData.MinRelease" [@"t - 1", "JC Boyle Reservoir"], 0.00000000 "cms" )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    RULE                 "Compute Iron Gate Supplemental Water Release";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Iron Gate Supplemental Water" [] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "MaxItem"( { ( $ "ReservoirOperations.Iron Gate Constrained Release" [@"t - 1"] - $ "ReservoirOperations.Iron Gate Unconstrained Release" [@"t - 1"] ) , IF ( $ "Iron Gate Reservoir.Pool Elevation" [@"t - 1"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] <= ( 0.25000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) ) )
  THEN
   "Max"( 0.00000000 "cms", "VolumeToFlow"( "ElevationToStorage"( % "Iron Gate Reservoir", ( 0.25000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) ) + $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) - $ "Iron Gate Reservoir.Storage" [@"t - 1"], @"t" ) )
  ELSE
   0.00000000 "cms"
  ENDIF , 0.00000000 "cms" } )
 ENDIF;

    END;

    RULE                 "Compute Iron Gate Supplemental Water Release OUTFLOW_UNCONST";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Iron Gate Supplemental Water" [] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "MaxItem"( { ( $ "ReservoirOperations.Iron Gate Constrained Release" [@"t - 1"] - $ "ReservoirOperations.Iron Gate Unconstrained Release" [@"t - 1"] ) , IF ( $ "Iron Gate Reservoir.Pool Elevation" [@"t - 1"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] <= ( 0.25000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) ) )
  THEN
   "Max"( ( $ "ReservoirOperations.Iron Gate Unconstrained Release" [@"t - 1"] - $ "Iron Gate Reservoir.Outflow" [@"t - 1"] ), "VolumeToFlow"( "ElevationToStorage"( % "Iron Gate Reservoir", ( 0.25000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) ) + $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) - $ "Iron Gate Reservoir.Storage" [@"t - 1"], @"t" ) )
  ELSE
   0.00000000 "cms"
  ENDIF , 0.00000000 "cms" } )
 ENDIF;

    END;

    RULE                 "Compute Iron Gate Supplemental Water Release With Ramping Only";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Iron Gate Supplemental Water" [] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Max"( ( $ "ReservoirOperations.Iron Gate Constrained Release" [@"t - 1"] - $ "ReservoirOperations.Iron Gate Unconstrained Release" [@"t - 1"] ), 0.00000000 "cms" )
 ENDIF;

    END;

    RULE                 "UKL To Iron Gate IFR Pass Thru Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL To Iron Gate IFR Pass Thru" [] := "Min"( "Max"( $ "ReservoirOperations.Iron Gate ENV Release" COMMENTED_BY "Iron Gate IFR minus downstream gains" [] - $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] + $ "ProjectData.ProjectReleaseForIronGateMin" [@"t - 1"] - "UKLToIronGateNetAccretion"( @"t - 1", @"t - 1" ), 0.00000000 "cms" ), $ "KBPMOperationsData.Max_UKL_To_IG" [] );

    END;

    RULE                 "UKL To Keno IFR Pass Thru Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL To Keno IFR Pass Thru" [] := "Min"( "MaxItem"( { 0.00000000 "cms" , $ "ReservoirData.MinRelease" [@"t", "Keno Reservoir"] - $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] + $ "ProjectData.ProjectReleaseForIronGateMin" [@"t - 1"] - "UKLToKenoNetAccretion"( @"t - 1", @"t - 1" ) , "VolumeToFlow"( "ElevationToStorage"( % "Keno Dam", $ "ReservoirData.ReservoirAllocations" ["Active", "Keno Dam"] ) - "PreviousStorage"( % "Keno Dam" ), @"t" ) } ), $ "KBPMOperationsData.Max_UKL_To_IG" [] );

    END;

    RULE                 "Request Area1 From Lost Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Lost River To Area1.Diversion Request" [] := $ "Area1:A1SouthOfLRDC.Diversion Requested" [];

    END;

    RULE                 "Iron Gate Environmental Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Iron Gate ENV Release" [] := IF ( "MarchThruMay"(  ) )
 THEN
  "Max"( "UKL_FillRateRatioSpring"( @"t" ) * $ "ProjectData.WilliamsonProportionCum" [] * "VolumeToFlow"( $ "ProjectData.EWARiver" [@"t"] - "TableInterpolation"( $ "KBPMOperationsData.EWA_reserve", 0.00000000, 1.00000000, $ "ProjectData.EWARiver" [@"t"], @"t" ) - $ "ProjectData.EWAUsed" [@"t - 1"], @"t" ) + $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] + "UKLToIronGateNetAccretion"( @"t - 1", @"t - 1" ) - $ "ProjectData.ProjectReleaseForIronGateMin" [], $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"] )
 ELSE
  IF ( "GetMonth"( @"t" ) == 6.00000000 )
  THEN
   "Max"( $ "ProjectData.WilliamsonProportionCum" [] * "VolumeToFlow"( $ "ProjectData.EWARiver" [@"t"] - ( $ "KBPMOperationsData.EWAReserveAdjustment" [] * "TableInterpolation"( $ "KBPMOperationsData.EWA_reserve", 0.00000000, 1.00000000, $ "ProjectData.EWARiver" [@"t"], @"t" ) ) - $ "ProjectData.EWAUsed" [@"t - 1"], @"t" ) + $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] + "UKLToIronGateNetAccretion"( @"t - 1", @"t - 1" ) - $ "ProjectData.ProjectReleaseForIronGateMin" [], $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"] )
  ELSE
   IF ( "GetMonth"( @"t" ) == 7.00000000 )
   THEN
    "Max"( "Min"( "TableInterpolation"( $ "KBPMOperationsData.IG_max", 0.00000000, 1.00000000, $ "ProjectData.EWARiver" [@"t"], @"t" ), $ "KBPMOperationsData.EWARemainJulSepFactors" [@"t", "Adjustment"] * $ "ProjectData.EWARemain" [@"t"] / "GetDaysInMonth"( @"t" ) ), $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"] )
   ELSE
    IF ( "GetMonth"( @"t" ) == 8.00000000 )
    THEN
     "Max"( "Min"( "TableInterpolation"( $ "KBPMOperationsData.IG_max", 2.00000000, 3.00000000, $ "ProjectData.EWARiver" [@"t"], @"t" ), $ "KBPMOperationsData.EWARemainJulSepFactors" [@"t", "Adjustment"] * $ "ProjectData.EWARemain" [@"t"] / "GetDaysInMonth"( @"t" ) ), $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"] )
    ELSE
     IF ( "GetMonth"( @"t" ) == 9.00000000 )
     THEN
      "Max"( "Min"( "TableInterpolation"( $ "KBPMOperationsData.IG_max", 4.00000000, 5.00000000, $ "ProjectData.EWARiver" [@"t"], @"t" ), $ "KBPMOperationsData.EWARemainJulSepFactors" [@"t", "Adjustment"] * $ "ProjectData.EWARemain" [@"t"] / "GetDaysInMonth"( @"t" ) ), $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"] )
     ELSE
      $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"]
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF;

    END;

    RULE                 "Accumulate Project Release For Iron Gate Minimum";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectCumForIronGateMin" [] := IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( "AprilThruJune"(  ) AND $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] > 0.00000000 "cms" )
  THEN
   $ "ProjectData.ProjectCumForIronGateMin" [@"t - 1"] + "FlowToVolume"( $ "ProjectData.ProjectReleaseForIronGateMin" [], @"t" )
  ELSE
   $ "ProjectData.ProjectCumForIronGateMin" [@"t - 1"]
  ENDIF
 ENDIF;

    END;

    RULE                 "Compute Project Release For Iron Gate Minimum";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectReleaseForIronGateMin" [] := IF ( "OctoberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( IF ( "FlowIsBetween"( "Max"( $ "ReservoirOperations.Iron Gate ENV Release" [@"t - 1"] + ( $ "Iron Gate Reservoir.Outflow" [@"t - 1"] - $ "ReservoirOperations.Iron Gate Hatchery Release" [@"t - 1"] - $ "ReservoirOperations.Iron Gate Unconstrained Release" [@"t - 1"] ) COMMENTED_BY "Ramping (by policy or unregulated spilling)", 0.00000000 "cms" ), $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate1"], $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate2"] ) )
  THEN
   "Max"( $ "ReservoirOperations.Iron Gate ENV Release" [@"t - 1"] + ( $ "Iron Gate Reservoir.Outflow" [@"t - 1"] - $ "ReservoirOperations.Iron Gate Hatchery Release" [@"t - 1"] - $ "ReservoirOperations.Iron Gate Unconstrained Release" [@"t - 1"] ) - $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate1"], 0.00000000 "cms" )
  ELSE
   0.00000000 "cms"
  ENDIF COMMENTED_BY "Env portion of release was between IronGate1 and IronGate2 IFR's", "Min"( "Max"( "VolumeToFlow"( "ElevationToStorage"( % "Upper Klamath Lake", $ "ReservoirData.MaxElevation" [@"t - 1", "Upper Klamath Lake"] ) - "PreviousStorage"( % "Upper Klamath Lake" ), @"t" ), 0.00000000 "cms" ), $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] ) COMMENTED_BY "min of water that was released yesterday beyond what was required to get reservoir below maximum storage (UKL max storage minus UKL actual <br>storage), UKL excess water release)" )
 ENDIF;

    END;

    RULE                 "Compute Project Release For Iron Gate Minimum Pseudo KBPM";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectReleaseForIronGateMin" [] := IF ( "OctoberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( "Max"( ( "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate2"], "Max"( $ "Iron Gate Reservoir.Outflow" [@"t - 1"] - "IronGatePreviousUnregulated"( @"t - 1" ) - ( $ "ReservoirOperations.Iron Gate Constrained Release" [@"t - 1"] - $ "ReservoirOperations.Iron Gate Unconstrained Release" [@"t - 1"] ), 0.00000000 "cms" ) ) COMMENTED_BY "max of (IG incremental MIF (IGMIF2, lower bound of IG Ramping)" - "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate1"], "Max"( $ "Iron Gate Reservoir.Outflow" [@"t - 1"] - "IronGatePreviousUnregulated"( @"t - 1" ) - ( $ "ReservoirOperations.Iron Gate Constrained Release" [@"t - 1"] - $ "ReservoirOperations.Iron Gate Unconstrained Release" [@"t - 1"] ), 0.00000000 "cms" ) ) COMMENTED_BY "max of (IG MIF (IGMIF1), lower bound of IG ramping)" ), 0.00000000 "cms" ), "Min"( "Max"( "VolumeToFlow"( "ElevationToStorage"( % "Upper Klamath Lake", $ "ReservoirData.TargetElevation" [@"t - 1", "Upper Klamath Lake"] ) - "PreviousStorage"( % "Upper Klamath Lake" ), @"t" ), 0.00000000 "cms" ), $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] ) COMMENTED_BY "min of water that was released yesterday beyond what was required to get reservoir below maximum storage (UKL max storage minus UKL actual <br>storage), UKL excess water release)" )
 ENDIF;

    END;

    RULE                 "Compute Project Release For Iron Gate Minimum Env Minus Ramping Constraint";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectReleaseForIronGateMin" [] := IF ( "OctoberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( "Max"( ( "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate2"], "Max"( $ "ReservoirOperations.Iron Gate ENV Release" [@"t - 1"] + ( $ "ReservoirOperations.Iron Gate Constrained Release" [@"t - 1"] - $ "ReservoirOperations.Iron Gate Unconstrained Release" [@"t - 1"] ), 0.00000000 "cms" ) ) COMMENTED_BY "max of (IG incremental MIF (IGMIF2, lower bound of IG Ramping)" - "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate1"], "Max"( $ "ReservoirOperations.Iron Gate ENV Release" [@"t - 1"] + ( $ "ReservoirOperations.Iron Gate Constrained Release" [@"t - 1"] - $ "ReservoirOperations.Iron Gate Unconstrained Release" [@"t - 1"] ), 0.00000000 "cms" ) ) COMMENTED_BY "max of (IG MIF (IGMIF1), lower bound of IG ramping)" ), 0.00000000 "cms" ), "Min"( "Max"( "VolumeToFlow"( "ElevationToStorage"( % "Upper Klamath Lake", $ "ReservoirData.TargetElevation" [@"t - 1", "Upper Klamath Lake"] ) - "PreviousStorage"( % "Upper Klamath Lake" ), @"t" ), 0.00000000 "cms" ), $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] ) COMMENTED_BY "min of water that was released yesterday beyond what was required to get reservoir below maximum storage (UKL max storage minus UKL actual <br>storage), UKL excess water release)" )
 ENDIF;

    END;

    RULE                 "Compute Project Release For Iron Gate Minimum Lower Bound Function";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectReleaseForIronGateMin" [] := IF ( "OctoberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( "Max"( ( "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate2"], "IronGateRampingLowerBound"( @"t - 1" ) ) COMMENTED_BY "max of (IG incremental MIF (IGMIF2, lower bound of IG Ramping)" - "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate1"], "IronGateRampingLowerBound"( @"t - 1" ) ) COMMENTED_BY "max of (IG MIF (IGMIF1), lower bound of IG ramping)" ), 0.00000000 "cms" ), "Min"( "Max"( "VolumeToFlow"( "ElevationToStorage"( % "Upper Klamath Lake", $ "ReservoirData.TargetElevation" [@"t - 1", "Upper Klamath Lake"] ) - "PreviousStorage"( % "Upper Klamath Lake" ), @"t" ), 0.00000000 "cms" ), $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] ) COMMENTED_BY "min of water that was released yesterday beyond what was required to get reservoir below maximum storage (UKL max storage minus UKL actual <br>storage), UKL excess water release)" )
 ENDIF;

    END;

    RULE                 "Compute Williamson Proportion Accumulation";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.WilliamsonProportionCum" [] := IF ( "MarchThruSeptember"(  ) )
 THEN
  WITH NUMERIC remainingWilliamson = $ "ProjectData.Williamson50Volume" [@"t"] - IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
  THEN
   0.00000000 "m3"
  ELSE
   "SumFlowsToVolumeSkipNaN"( $ "Williamson Near Chiloquin.Gage Outflow", "GetDate"( "March 1, Current Year" ), @"t - 1" )
  ENDIF DO
   WITH NUMERIC yesterdayWilliamson = "FlowToVolume"( $ "Williamson Near Chiloquin.Gage Outflow" [@"t - 1"], @"t - 1" ) DO
    IF ( remainingWilliamson < yesterdayWilliamson )
    THEN
     0.00000000
    ELSE
     IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
     THEN
      yesterdayWilliamson / remainingWilliamson
     ELSE
      "Min"( yesterdayWilliamson / remainingWilliamson, "Max"( 1.00000000 - "SumSlot"( $ "ProjectData.WilliamsonProportionCum", "GetDate"( "March 1, Current Year" ), @"t - 1" ), 0.00000000 ) )
     ENDIF
    ENDIF
   ENDWITH
  ENDWITH
 ELSE
  0.00000000
 ENDIF;

    END;

    RULE                 "Set Area 2 Headgate Demand";
    DESCRIPTION          "Adjust headgate and depletion demands to reflect supply conditions.  Uses water year ratio but apply to next calendar year.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.DistributedArea2HeadgateDemand" [] := "Min"( WITH NUMERIC remainingSoilMoistureSpace = "Max"( "ElevationToStorage"( % "Area2 Supply", $ "InitialConditions.Area 2 Supply" [] ) + $ "ProjectData.Area2 Soil Moisture Limit" [] - "PreviousStorage"( % "Area2 Supply" ), 0.00000000 "m3" ) DO
  IF ( "OctoberThruFebruary"(  ) )
  THEN
   $ "Area2.Diversion Requested" [] + "VolumeToFlow"( remainingSoilMoistureSpace, @"t" )
  ELSE
   WITH NUMERIC supplyToDate = $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"] DO
    WITH NUMERIC demandToDate = "SumFlowsToVolume"( $ "Area2.Diversion", @"24:00:00 October 1, Previous Year", @"t - 1" ) DO
     WITH NUMERIC remainingSupply = supplyToDate - demandToDate DO
      WITH NUMERIC remainingDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"t", @"24:00:00 September 30, Current Year" ) DO
       WITH NUMERIC unsuppliedDemand = "Max"( remainingDemand - remainingSupply, 0.00000000 "m3" ) DO
        IF ( "GetMonth"( @"t" ) == 9.00000000 )
        THEN
         "Min"( $ "Area2.Diversion Requested" [@"t"] / remainingDemand * unsuppliedDemand, "VolumeToFlow"( unsuppliedDemand, @"t" ) )
        ELSE
         "Max"( IF ( remainingDemand != 0.00000000 )
         THEN
          "PeriodAverage"( $ "Area2.Diversion Requested", "OffsetDate"( @"t", - 10.00000000, "1 days" ), "OffsetDate"( @"t", 10.00000000, "1 days" ) ) / remainingDemand * unsuppliedDemand
         ELSE
          0.00000000
         ENDIF, IF ( "GetMonth"( @"t" ) < 7.00000000 )
         THEN
          $ "Area2.Diversion Requested" [] + "VolumeToFlow"( remainingSoilMoistureSpace, @"t" )
         ELSE
          0.00000000 "cms"
         ENDIF )
        ENDIF
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDIF
 ENDWITH, $ "ProjectData.MaximumToArea2" [] );

    END;

    RULE                 "Set Area 2 Headgate Demand No Storage Check After Feb";
    DESCRIPTION          "Adjust headgate and depletion demands to reflect supply conditions.  Uses water year ratio but apply to next calendar year.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.DistributedArea2HeadgateDemand" [] := "Min"( WITH NUMERIC remainingSoilMoistureSpace = "Max"( "ElevationToStorage"( % "Area2 Supply", $ "InitialConditions.Area 2 Supply" [] ) + $ "ProjectData.Area2 Soil Moisture Limit" [] - "PreviousStorage"( % "Area2 Supply" ), 0.00000000 "m3" ) DO
  IF ( "OctoberThruFebruary"(  ) )
  THEN
   $ "Area2.Diversion Requested" [] + "VolumeToFlow"( remainingSoilMoistureSpace, @"t" )
  ELSE
   WITH NUMERIC supplyToDate = $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"] DO
    WITH NUMERIC demandToDate = "SumFlowsToVolume"( $ "Area2.Diversion", @"24:00:00 October 1, Previous Year", @"t - 1" ) DO
     WITH NUMERIC remainingSupply = supplyToDate - demandToDate DO
      WITH NUMERIC remainingDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"t", @"24:00:00 September 30, Current Year" ) DO
       WITH NUMERIC unsuppliedDemand = "Max"( remainingDemand - remainingSupply, 0.00000000 "m3" ) DO
        IF ( "GetMonth"( @"t" ) == 9.00000000 )
        THEN
         "Min"( $ "Area2.Diversion Requested" [@"t"] / remainingDemand * unsuppliedDemand, "VolumeToFlow"( unsuppliedDemand, @"t" ) )
        ELSE
         "PeriodAverage"( $ "Area2.Diversion Requested", "OffsetDate"( @"t", - 10.00000000, "1 days" ), "OffsetDate"( @"t", 10.00000000, "1 days" ) ) / remainingDemand * unsuppliedDemand
        ENDIF
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDIF
 ENDWITH, $ "ProjectData.MaximumToArea2" [] );

    END;

    RULE                 "Distribute Area 2 Headgate Demand On First of Month";
    DESCRIPTION          "Adjust headgate and depletion demands to reflect supply conditions.  Uses water year ratio but apply to next calendar year.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "GetMonth"( @"t" ) > 2.00000000 AND "GetMonth"( @"t" ) < 10.00000000 AND "GetDayOfMonth"( @"t" ) == 1.00000000 "day" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC supplyToDate = $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"]) DO
            WITH_STATEMENT (NUMERIC demandToDate = "SumFlowsToVolume"( $ "Area2.Diversion", @"24:00:00 October 1, Previous Year", @"t - 1" )) DO
            WITH_STATEMENT (NUMERIC remainingSupply = supplyToDate - demandToDate) DO
            WITH_STATEMENT (NUMERIC remainingDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"t", @"24:00:00 September 30, Current Year" )) DO
            WITH_STATEMENT (NUMERIC unsuppliedDemand = "Max"( remainingDemand - remainingSupply, 0.00000000 "m3" )) DO
            FOREACH (DATETIME monthlyDate IN "GetDates"( @"t", @"24:00:00 September 30, Current Year", "1 Months" )) DO
            WITH_STATEMENT (NUMERIC monthlyDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", "BeginOfMonthDate"( monthlyDate ), "EndOfMonthDate"( monthlyDate ) )) DO
            IF_STATEMENT ("GetMonth"( @"t" ) == 9.00000000) THEN
            FOREACH (DATETIME date IN "GetDates"( "BeginOfMonthDate"( monthlyDate ), "EndOfMonthDate"( monthlyDate ), "1 days" )) DO
            $ "ProjectData.DistributedArea2HeadgateDemand" [date] := $ "Area2.Diversion Requested" [date] / remainingDemand * unsuppliedDemand;

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( "BeginOfMonthDate"( monthlyDate ), "EndOfMonthDate"( monthlyDate ), "1 days" )) DO
            $ "ProjectData.DistributedArea2HeadgateDemand" [date] := "VolumeToFlow"( monthlyDemand / remainingDemand * unsuppliedDemand / "GetUnitlessDaysInMonth"( date ), date );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Distribute Area 2 Headgate Demand On First of Month From KBPM Supply Distrbution";
    DESCRIPTION          "Adjust headgate and depletion demands to not be more than historic as a function of UKL inflow.  Use water year ratio but apply to next calendar year.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "GetMonth"( @"t" ) > 2.00000000 AND "GetMonth"( @"t" ) < 10.00000000 AND "GetDayOfMonth"( @"t" ) == 1.00000000 "day" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC supplyToDate = $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"]) DO
            WITH_STATEMENT (NUMERIC demandToDate = "SumFlowsToVolume"( $ "Area2.Diversion", @"24:00:00 October 1, Previous Year", @"t - 1" )) DO
            WITH_STATEMENT (NUMERIC remainingSupply = supplyToDate - demandToDate) DO
            WITH_STATEMENT (NUMERIC remainingDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"t", @"24:00:00 September 30, Current Year" )) DO
            WITH_STATEMENT (NUMERIC unsuppliedDemand = "Max"( remainingDemand - remainingSupply, 0.00000000 "m3" )) DO
            WITH_STATEMENT (NUMERIC MarchSeptDistribution = "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", @"t", @"24:00:00 September 30, Current Year" )) DO
            FOREACH (DATETIME date IN "GetDates"( @"t", @"24:00:00 September 30, Current Year", "1 days" )) DO
            $ "ProjectData.DistributedArea2HeadgateDemand" [date] := "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [date] / MarchSeptDistribution * unsuppliedDemand, date );

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Distribute Area 2 Headgate Demand On March 1 KBPM Supply Distribution";
    DESCRIPTION          "Adjust headgate and depletion demands to not be more than historic as a function of UKL inflow.  Use water year ratio but apply to next calendar year.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == "GetDate"( "March 1, Current Year" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC supplyToDate = $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"]) DO
            WITH_STATEMENT (NUMERIC demandToDate = "SumFlowsToVolume"( $ "Area2.Diversion", @"24:00:00 October 1, Previous Year", @"t - 1" )) DO
            WITH_STATEMENT (NUMERIC remainingSupply = supplyToDate - demandToDate) DO
            WITH_STATEMENT (NUMERIC remainingDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"24:00:00 March 1, Current Year", @"24:00:00 September 30, Current Year" )) DO
            WITH_STATEMENT (NUMERIC unsuppliedDemand = "Max"( remainingDemand - remainingSupply, 0.00000000 "m3" )) DO
            WITH_STATEMENT (NUMERIC MarchSeptDistribution = "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", @"24:00:00 March 1, Current Year", @"24:00:00 September 30, Current Year" )) DO
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 1, Current Year", @"24:00:00 September 30, Current Year", "1 days" )) DO
            $ "ProjectData.DistributedArea2HeadgateDemand" [date] := "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [date] / MarchSeptDistribution * unsuppliedDemand, date );

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Adjust Demands For Historic Supply On March 1";
    DESCRIPTION          "Adjust headgate and depletion demands to not be more than historic as a function of UKL inflow.  Use water year ratio but apply to next calendar year.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == "GetDate"( "March 1, Current Year" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC historicSupply = "TableInterpolation"( $ "ProjectData.Historic Ranked Irrigation Supplies", 0.00000000, 1.00000000, $ "ProjectData.March50Volume" [@"t"], @"t" )) DO
            WITH_STATEMENT (NUMERIC etDemand = "SumFlowsToVolume"( $ "Area1.Total Diversion Requested", @"24:00:00 October 1, Previous Year", @"24:00:00 September 30, Current Year" ) + "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"24:00:00 October 1, Previous Year", @"24:00:00 September 30, Current Year" )) DO
            WITH_STATEMENT (NUMERIC adjustmentRatio = IF ( etDemand == 0.00000000 "m3" )
 THEN
  1.00000000
 ELSE
  "Max"( historicSupply / etDemand, 1.00000000 )
 ENDIF) DO
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 1, Current Year", "DateMin"( @"24:00:00 February Max DayOfMonth, Next Year", "RunEndDate"(  ) ), "1 days" )) DO
            $ "Area1:A1NorthOfLRDC.Diversion Requested" [date] := adjustmentRatio * $ "Area1:A1NorthOfLRDC.Diversion Requested" [date];

            $ "Area1:A1NorthOfLRDC.Depletion Requested" [date] := adjustmentRatio * $ "Area1:A1NorthOfLRDC.Depletion Requested" [date];

            $ "Area1:A1SouthOfLRDC.Diversion Requested" [date] := adjustmentRatio * $ "Area1:A1SouthOfLRDC.Diversion Requested" [date];

            $ "Area1:A1SouthOfLRDC.Depletion Requested" [date] := adjustmentRatio * $ "Area1:A1SouthOfLRDC.Depletion Requested" [date];

            $ "Area2.Diversion Requested" [date] := adjustmentRatio * $ "Area2.Diversion Requested" [date];

            $ "Area2.Depletion Requested" [date] := adjustmentRatio * $ "Area2.Depletion Requested" [date];

            $ "Lost River Irrigation Depletions.Diversion Requested" [date] := adjustmentRatio * $ "Lost River Irrigation Depletions.Diversion Requested" [date];

            $ "Lost River Irrigation Depletions.Depletion Requested" [date] := adjustmentRatio * $ "Lost River Irrigation Depletions.Depletion Requested" [date];

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Set Project Supply Distribution on March 1";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == "GetDate"( "March 1, Current Year" );
    NOTES                "";
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( "GetDate"( "March 1, Current Year" ), "DateMin"( @"24:00:00 February Max DayOfMonth, Next Year", @"Finish Timestep" ), "1 days" )) DO
            $ "ProjectData.ProjectSupplyDailyDistribution" [date] := $ "ProjectData.ProjectSupplyMonthlyDistribution" [date, "TableLookup"( $ "ProjectData.SupplyTemporalDistriibutionType", 0.00000000, 1.00000000, $ "ProjectData.March50Volume" [@"t - 1"], @"t - 1", TRUE ) - 1.00000000] / "GetUnitlessDaysInMonth"( date );

      ENDFOREACH;

    END;

    RULE                 "Compute Project Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectSupply" [] := IF ( "JulyThruFebruary"(  ) )
 THEN
  $ "ProjectData.ProjectSupply" [@"t - 1"]
 ELSE
  IF ( "MarchThruJune"(  ) AND "ProjectIsFull"(  ) )
  THEN
   $ "KBPMOperationsData.ProjectMaximumSupply" []
  ELSE
   IF ( "MarchThruApril"(  ) )
   THEN
    "Min"( "Max"( $ "ProjectData.UKLSupply" [] - $ "ProjectData.EWARiver" [], 0.00000000 "m3" ), $ "KBPMOperationsData.ProjectMaximumSupply" [] )
   ELSE
    IF ( "GetMonth"( @"t" ) == 5.00000000 )
    THEN
     IF ( $ "ProjectData.UKLSupply" [] > $ "ProjectData.UKLSupply" [@"t - 1"] )
     THEN
      "Max"( $ "ProjectData.ProjectSupply" ["GetDate"( "April 30, Current Year" )], "Min"( "Max"( $ "ProjectData.UKLSupply" [] - $ "ProjectData.EWARiver" [], 0.00000000 "m3" ), $ "KBPMOperationsData.ProjectMaximumSupply" [] ) ) COMMENTED_BY "Supply is increasing"
     ELSE
      $ "ProjectData.ProjectSupply" [@"t - 1"]
     ENDIF
    ELSE
     IF ( "GetMonth"( @"t" ) == 6.00000000 )
     THEN
      IF ( $ "ProjectData.UKLSupply" [] > $ "ProjectData.UKLSupply" ["GetDate"( "April 30, Current Year" )] )
      THEN
       "Max"( $ "ProjectData.ProjectSupply" [@"t - 1"], "Min"( "Max"( $ "ProjectData.UKLSupply" [] - $ "ProjectData.EWARiver" [], 0.00000000 "m3" ), $ "KBPMOperationsData.ProjectMaximumSupply" [] ) ) COMMENTED_BY "Supply is increasing"
      ELSE
       "Max"( $ "ProjectData.ProjectSupply" ["GetDate"( "April 30, Current Year" )], "Min"( "Max"( $ "ProjectData.UKLSupply" [] - $ "ProjectData.EWARiver" [], 0.00000000 "m3" ), $ "KBPMOperationsData.ProjectMaximumSupply" [] ) ) COMMENTED_BY "Supply is decreasing"
      ENDIF
     ELSE
      $ "ProjectData.ProjectSupply" [@"t - 1"]
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF;

    END;

    RULE                 "Compute EWA Remain";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ProjectData.EWARemain" [] := IF ( "MarchThruSeptember"(  ) )
 THEN
  IF ( "GetUnitlessDayOfMonth"( @"t" ) == 1.00000000 )
  THEN
   "Max"( "EWARemainingMinimumVolume"(  ), $ "ProjectData.EWARiver" [@"t"] - $ "ProjectData.EWAUsed" [@"t - 1"] )
  ELSE
   $ "ProjectData.EWARemain" [@"t - 1"]
  ENDIF
 ELSE
  0.00000000 "m3"
 ENDIF;

    END;

    RULE                 "Compute EWA River";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.EWARiver" [] := IF ( "MarchThruJune"(  ) AND "GetUnitlessDayOfMonth"( @"t" ) == 1.00000000 )
 THEN
  "Max"( $ "KBPMOperationsData.EWARiverMinimum" [], $ "ProjectData.UKLSupply" [@"t"] * "TableInterpolation"( $ "KBPMOperationsData.EWASupplyPercent", 0.00000000, 1.00000000, $ "ProjectData.UKLSupply" [@"t"], @"t" ) ) COMMENTED_BY "Max (Minimum EWA, UKL Supply times EWA portion of UKL Supply)"
 ELSE
  IF ( "OctoberThruFebruary"(  ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "ProjectData.EWARiver" [@"t - 1"]
  ENDIF
 ENDIF;

    END;

    RULE                 "Compute UKL Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.UKLSupply" [] := IF ( "GetUnitlessDayOfMonth"( @"t" ) == 1.00000000 AND "GetMonth"( @"t" ) >= 3.00000000 AND "GetMonth"( @"t" ) <= 6.00000000 )
 THEN
  ( $ "ProjectData.March50Volume" [@"t"] + "Max"( $ "Upper Klamath Lake.Storage" [@"24:00:00 February Max DayOfMonth, Current Year"] - "ElevationToStorage"( % "Upper Klamath Lake", "TableInterpolation"( $ "KBPMOperationsData.UKL_EOS_target_level", 0.00000000, 1.00000000, $ "ProjectData.March50Volume" [@"t"], @"t" ) ), 0.00000000 "m3" ) ) COMMENTED_BY "Forecasted March thru September Inflow + (End of February UKL Storage - End of September Target Storage)"
 ELSE
  $ "ProjectData.UKLSupply" [@"t - 1"]
 ENDIF;

    END;

    RULE                 "Compute March 50 Volume";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.March50Volume" [] := IF ( "MarchThruSeptember"(  ) AND "GetUnitlessDayOfMonth"( @"t" ) == 1.00000000 )
 THEN
  IF ( "GetMonth"( @"t" ) == 3.00000000 )
  THEN
   "EstimatedUKLInflow"( "GetDate"( "March 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) COMMENTED_BY "March thru September Forecasted Inflow"
  ELSE
   IF ( "GetMonth"( @"t" ) == 4.00000000 )
   THEN
    ( "EstimatedUKLInflow"( "GetDate"( "April 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + ( "SumFlowsToVolumeSkipNaN"( $ "Upper Klamath Lake.Inflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "March 31, Current Year" ) ) - "SumSlot"( $ "Upper Klamath Lake.Evaporation", "GetDate"( "March 1, Current Year" ), "GetDate"( "March 31, Current Year" ) ) ) ) COMMENTED_BY "April thru September Forecasted Inflow Plus March Actual Inflow"
   ELSE
    IF ( "GetMonth"( @"t" ) == 5.00000000 )
    THEN
     ( "EstimatedUKLInflow"( "GetDate"( "May 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + ( "SumFlowsToVolumeSkipNaN"( $ "Upper Klamath Lake.Inflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "April 30, Current Year" ) ) - "SumSlot"( $ "Upper Klamath Lake.Evaporation", "GetDate"( "March 1, Current Year" ), "GetDate"( "April 30, Current Year" ) ) ) ) COMMENTED_BY "May thru September Forecasted Inflow Plus March thru April Actual Inflow"
    ELSE
     IF ( ( "GetMonth"( @"t" ) == 6.00000000 ) COMMENTED_BY "June thru September Forecasted Inflow Plus March thru May Actual Inflow" )
     THEN
      "EstimatedUKLInflow"( "GetDate"( "June 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + ( "SumFlowsToVolumeSkipNaN"( $ "Upper Klamath Lake.Inflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "May 31, Current Year" ) ) - "SumSlot"( $ "Upper Klamath Lake.Evaporation", "GetDate"( "March 1, Current Year" ), "GetDate"( "May 31, Current Year" ) ) )
     ELSE
      $ "ProjectData.March50Volume" [@"t - 1"]
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ELSE
  $ "ProjectData.March50Volume" [@"t - 1"]
 ENDIF;

    END;

    RULE                 "Compute Williamson 50 Volume";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.Williamson50Volume" [] := IF ( "MarchThruSeptember"(  ) )
 THEN
  IF ( "GetMonth"( @"t" ) == 3.00000000 )
  THEN
   "Max"( "EstimatedWilliamsonForecast"( "GetDate"( "March 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ), $ "KBPMOperationsData.Will50Maximum" [] ) COMMENTED_BY "March thru September Forecasted Inflow"
  ELSE
   IF ( "GetMonth"( @"t" ) == 4.00000000 )
   THEN
    ( "EstimatedWilliamsonForecast"( "GetDate"( "April 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + "SumFlowsToVolumeSkipNaN"( $ "Williamson Near Chiloquin.Gage Outflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "March 31, Current Year" ) ) ) COMMENTED_BY "April thru September Forecasted Inflow Plus March Actual Inflow"
   ELSE
    IF ( "GetMonth"( @"t" ) == 5.00000000 )
    THEN
     ( "EstimatedWilliamsonForecast"( "GetDate"( "May 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + "SumFlowsToVolumeSkipNaN"( $ "Williamson Near Chiloquin.Gage Outflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "April 30, Current Year" ) ) ) COMMENTED_BY "May thru September Forecasted Inflow Plus March thru April Actual Inflow"
    ELSE
     IF ( ( "GetMonth"( @"t" ) == 6.00000000 ) COMMENTED_BY "June thru September Forecasted Inflow Plus March thru May Actual Inflow" )
     THEN
      ( "EstimatedWilliamsonForecast"( "GetDate"( "June 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + "SumFlowsToVolumeSkipNaN"( $ "Williamson Near Chiloquin.Gage Outflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "May 3, Current Year" ) ) )
     ELSE
      $ "ProjectData.Williamson50Volume" [@"t - 1"]
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ELSE
  $ "ProjectData.Williamson50Volume" [@"t - 1"]
 ENDIF;

    END;

  END;

  POLICY_GROUP   "Lost River Operations";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Lost River MI RD Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "Lost River MI RD Depletions.Incoming Available Water" [] := "Max"( "Min"( $ "Lost River MI RD Diversions.Inflow" [], $ "Lost River MI RD Depletions.Diversion Requested" [] ), 0.00000000 "cms" );

    END;

    RULE                 "Lost River Irrigation Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "Lost River Irrigation Depletions.Incoming Available Water" [] := "Max"( "Min"( $ "Lost River Irrigation Diversions.Inflow" [], $ "Lost River Irrigation Depletions.Diversion Requested" [] ), 0.00000000 "cms" );

    END;

    RULE                 "Set Gerber Reservoir Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Gerber Reservoir.Outflow" [] := "UnregSpillwayCapacityCheck"( % "Gerber Reservoir", "MaxMinElevationCheck"( % "Gerber Reservoir", "Gerber Reservoir", "MaxItem"( { "GerberIrrigationRelease"(  ) + $ "ReservoirOperations.TargetRelease" [@"t", "Gerber Reservoir"] , $ "ReservoirOperations.Gerber Dam Flood Control Release" [] , $ "ReservoirOperations.IFRRelease" [@"t", "Gerber Reservoir"] } ) ) );

    END;

    RULE                 "Gerber Seepage";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Gerber Reservoir.Seepage" [] := "ComputeSeepage"( $ "ProjectData.LostRiverSeepageRates", "Gerber Reservoir", $ "Gerber Reservoir.Surface Area" [@"t - 1"], $ "Gerber Reservoir.Surface Area" [@"t - 1"], @"t" );

    END;

    RULE                 "Gerber Dam Lake Flood Control Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Gerber Dam Flood Control Release" [] := IF ( "JanuaryThruApril"(  ) )
 THEN
  WITH NUMERIC coeFloodControl = "DailyFloodControlRelease"( % "Gerber Reservoir", "Gerber Reservoir", "GetDate"( "April 30, Current Year" ), $ "ReservoirData.MaxRelease" [@"t", "Gerber Reservoir"], "EstimatedInflowForecast"( $ "Gerber Reservoir.Inflow", @"t", "GetDate"( "April 30, Current Year" ) ) ) DO
   "MaxItem"( { coeFloodControl , "DailyMaximumStorageRelease"( % "Gerber Reservoir", "Gerber Reservoir", @"t", "PreviousStorage"( % "Gerber Reservoir" ), 0.50000000 * ( $ "Gerber Reservoir.Inflow" [] + $ "Gerber Reservoir.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ) , "DailyFloodControlRelease"( % "Gerber Reservoir", "Gerber Reservoir", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ), $ "ReservoirData.MaxRelease" [@"t", "Gerber Reservoir"], "EstimatedInflowForecast"( $ "Gerber Reservoir.Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) ) } )
  ENDWITH
 ELSE
  "Max"( "DailyMaximumStorageRelease"( % "Gerber Reservoir", "Gerber Reservoir", @"t", "PreviousStorage"( % "Gerber Reservoir" ), 0.50000000 * ( $ "Gerber Reservoir.Inflow" [] + $ "Gerber Reservoir.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ), "DailyFloodControlRelease"( % "Gerber Reservoir", "Gerber Reservoir", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ), $ "ReservoirData.MaxRelease" [@"t", "Gerber Reservoir"], "EstimatedInflowForecast"( $ "Gerber Reservoir.Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) ) )
 ENDIF;

    END;

    RULE                 "Gerber Dam Target  Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Gerber Reservoir"] := IF ( "DecisionDate"( @"t", $ "ReservoirData.DecisionDates", "Normal" ) OR $ "Clear Lake.Pool Elevation" [@"t - 1"] > 0.50000000 * ( $ "ReservoirOperations.TargetElevation" [@"t", "Gerber Reservoir"] + $ "ReservoirData.MaxElevation" [@"t", "Gerber Reservoir"] ) OR $ "ReservoirOperations.TargetRelease" [@"t - 1", "Gerber Reservoir"] > 0.00000000 "cms" )
 THEN
  "AverageDailyFlowForVolume"( "SurplusVolumeBySlotWithLosses"( % "Gerber Reservoir", "Gerber Reservoir", $ "Gerber Reservoir.Inflow", "EstimateSeepage"( $ "ProjectData.LostRiverSeepageRates", "Gerber Reservoir", "GetMeanArea"( % "Clear Lake", "PreviousStorage"( % "Gerber Reservoir" ), "DailyTargetStorage"( % "Gerber Reservoir", "Gerber Reservoir", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) ), "DateMin"( @"t", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ), @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ), @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
 ELSE
  $ "ReservoirOperations.TargetRelease" [@"t - 1", "Gerber Reservoir"]
 ENDIF;

    END;

    RULE                 "Set Clear Lake Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Clear Lake.Outflow" [] := "UnregSpillwayCapacityCheck"( % "Clear Lake", "MaxMinElevationCheck"( % "Clear Lake", "Clear Lake", "MaxItem"( { "ClearLakeIrrigationRelease"(  ) + $ "ReservoirOperations.TargetRelease" [@"t", "Clear Lake"] , $ "ReservoirOperations.Clear Lake Flood Control Release" [] , $ "ReservoirOperations.IFRRelease" [@"t", "Clear Lake"] } ) ) );

    END;

    RULE                 "Clear Lake Seepage";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Clear Lake.Seepage" [] := "ComputeSeepage"( $ "ProjectData.LostRiverSeepageRates", "Clear Lake", $ "Clear Lake.Surface Area" [@"t - 1"], $ "Clear Lake.Surface Area" [@"t - 1"], @"t" );

    END;

    RULE                 "Clear Lake Flood Control Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Clear Lake Flood Control Release" [] := IF ( "JanuaryThruApril"(  ) )
 THEN
  WITH NUMERIC coeFloodControl = "DailyFloodControlRelease"( % "Clear Lake", "Clear Lake", "GetDate"( "April 30, Current Year" ), $ "ReservoirData.MaxRelease" [@"t", "Clear Lake"], "EstimatedInflowForecast"( $ "Clear Lake.Inflow", @"t", "GetDate"( "April 30, Current Year" ) ) ) DO
   "MaxItem"( { coeFloodControl , "DailyMaximumStorageRelease"( % "Clear Lake", "Clear Lake", @"t", "PreviousStorage"( % "Clear Lake" ), 0.50000000 * ( $ "Clear Lake.Inflow" [] + $ "Clear Lake.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ) , "DailyFloodControlRelease"( % "Clear Lake", "Clear Lake", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ), $ "ReservoirData.MaxRelease" [@"t", "Clear Lake"], "EstimatedInflowForecast"( $ "Clear Lake.Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) ) } )
  ENDWITH
 ELSE
  "Max"( "DailyMaximumStorageRelease"( % "Clear Lake", "Clear Lake", @"t", "PreviousStorage"( % "Clear Lake" ), 0.50000000 * ( $ "Clear Lake.Inflow" [] + $ "Clear Lake.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ), "DailyFloodControlRelease"( % "Clear Lake", "Clear Lake", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ), $ "ReservoirData.MaxRelease" [@"t", "Clear Lake"], "EstimatedInflowForecast"( $ "Clear Lake.Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) ) )
 ENDIF;

    END;

    RULE                 "Clear Lake Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Clear Lake"] := IF ( "DecisionDate"( @"t", $ "ReservoirData.DecisionDates", "Normal" ) OR $ "Clear Lake.Pool Elevation" [@"t - 1"] > 0.50000000 * ( $ "ReservoirOperations.TargetElevation" [@"t", "Clear Lake"] + $ "ReservoirData.MaxElevation" [@"t", "Clear Lake"] ) OR $ "ReservoirOperations.TargetRelease" [@"t - 1", "Clear Lake"] > 0.00000000 "cms" )
 THEN
  "AverageDailyFlowForVolume"( "SurplusVolumeBySlotWithLosses"( % "Clear Lake", "Clear Lake", $ "Clear Lake.Inflow", "EstimateSeepage"( $ "ProjectData.LostRiverSeepageRates", "Clear Lake", "GetMeanArea"( % "Clear Lake", "PreviousStorage"( % "Clear Lake" ), "DailyTargetStorage"( % "Clear Lake", "Clear Lake", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) ), "DateMin"( @"t", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ), @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ), @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
 ELSE
  $ "ReservoirOperations.TargetRelease" [@"t - 1", "Clear Lake"]
 ENDIF;

    END;

    RULE                 "Adjust Clear Lake Target Elevation For Surcharging";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetElevation" [@"t", "Clear Lake"] := $ "ReservoirData.TargetElevation" [@"t", "Clear Lake"];

    END;

    RULE                 "Gerber Reservoir Instream Flow Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Gerber Reservoir"] := "Max"( "Min"( "Min"( $ "Gerber Reservoir.Inflow" [], "Min"( $ "ReservoirData.MinRelease" [@"t", "Gerber Reservoir"], "GetMaxReleaseGivenInflow"( % "Gerber Reservoir", $ "Gerber Reservoir.Inflow" [], @"t" ) ) ), "SolveOutflow"( % "Gerber Reservoir", $ "Gerber Reservoir.Inflow" [], "ElevationToStorage"( % "Gerber Reservoir", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Gerber Reservoir"] ), "PreviousStorage"( % "Gerber Reservoir" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

    END;

    RULE                 "Clear Lake Instream Flow Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Clear Lake"] := "Max"( "Min"( "Min"( $ "Clear Lake.Inflow" [], "Min"( $ "ReservoirData.MinRelease" [@"t", "Clear Lake"], "GetMaxReleaseGivenInflow"( % "Clear Lake", $ "Clear Lake.Inflow" [], @"t" ) ) ), "SolveOutflow"( % "Clear Lake", $ "Clear Lake.Inflow" [], "ElevationToStorage"( % "Clear Lake", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Clear Lake"] ), "PreviousStorage"( % "Clear Lake" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

    END;

  END;

  POLICY_GROUP   "Forecast Computations";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "No Forecast Error";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirData.UpperKlamathLakePercentForecastError" [] := 0.00000000;

      $ "ReservoirData.WilliamsonPercentForecastError" [] := 0.00000000;

    END;

    RULE                 "Save Iron Gate Routed Klamath Inflow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == "RunStartDate"(  );
    NOTES                "";
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( "RunStartDate"(  ), "RunEndDate"(  ), "1 Days" )) DO
            $ "ReservoirOperations.Iron Gate Routed UKL Inflow" [date] := $ "Keno To Iron Gate Routing.Outflow" [date];

      ENDFOREACH;

    END;

    RULE                 "Initialiize UKL To Iron Gate Routing";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == "RunStartDate"(  );
    NOTES                "";
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( "RunStartDate"(  ), "RunEndDate"(  ), "1 Days" )) DO
            $ "UKL To Keno Gain.Inflow" [date] := $ "Upper Klamath Lake.Inflow" [date];

      ENDFOREACH;

    END;

  END;

  UTILITY_GROUP "Model Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AdjustedProjectSupply" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "m3", $ "ProjectData.ProjectSupply" [date] - $ "ProjectData.ProjectCumForIronGateMin" [date] );

    END;

    FUNCTION       "AvailableClearLakeWater" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cms";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "NovemberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "VolumeToFlow"( "Max"( "PreviousStorage"( % "Clear Lake" ) - "ElevationToStorage"( % "Clear Lake", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Clear Lake"] ), 0.00000000 "m3" ), @"t" )
 ENDIF;

    END;

    FUNCTION       "AvailableGerberReservoirWater" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cms";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "NovemberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "VolumeToFlow"( "Max"( "PreviousStorage"( % "Gerber Reservoir" ) - "ElevationToStorage"( % "Gerber Reservoir", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Gerber Reservoir"] ), 0.00000000 "m3" ), @"t" )
 ENDIF;

    END;

    FUNCTION       "AvailableLostRiverStorageWater" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "AvailableGerberReservoirWater"(  ) + "AvailableClearLakeWater"(  );

    END;

    FUNCTION       "AugNovRefugeProportion" ( NUMERIC remainingProjectSupply )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " 1 NONE";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "DecemberThruJuly"(  ) )
 THEN
  0.00000000
 ELSE
  WITH NUMERIC mon = "GetMonth"( @"t" ) DO
   IF ( mon == 8.00000000 )
   THEN
    "TableInterpolation"( $ "KBPMOperationsData.AugNovRefugeProportions", 0.00000000, 1.00000000, remainingProjectSupply, @"t" )
   ELSE
    IF ( mon == 9.00000000 )
    THEN
     "TableInterpolation"( $ "KBPMOperationsData.AugNovRefugeProportions", 2.00000000, 3.00000000, remainingProjectSupply, @"t" )
    ELSE
     IF ( mon == 10.00000000 )
     THEN
      "TableInterpolation"( $ "KBPMOperationsData.AugNovRefugeProportions", 4.00000000, 5.00000000, remainingProjectSupply, @"t" )
     ELSE
      IF ( mon == 11.00000000 )
      THEN
       "TableInterpolation"( $ "KBPMOperationsData.AugNovRefugeProportions", 6.00000000, 7.00000000, remainingProjectSupply, @"t" )
      ELSE
       0.00000000
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDWITH
 ENDIF;

    END;

    FUNCTION       "ClearLakeIrrigationRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "AvailableLostRiverStorageWater"(  ) > 0.00000000 "cms" )
 THEN
  "Min"( "AvailableClearLakeWater"(  ) / "AvailableLostRiverStorageWater"(  ) * "Max"( $ "Lost River Irrigation Depletions.Diversion Requested" ["DateMin"( @"t + 1", @"Finish Timestep" )] - $ "Lost River Gains.Local Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )], 0.00000000 "cms" ), "GetMaxOutflowGivenInflow"( % "Clear Lake", $ "Clear Lake.Inflow" [], @"t" ) )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    FUNCTION       "ComputeSeepage" ( SLOT theSlot, STRING column, NUMERIC startingArea, NUMERIC endingArea, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      0.50000000 * ( startingArea + endingArea ) * theSlot [date, column];

    END;

    FUNCTION       "EstimateSeepage" ( SLOT theSlot, STRING column, NUMERIC meanArea, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "Estimates furture reservoir evaporation form startDate (usually current time step)<br>thru endDate.  Additional argument of meanArea is estimated average surface<br>area during interval.<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( theSlot [date, column] * meanArea, date )
 ENDFOR;

    END;

    FUNCTION       "EstimatedUKLInflow" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( "SumFlowsToVolume"( $ "Upper Klamath Lake.Inflow", startDate, endDate ) - "EstimateEvaporation"( % "Upper Klamath Lake", "GetMeanArea"( % "Upper Klamath Lake", "ElevationToStorage"( % "Upper Klamath Lake", IF ( startDate > @"t" )
 THEN
  $ "ReservoirData.TargetElevation" [startDate, "Upper Klamath Lake"]
 ELSE
  $ "Upper Klamath Lake.Pool Elevation" ["OffsetDate"( startDate, - 1.00000000, "1 DAYS" )]
 ENDIF ), "ElevationToStorage"( % "Upper Klamath Lake", $ "ReservoirData.TargetElevation" [endDate, "Upper Klamath Lake"] ) ), startDate, endDate ) COMMENTED_BY "Subtract evaporation NRCS forecast is without evaporation", 0.00000000 "m3" );

    END;

    FUNCTION       "EstimatedWilliamsonForecast" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC inflowNoError = "SumFlowsToVolume"( $ "Williamson Near Chiloquin.Gage Outflow", startDate, endDate ) DO
  inflowNoError
 ENDWITH;

    END;

    FUNCTION       "EWARemainingMinimumVolume" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "JuneThruSeptember"(  ) )
 THEN
  IF ( $ "ReservoirOperations.UKL Cumulative Excess Water Release Volume" [@"t - 1"] >= ( $ "KBPMOperationsData.EWARemainMinimumAdjustmentFactors" [@"t", "EWARiverFraction"] * $ "ProjectData.EWARiver" [@"t"] ) )
  THEN
   ( $ "KBPMOperationsData.EWARemainMinimumAdjustmentFactors" [@"t", "AdjustmentFactor"] * $ "ProjectData.EWARiver" [@"t"] )
  ELSE
   0.00000000 "m3"
  ENDIF
 ELSE
  0.00000000 "m3"
 ENDIF;

    END;

    FUNCTION       "FillRateAdjustment" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "FillRateAdjustmentPeriod"(  ) )
 THEN
  "TableInterpolation"( $ "KBPMOperationsData.Fill_rate_adjust", 0.00000000, IF ( "LastYearsUKLMarchSeptInflow"(  ) > $ "KBPMOperationsData.MedianMarchSeptInflow" [] )
  THEN
   1.00000000
  ELSE
   2.00000000
  ENDIF, "UKL_RecentFillRate"( @"t" ) - "UKLNeededFillRate"(  ), @"t" )
 ELSE
  1.00000000
 ENDIF COMMENTED_BY "If November 16 - end of February, then apply fill rate adjustment, else fill rate adjustment is 1.";

    END;

    FUNCTION       "IronGateCapacityCheck" ( NUMERIC request )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "Checks a tenative outflow against outlet works and spillway capacities and computes how much spill is required.<br>This function works most of the time but apparantly, when an unregulated spillway is operating with a power plant,<br>function GetMaxOutflowGivenInflow underestimates the capacity.  The only way that this case was resolved<br>was to invoke the Reduce Inflow Outflow method of the Inflow Outflow Adjustment category.  This reduces the<br>outflow to the actual release capacity.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC estEOPElev = "StorageToElevation"( % "Iron Gate Reservoir", "SolveStorage"( % "Iron Gate Reservoir", $ "Iron Gate Reservoir.Inflow" [], request, "PreviousStorage"( % "Iron Gate Reservoir" ), @"t" ) ) DO
  "Min"( "Max"( "GetMaxOutflowGivenInflow"( % "Iron Gate Reservoir", $ "Iron Gate Reservoir.Inflow" [], @"t" ) - ( "TableInterpolation"( $ "Iron Gate Reservoir.Bypass Table", 0.00000000, 1.00000000, 0.50000000 * ( $ "Iron Gate Reservoir.Pool Elevation" [@"t - 1"] + estEOPElev ), @"t" ) - $ "ReservoirOperations.Iron Gate Hatchery Release" [] ) COMMENTED_BY "Back out unusable fish hatchery bypass capacity", 0.00000000 "cms" ), "Max"( request, "GetMinSpillGivenInflowRelease"( % "Iron Gate Reservoir", $ "Iron Gate Reservoir.Inflow" [], "Min"( "Max"( request - $ "ReservoirOperations.Iron Gate Hatchery Release" [], 0.00000000 "cms" ), "GetMaxReleaseGivenInflow"( % "Iron Gate Reservoir", $ "Iron Gate Reservoir.Inflow" [], @"t" ) ), @"t" ) COMMENTED_BY "Flow that we have to spill thru spillways and bypass." ) )
 ENDWITH;

    END;

    FUNCTION       "IronGateMaxRamping" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( $ "ReservoirOperations.Iron Gate Hatchery Release" [date], WITH NUMERIC flowChange = $ "Iron Gate Reservoir.Outflow" [date] COMMENTED_BY "Effectively, yesterday IG spill" - $ "Iron Gate Reservoir.Outflow" ["OffsetDate"( date, - 1.00000000, "1 Days" )] DO
  "Max"( $ "ReservoirOperations.Iron Gate ENV Release" [date] + $ "ReservoirOperations.Iron Gate Hatchery Release" [date], IF ( flowChange < 0.00000000 "cms" AND NOT ( "IronGatePreviousUnregulated"( date ) >= 0.00000000 "cfs" AND "IronGatePreviousUnregulated"( "OffsetDate"( date, - 1.00000000, "1 Days" ) ) >= 0.00000000 "cfs" ) )
  THEN
   ( $ "Iron Gate Reservoir.Outflow" ["OffsetDate"( date, - 1.00000000, "1 Days" )] - "Min"( - 1.00000000 * flowChange, IF ( "Max"( 0.00000000 "cms", $ "Iron Gate Reservoir.Outflow" [date] - $ "ReservoirOperations.Iron Gate ENV Release" [date] ) COMMENTED_BY "Effectively, yesterday IG spill" <= ( $ "ReservoirData.Iron Gate Ramping Criteria" ["Threshold", "Middle Descending"] + $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Middle Descending"] ) AND "Max"( 0.00000000 "cms", $ "Iron Gate Reservoir.Outflow" [date] - $ "ReservoirOperations.Iron Gate ENV Release" [date] ) COMMENTED_BY "Effectively, yesterday IG spill" > ( $ "ReservoirData.Iron Gate Ramping Criteria" ["Threshold", "Low Descending"] + $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"] ) )
   THEN
    $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Middle Descending"]
   ELSE
    IF ( "Max"( 0.00000000 "cms", $ "Iron Gate Reservoir.Outflow" [date] - $ "ReservoirOperations.Iron Gate ENV Release" [date] ) COMMENTED_BY "Effectively, yesterday IG spill" <= ( $ "ReservoirData.Iron Gate Ramping Criteria" ["Threshold", "Low Descending"] + $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"] ) )
    THEN
     $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"]
    ELSE
     "Max"( 0.00000000 "cms", $ "Iron Gate Reservoir.Outflow" [date] - $ "ReservoirOperations.Iron Gate ENV Release" [date] )
    ENDIF
   ENDIF ) ) COMMENTED_BY "Descening limit is, <br>  if (proposed flow > 3000) then rate of decline is net UKL inflow + Keno to IG accretions<br>  else if (1750 < flow <= 3000) then rate of decline is 300 cfs<br>  else if (flow <= 1750) then rate of decline is 150 cfs"
  ELSE
   "Max"( 0.00000000 "cms", $ "Iron Gate Reservoir.Outflow" [date] - $ "ReservoirOperations.Iron Gate ENV Release" [date] ) COMMENTED_BY "Ascending ramping is not restricted"
  ENDIF )
 ENDWITH );

    END;

    FUNCTION       "IronGateRampingLowerBound" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "cms", "IronGatePreviousUnregulated"( date ) - "Max"( 0.00000000 "cms", $ "Iron Gate Reservoir.Outflow" [date] - $ "ReservoirOperations.Iron Gate ENV Release" [date] ) - "IronGateMaxRamping"( date ) );

    END;

    FUNCTION       "IronGatePreviousUnregulated" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Min"( "Max"( 0.00000000 "cms", $ "Upper Klamath Lake.Outflow" [date] - ( $ "ReservoirOperations.UKL Environmental Release" [date] + $ "ReservoirOperations.UKL Demand Release" [date] ) - $ "ProjectData.ProjectReleaseForIronGateMin" [date] ), "Max"( 0.00000000 "cms", $ "Iron Gate Reservoir.Outflow" [date] - $ "ReservoirOperations.Iron Gate Hatchery Release" [date] - $ "ReservoirOperations.Iron Gate ENV Release" [date] ) COMMENTED_BY "Effectively, yesterday IG spill" );

    END;

    FUNCTION       "GerberIrrigationRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "AvailableLostRiverStorageWater"(  ) > 0.00000000 "cms" )
 THEN
  "Min"( "Min"( "AvailableGerberReservoirWater"(  ), "Max"( "Max"( $ "Lost River Irrigation Depletions.Diversion Requested" ["DateMin"( @"t + 1", @"Finish Timestep" )] - $ "Lost River Gains.Local Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )], 0.00000000 "cms" ) - "Min"( $ "Clear Lake.Outflow" [], "ClearLakeIrrigationRelease"(  ) ), 0.00000000 "cms" ) ), "GetMaxOutflowGivenInflow"( % "Gerber Reservoir", $ "Gerber Reservoir.Inflow" [], @"t" ) )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    FUNCTION       "KenoToIronGateNetAccretion" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "SumSlotSkipNaN"( $ "Keno to Boyle Gain.Local Inflow", startDate, endDate ) + "SumSlotSkipNaN"( $ "Boyle Bypass Reach.Local Inflow", startDate, endDate ) + "SumSlotSkipNaN"( $ "Boyle Gage to Copco Gain.Local Inflow", startDate, endDate ) + "SumSlotSkipNaN"( $ "Copco to Iron Gate Gain.Local Inflow", startDate, endDate ) + "AverageDailyFlowForVolume"( "SumSlotSkipNaN"( $ "JC Boyle Reservoir.Precipitation Volume", startDate, endDate ) + "SumSlotSkipNaN"( $ "Copco 1 Reservoir.Precipitation Volume", startDate, endDate ) + "SumSlotSkipNaN"( $ "Iron Gate Reservoir.Precipitation Volume", startDate, endDate ), startDate, endDate ) - "AverageDailyFlowForVolume"( "SumSlotSkipNaN"( $ "JC Boyle Reservoir.Evaporation", startDate, endDate ) + "SumSlotSkipNaN"( $ "Copco 1 Reservoir.Evaporation", startDate, endDate ) + "SumSlotSkipNaN"( $ "Iron Gate Reservoir.Evaporation", startDate, endDate ), startDate, endDate );

    END;

    FUNCTION       "LastYearsUKLMarchSeptInflow" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < "OffsetDate"( @"Start Timestep", 1.00000000, "1 YEARS" ) )
 THEN
  $ "KBPMOperationsData.MedianMarchSeptInflow" []
 ELSE
  "SumFlowsToVolume"( $ "Upper Klamath Lake.Inflow", IF ( "GetMonth"( @"t" ) > 9.00000000 )
  THEN
   @"24:00:00 March 1, Current Year"
  ELSE
   @"24:00:00 March 1, Previous Year"
  ENDIF, IF ( "GetMonth"( @"t" ) > 9.00000000 )
  THEN
   @"24:00:00 September Max DayOfMonth, Current Year"
  ELSE
   @"24:00:00 September Max DayOfMonth, Previous Year"
  ENDIF )
 ENDIF;

    END;

    FUNCTION       "LinkDamIFRAccretionAdjustment" ( NUMERIC netAccretion )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " 1 NONE";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( $ "KBPMOperationsData.LinkDamIFROptions" ["NetAccretion", 0.00000000] == 0.00000000 )
 THEN
  1.00000000
 ELSE
  WITH NUMERIC mon = "GetMonth"( @"t" ) DO
   IF ( mon == 10.00000000 )
   THEN
    "TableInterpolation"( $ "KBPMOperationsData.AccretionIFRProportions", 0.00000000, 1.00000000, netAccretion, @"t" )
   ELSE
    IF ( mon == 11.00000000 )
    THEN
     "TableInterpolation"( $ "KBPMOperationsData.AccretionIFRProportions", 2.00000000, 3.00000000, netAccretion, @"t" )
    ELSE
     IF ( mon == 12.00000000 )
     THEN
      "TableInterpolation"( $ "KBPMOperationsData.AccretionIFRProportions", 4.00000000, 5.00000000, netAccretion, @"t" )
     ELSE
      IF ( mon == 1.00000000 )
      THEN
       "TableInterpolation"( $ "KBPMOperationsData.AccretionIFRProportions", 6.00000000, 7.00000000, netAccretion, @"t" )
      ELSE
       IF ( mon == 2.00000000 )
       THEN
        "TableInterpolation"( $ "KBPMOperationsData.AccretionIFRProportions", 8.00000000, 9.00000000, netAccretion, @"t" )
       ELSE
        1.00000000
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDWITH
 ENDIF;

    END;

    FUNCTION       "LinkDamIFRWilliamsonProportion" ( NUMERIC williamsonFlow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " 1 NONE";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( $ "KBPMOperationsData.LinkDamIFROptions" ["WilliamsonFlow", 0.00000000] == 0.00000000 )
 THEN
  1.00000000
 ELSE
  WITH NUMERIC mon = "GetMonth"( @"t" ) DO
   IF ( mon == 10.00000000 )
   THEN
    "TableInterpolation"( $ "KBPMOperationsData.WilliamsonIFFProportions", 0.00000000, 1.00000000, williamsonFlow, @"t" )
   ELSE
    IF ( mon == 11.00000000 )
    THEN
     "TableInterpolation"( $ "KBPMOperationsData.WilliamsonIFFProportions", 2.00000000, 3.00000000, williamsonFlow, @"t" )
    ELSE
     IF ( mon == 12.00000000 )
     THEN
      "TableInterpolation"( $ "KBPMOperationsData.WilliamsonIFFProportions", 4.00000000, 5.00000000, williamsonFlow, @"t" )
     ELSE
      IF ( mon == 1.00000000 )
      THEN
       "TableInterpolation"( $ "KBPMOperationsData.WilliamsonIFFProportions", 6.00000000, 7.00000000, williamsonFlow, @"t" )
      ELSE
       IF ( mon == 2.00000000 )
       THEN
        "TableInterpolation"( $ "KBPMOperationsData.WilliamsonIFFProportions", 8.00000000, 9.00000000, williamsonFlow, @"t" )
       ELSE
        1.00000000
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDWITH
 ENDIF;

    END;

    FUNCTION       "March50Volume" ( DATETIME theDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "MarchThruJune"(  ) )
 THEN
  IF ( "GetMonth"( theDate ) == 3.00000000 )
  THEN
   "EstimatedUKLInflow"( "GetDate"( "March 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) COMMENTED_BY "March thru September Forecasted Inflow"
  ELSE
   IF ( "GetMonth"( theDate ) == 4.00000000 )
   THEN
    ( "EstimatedUKLInflow"( "GetDate"( "April 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + ( "SumFlowsToVolumeSkipNaN"( $ "Upper Klamath Lake.Inflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "March 31, Current Year" ) ) - "SumSlot"( $ "Upper Klamath Lake.Evaporation", "GetDate"( "March 1, Current Year" ), "GetDate"( "March 31, Current Year" ) ) ) ) COMMENTED_BY "April thru September Forecasted Inflow Plus March Actual Inflow"
   ELSE
    IF ( "GetMonth"( theDate ) == 5.00000000 )
    THEN
     ( "EstimatedUKLInflow"( "GetDate"( "May 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + ( "SumFlowsToVolumeSkipNaN"( $ "Upper Klamath Lake.Inflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "April 30, Current Year" ) ) - "SumSlot"( $ "Upper Klamath Lake.Evaporation", "GetDate"( "March 1, Current Year" ), "GetDate"( "April 30, Current Year" ) ) ) ) COMMENTED_BY "May thru September Forecasted Inflow Plus March thru April Actual Inflow"
    ELSE
     "EstimatedUKLInflow"( "GetDate"( "June 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) COMMENTED_BY "June thru September Forecasted Inflow Plus March thru May Actual Inflow" + ( "SumFlowsToVolumeSkipNaN"( $ "Upper Klamath Lake.Inflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "May 31, Current Year" ) ) - "SumSlot"( $ "Upper Klamath Lake.Evaporation", "GetDate"( "March 1, Current Year" ), "GetDate"( "May 31, Current Year" ) ) )
    ENDIF
   ENDIF
  ENDIF
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    FUNCTION       "ProjectIsFull" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "DecemberThruFebruary"(  ) )
 THEN
  FALSE
 ELSE
  IF ( "OctoberThruNovember"(  ) )
  THEN
   IF ( $ "ProjectData.UKLSupply" [@"24:00:00 September Max DayOfMonth, Current Year"] - $ "ProjectData.EWARiver" [@"24:00:00 September Max DayOfMonth, Current Year"] >= $ "KBPMOperationsData.ProjectMaximumSupply" [] OR $ "ProjectData.UKLSupply" [@"24:00:00 September Max DayOfMonth, Current Year"] >= $ "KBPMOperationsData.UKLSupplyProjectFullThrehold" [] )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ELSE
   IF ( $ "ProjectData.UKLSupply" [] - $ "ProjectData.EWARiver" [] >= $ "KBPMOperationsData.ProjectMaximumSupply" [] OR $ "ProjectData.UKLSupply" [] >= $ "KBPMOperationsData.UKLSupplyProjectFullThrehold" [] )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDIF
 ENDIF;

    END;

    FUNCTION       "RemainingProjectSupply" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "m3", "AdjustedProjectSupply"( date ) - $ "ProjectData.CumAgMarchThruNovDelivery" ["OffsetDate"( date, - 1.00000000, "1 days" )] );

    END;

    FUNCTION       "SeaonalVolumeFromMonthlySlots" ( SLOT slotToCompute, DATETIME monthlyDatetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "Returns a seasonal volume from monthly flow slots.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC monthNum = "GetMonth"( monthlyDatetime ) DO
  IF ( monthNum > 9.00000000 )
  THEN
   WITH DATETIME firstDatetime = @"24:00:00 October Max DayOfMonth, Current Year" DO
    WITH DATETIME middleDatetime = @"24:00:00 November Max DayOfMonth, Current Year" DO
     WITH DATETIME lastDatetime = @"24:00:00 December Max DayOfMonth, Current Year" DO
      "SumFlowsToVolume"( slotToCompute, firstDatetime, firstDatetime ) + "SumFlowsToVolume"( slotToCompute, middleDatetime, middleDatetime ) + "SumFlowsToVolume"( slotToCompute, lastDatetime, lastDatetime )
     ENDWITH
    ENDWITH
   ENDWITH COMMENTED_BY "Fall"
  ELSE
   IF ( monthNum < 4.00000000 )
   THEN
    WITH DATETIME firstDatetime = @"24:00:00 January Max DayOfMonth, Current Year" DO
     WITH DATETIME middleDatetime = @"24:00:00 February Max DayOfMonth, Current Year" DO
      WITH DATETIME lastDatetime = @"24:00:00 March Max DayOfMonth, Current Year" DO
       "SumFlowsToVolume"( slotToCompute, firstDatetime, firstDatetime ) + "SumFlowsToVolume"( slotToCompute, middleDatetime, middleDatetime ) + "SumFlowsToVolume"( slotToCompute, lastDatetime, lastDatetime )
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "Winter"
   ELSE
    IF ( monthNum > 3.00000000 AND monthNum < 7.00000000 )
    THEN
     WITH DATETIME firstDatetime = @"24:00:00 April Max DayOfMonth, Current Year" DO
      WITH DATETIME middleDatetime = @"24:00:00 May Max DayOfMonth, Current Year" DO
       WITH DATETIME lastDatetime = @"24:00:00 June Max DayOfMonth, Current Year" DO
        "SumFlowsToVolume"( slotToCompute, firstDatetime, firstDatetime ) + "SumFlowsToVolume"( slotToCompute, middleDatetime, middleDatetime ) + "SumFlowsToVolume"( slotToCompute, lastDatetime, lastDatetime )
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "Spring"
    ELSE
     WITH DATETIME firstDatetime = @"24:00:00 July Max DayOfMonth, Current Year" DO
      WITH DATETIME middleDatetime = @"24:00:00 August Max DayOfMonth, Current Year" DO
       WITH DATETIME lastDatetime = @"24:00:00 September Max DayOfMonth, Current Year" DO
        "SumFlowsToVolume"( slotToCompute, firstDatetime, firstDatetime ) + "SumFlowsToVolume"( slotToCompute, middleDatetime, middleDatetime ) + "SumFlowsToVolume"( slotToCompute, lastDatetime, lastDatetime )
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "Summer"
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END;

    FUNCTION       "UKLDailyFloodControlRelease" ( OBJECT reservoir, STRING column, DATETIME endDate, NUMERIC maxRelease, NUMERIC forecastVolume, NUMERIC fcStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes flood control release for a daily time step as function of today's maximum storage<br>and today's flood control storage.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC fcRelease = "Max"( 0.00000000 "cms", "SolveOutflow"( reservoir, reservoir & "Inflow" [], fcStorage, "PreviousStorage"( reservoir ), @"t" ) ) DO
  IF ( fcRelease > maxRelease )
  THEN
   WITH NUMERIC maxRelStorage = "Max"( 0.00000000 "m3", "SolveStorage"( reservoir, reservoir & "Inflow" [], maxRelease, "PreviousStorage"( reservoir ), @"t" ) ) DO
    WITH NUMERIC maxStorage = "DailyMaximumStorage"( reservoir, column, @"t" ) DO
     IF ( maxRelStorage > maxStorage )
     THEN
      "Max"( 0.00000000 "cms", "SolveOutflow"( reservoir, reservoir & "Inflow" [], maxStorage, "PreviousStorage"( reservoir ), @"t" ) )
     ELSE
      maxRelease
     ENDIF
    ENDWITH
   ENDWITH
  ELSE
   fcRelease
  ENDIF
 ENDWITH;

    END;

    FUNCTION       "UKL_FillRateRatioSpring" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "MarchThruMay"(  ) )
 THEN
  "Min"( 1.00000000, ( $ "Upper Klamath Lake.Pool Elevation" [@"t - 1"] - $ "ReservoirData.ReservoirAllocations" ["Inactive", "Upper Klamath Lake"] ) / ( $ "ReservoirOperations.TargetElevation" [@"t", "Upper Klamath Lake"] - $ "ReservoirData.ReservoirAllocations" ["Inactive", "Upper Klamath Lake"] ) )
 ELSE
  1.00000000
 ENDIF;

    END;

    FUNCTION       "UKLNeededFillRate" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 feet/day";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "OctoberThruDecember"(  ) )
 THEN
  "Max"( ( ( $ "ReservoirOperations.TargetElevation" [@"24:00:00 December 31, Current Year", "Upper Klamath Lake"] - $ "Upper Klamath Lake.Pool Elevation" [@"t - 1"] ) / ( "GetJulianDate"( @"24:00:00 December 31, Current Year" ) * 1.00000000 "day" - "GetJulianDate"( @"t" ) * 1.00000000 "day" + 1.00000000 "day" ) ) COMMENTED_BY "KBS criteria", ( ( $ "KBPMOperationsData.UKL_Fill_Target" [] - $ "Upper Klamath Lake.Pool Elevation" [@"t - 1"] ) / ( "GetJulianDate"( @"24:00:00 February Max DayOfMonth, Next Year" ) * 1.00000000 "day" - "GetJulianDate"( @"t" ) * 1.00000000 "day" + 1.00000000 "day" ) ) COMMENTED_BY "KBPM criteria" )
 ELSE
  IF ( "JanuaryThruFebruary"(  ) )
  THEN
   "Max"( ( ( $ "ReservoirOperations.TargetElevation" [@"24:00:00 April 30, Current Year", "Upper Klamath Lake"] - $ "Upper Klamath Lake.Pool Elevation" [@"t - 1"] ) / ( "GetJulianDate"( @"24:00:00 April 30, Current Year" ) * 1.00000000 "day" - "GetJulianDate"( @"t" ) * 1.00000000 "day" + 1.00000000 "day" ) ) COMMENTED_BY "KBS criteria", ( ( $ "KBPMOperationsData.UKL_Fill_Target" [] - $ "Upper Klamath Lake.Pool Elevation" [@"t - 1"] ) / ( "GetJulianDate"( @"24:00:00 February Max DayOfMonth, Current Year" ) * 1.00000000 "day" - "GetJulianDate"( @"t" ) * 1.00000000 "day" + 1.00000000 "day" ) ) COMMENTED_BY "KBPM criteria" )
  ELSE
   0.00000000 "m/s"
  ENDIF
 ENDIF;

    END;

    FUNCTION       "UKLToIronGateNetAccretion" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "UKLToKenoNetAccretion"( startDate, endDate ) + "KenoToIronGateNetAccretion"( startDate, endDate );

    END;

    FUNCTION       "UKL_RecentFillRate" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 feet/day";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( date > @"Start Timestep + 5" )
 THEN
  ( $ "Upper Klamath Lake.Pool Elevation" [date - 1.00000000 "day"] - $ "Upper Klamath Lake.Pool Elevation" [date - 7.00000000 "day"] ) / ( 7.00000000 * 86400.00000000 "sec" )
 ELSE
  0.00000000 "m/s"
 ENDIF COMMENTED_BY "compute mean fill rate over past 7 days - ensure timestep>6";

    END;

    FUNCTION       "UKLToKenoNetAccretion" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "SumSlotSkipNaN"( $ "Lost River To Klamath River.Inflow2", startDate, endDate ) + "SumSlotSkipNaN"( $ "Lake Ewuana Gain.Local Inflow", startDate, endDate ) + "SumSlotSkipNaN"( $ "F and FF Pumps.Outflow", startDate, endDate ) + "SumSlotSkipNaN"( $ "Change In Non Project Depletions.Return Flow", startDate, endDate ) - ( "SumSlotSkipNaN"( $ "Klamath River To Area1.Outflow", startDate, endDate ) + "SumSlotSkipNaN"( $ "ProjectData.LostToArea2SpringSummer", startDate, endDate ) );

    END;

    FUNCTION       "UKLRampingLowerBound" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "ReservoirOperations.UKL To Iron Gate IFR Pass Thru" [@"t"] - "IronGateMaxRamping"( @"t" );

    END;

  END;

  UTILITY_GROUP "AggDisagg Averaging Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AddNumericLists" ( LIST firstList, LIST secondList )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns lists of the sum of 2 lists.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( ( LENGTH firstList ) == 0.00000000 OR ( LENGTH firstList ) != LENGTH secondList )
 THEN
  {  }
 ELSE
  FOR ( NUMERIC index IN "MakeForLoopList"( LENGTH firstList ) ) WITH LIST result = {  } DO
   APPEND ( GET @INDEX index FROM firstList ) + GET @INDEX index FROM secondList ONTO result
  ENDFOR
 ENDIF;

    END;

    FUNCTION       "AddUpstreamStorage" ( LIST listOfReservoirs, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Add storages for requested timestep and list of reservoirs.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( OBJECT index IN listOfReservoirs ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + index & "Storage" [datetime]
 ENDFOR;

    END;

    FUNCTION       "AverageDailyFlowForVolume" ( NUMERIC volume, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes average daily flow given a volume and period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "VolumeToFlow"( volume * 1.00000000 "day" / ( "GetJulianDate"( endDate ) * 1.00000000 "day" - "GetJulianDate"( startDate ) * 1.00000000 "day" + 1.00000000 "day" ), @"t" );

    END;

    FUNCTION       "AverageMonthlyFlowForVolume" ( NUMERIC volume, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " acre-feet/month ";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetUnitlessDaysInMonth"( startDate ) * "VolumeToFlow"( volume * 1.00000000 "day" / ( "GetJulianDate"( endDate ) * 1.00000000 "day" - "GetJulianDate"( "BeginOfMonthDate"( startDate ) ) * 1.00000000 "day" + 1.00000000 "day" ), startDate );

    END;

    FUNCTION       "DailyAverageFlowDuringPeriod" ( NUMERIC timeStep, SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Compute average flow for a period and slot.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC numberDays = "GetNumberOfDays"( timeStep, startDate, endDate ) DO
  IF ( numberDays >= 1.00000000 )
  THEN
   "SumFlowsToVolumeSkipNaN"( slot, startDate, endDate ) / ( numberDays * 1.00000000 "day" )
  ELSE
   0.00000000 "cms"
  ENDIF
 ENDWITH;

    END;

    FUNCTION       "FlowFractionComputation" ( DATETIME dailyDateTime, DATETIME monthlyDateTime, SLOT dailySlot, SLOT monthlySlot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Computes daily flow fraction given daily flow and monthly flow.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( monthlySlot [monthlyDateTime] > 0.00000000 "cms" )
 THEN
  dailySlot [dailyDateTime] / monthlySlot [monthlyDateTime] * ( 1.00000000 "day" / "GetDaysInMonth"( monthlyDateTime ) )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    FUNCTION       "FlowFractionDisaggregation" ( DATETIME dailyDateTime, DATETIME monthlyDateTime, SLOT dailyFractionSlot, SLOT monthlySlot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes daily values as a fraction of monthly values.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      dailyFractionSlot [dailyDateTime] * ( monthlySlot [monthlyDateTime] * ( "GetDaysInMonth"( monthlyDateTime ) / 1.00000000 "day" ) );

    END;

    FUNCTION       "MonthlyVolumeFromMonthlyFlow" ( NUMERIC monthlyFlow, DATETIME dateTime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " acre-feet ";
    DESCRIPTION    "Computes monthly flow from monthly volume to deal with monthly data objects flows in a daily model.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "FlowToVolume"( monthlyFlow, dateTime ) * "GetUnitlessDaysInMonth"( dateTime );

    END;

    FUNCTION       "PeriodAverage" ( SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Computes Period Average - can replace this with palette Avg function.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH LIST values = "GetSlotVals"( slot, startDate, endDate ) DO
  "Sum"( values ) / LENGTH values
 ENDWITH;

    END;

    FUNCTION       "ProratedFlowDisaggregation" ( DATETIME dailyDateTime, DATETIME monthlyDateTime, SLOT dailyRefSlot, SLOT monthlyRefSlot, SLOT monthlyItemSlot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Disaggregates by proration of another slot's daily to monthly values.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( monthlyRefSlot [monthlyDateTime] > 0.00000000 "cms" )
 THEN
  dailyRefSlot [dailyDateTime] / monthlyRefSlot [monthlyDateTime] * monthlyItemSlot [monthlyDateTime]
 ELSE
  monthlyItemSlot [monthlyDateTime]
 ENDIF;

    END;

    FUNCTION       "SumDailyFlowsInListToVolume" ( LIST listToSum )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums daily flows in provided list to a volume.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      86400.00000000 "s" * "Sum"( listToSum );

    END;

    FUNCTION       "SumDailyFlowsInSlotToVolume" ( SLOT slotToSum, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums volume of a daily slot.  Intended to be used in monthly models.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      86400.00000000 "s" * "SumSlot"( slotToSum, startDate, endDate );

    END;

    FUNCTION       "SumFlowValueToVolume" ( DATETIME startDate, DATETIME endDate, NUMERIC valueToSum )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "Sum specified flow value to a volume for specified time period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME dateTime IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( valueToSum, dateTime )
 ENDFOR;

    END;

    FUNCTION       "SumMonthlyFlowTableToVolume" ( OBJECT reservoir, SLOT objectSlot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums columns of months in a table slot to a volume for a specified period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( objectSlot [STRINGIFY reservoir, "GetMonthAsString"( index )], index )
 ENDFOR;

    END;

    FUNCTION       "SumNegativeDailyFlowsInSlotToVolume" ( SLOT slotToSum, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums negative days flows to a volume.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN "GetDates"( startDate, endDate, "1 Days" ) ) WITH NUMERIC result = 0.00000000 "m3" DO
  IF ( slotToSum [index] < 0.00000000 "cms" )
  THEN
   result + 86400.00000000 "s" * slotToSum [index]
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "SumPeriodicFlowToVolume" ( SLOT slot, DATETIME startDate, DATETIME endDate, STRING column )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums a periodic slot flow to a volume for specified time period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( slot [date, column], date )
 ENDFOR;

    END;

    FUNCTION       "SumTableFlowToVolume" ( SLOT objectSlot, DATETIME startDate, DATETIME endDate, STRING row, STRING column )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums a table slot flow to a volume for specified time period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( objectSlot [row, column], date )
 ENDFOR;

    END;

    FUNCTION       "SumUpstreamStorage" ( OBJECT reservoir, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sum upstreams storages for requested timestep.  Subbasin name is specified as AboveReservoirReservoirs.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "AddUpstreamStorage"( "FilterByObjType"( "ListSubbasin"( "Above" CONCAT STRINGIFY reservoir CONCAT "Reservoirs" ), { "StorageReservoir" } ), datetime ) + "AddUpstreamStorage"( "FilterByObjType"( "ListSubbasin"( "Above" CONCAT STRINGIFY reservoir CONCAT "Reservoirs" ), { "SlopePowerReservoir" } ), datetime ) + "AddUpstreamStorage"( "FilterByObjType"( "ListSubbasin"( "Above" CONCAT STRINGIFY reservoir CONCAT "Reservoirs" ), { "LevelPowerReservoir" } ), datetime );

    END;

    FUNCTION       "SumVolumeWithNaNsToVolume" ( SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums a volume slot for specified period with NaNs allowed.  Can now use SumSlotSkipNaNs.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  IF ( IsNaN slot [index] )
  THEN
   result
  ELSE
   result + slot [index]
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "TimeRatedStorageDisaggregation" ( SLOT storageSlot, DATETIME dailyDateTime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Distributes a storage by time from starting value to ending value.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC previousStorage = storageSlot ["EndOfPreviousMonthDate"( dailyDateTime )] DO
  previousStorage + ( storageSlot ["EndOfMonthDate"( dailyDateTime )] - previousStorage ) * ( "GetDayOfMonth"( dailyDateTime ) / "GetDaysInMonth"( dailyDateTime ) )
 ENDWITH;

    END;

  END;

  UTILITY_GROUP "Datetime Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AprilThruJuly" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 March 31, Current Year" AND @"t" < @"24:00:00 August 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AprilThruJune" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 March 31, Current Year" AND @"t" < @"24:00:00 July 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AprilThruOctober" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 March 31, Current Year" AND @"t" < @"24:00:00 November 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AugustThruDecember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 July 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AugustThruOctober" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 July 31, Current Year" AND @"t" < @"24:00:00 November 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AugustThruNovember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 July 31, Current Year" AND @"t" < @"24:00:00 December 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AnnualDatesInDecade" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      { @"24:00:00 December Max DayOfMonth, Current Year - 9 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 8 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 7 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 6 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 5 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 4 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 3 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 2 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 1 Year" };

    END;

    FUNCTION       "BeginOfMonthDate" ( DATETIME dateTime )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns beginning of month date given a date.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "PreviousDate"( dateTime, @"Min DayOfMonth" );

    END;

    FUNCTION       "BigTimestep" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetTimestep"( @"t" ) > 2000000.00000000 "s" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DateIsBetween" ( DATETIME dateA, DATETIME dateB, DATETIME dateC )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Checks if dateA falls between dateB and dateC inclusively.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( dateC > dateB )
 THEN
  IF ( dateA > dateC )
  THEN
   FALSE
  ELSE
   IF ( dateA >= dateB )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDIF
 ELSE
  IF ( dateA > dateB )
  THEN
   FALSE
  ELSE
   IF ( dateA >= dateC )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDIF
 ENDIF;

    END;

    FUNCTION       "DecemberThruFebruary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" > @"24:00:00 November 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DecemberThruJune" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 July 1, Current Year" OR @"t" > @"24:00:00 November 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DecemberThruJuly" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 August 1, Current Year" OR @"t" > @"24:00:00 November 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DecemberThruMay" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 June 1, Current Year" OR @"t" > @"24:00:00 November 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DecisionDate" ( DATETIME datetime, SLOT slot, STRING column )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns true or false given a date, and slot and column of a periodic slot.  If<br>the date of the period slot has a 1, true; otherwise 0.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( slot [datetime, column] == 1.00000000 )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DecisionPeriod" ( DATETIME datetime, SLOT slot )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines if date is in the period of a periodic slot.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH DATETIME startDate = "OffsetDate"( "GetMinDateInList"( "DatesInPeriod"( slot, datetime ) ), 24.00000000, "1 Hours" ) DO
  WITH DATETIME endDate = "OffsetDate"( "GetMaxDateInList"( "DatesInPeriod"( slot, datetime ) ), 24.00000000, "1 Hours" ) DO
   IF ( "DateIsBetween"( datetime, startDate, endDate ) )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "EndOfMonthDate" ( DATETIME dateTime )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns end of month date given date.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "NextDate"( dateTime, @"Max DayOfMonth" );

    END;

    FUNCTION       "EndOfPreviousMonthDate" ( DATETIME dateTime )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns date corresponding to last day of previous month.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "OffsetDate"( dateTime, "GetDayOfMonth"( dateTime ) / - 1.00000000 "day", "1 DAYS" );

    END;

    FUNCTION       "GetMaxDateInList" ( LIST listToMax )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN listToMax ) WITH DATETIME result = @"24:00:00 January 1, Start Year" DO
  IF ( "GetJulianDate"( index ) > "GetJulianDate"( result ) )
  THEN
   index
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "FillRateAdjustmentPeriod" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" > @"24:00:00 November 15, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "GetMinDateInList" ( LIST listToMin )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN listToMin ) WITH DATETIME result = @"24:00:00 December 31, Finish Year" DO
  IF ( "GetJulianDate"( index ) < "GetJulianDate"( result ) )
  THEN
   index
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetDailyDatesInMonth" ( DATETIME dateTime )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of dates in specified monthly datetime.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDates"( "BeginOfMonthDate"( dateTime ), "EndOfMonthDate"( dateTime ), "1 Days" );

    END;

    FUNCTION       "GetNumberOfPeriods" ( NUMERIC timeStep, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Returns number of periods between dates given dates and time step in seconds.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Div"( 86400.00000000 "sec" * ( "GetJulianDate"( endDate ) - "GetJulianDate"( startDate ) ), 1.00000000 "sec", timeStep, 1.00000000 "sec" ) + 1.00000000;

    END;

    FUNCTION       "GetNumberOfDays" ( NUMERIC timeStep, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Returns number of days in specfied period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( timeStep > 2000000.00000000 "sec" )
 THEN
  "GetJulianDate"( endDate ) - "GetJulianDate"( startDate ) + "GetUnitlessDaysInMonth"( startDate )
 ELSE
  "GetJulianDate"( endDate ) - "GetJulianDate"( startDate ) + 1.00000000
 ENDIF;

    END;

    FUNCTION       "GetPreviousMonthAsString" ( DATETIME datetime )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetMonthAsString"( "OffsetDate"( datetime, - 1.00000000, "1 Months" ) );

    END;

    FUNCTION       "GetTimeStepAsString" (  )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns time step as a string in format that OffsetDate and GetDates functions require.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetTimestep"( @"t" ) > 3000000.00000000 "s" )
 THEN
  "1 Years"
 ELSE
  IF ( "GetTimestep"( @"t" ) > 2000000.00000000 "s" AND "GetTimestep"( @"t" ) < 3000000.00000000 "s" )
  THEN
   "1 Months"
  ELSE
   IF ( "GetTimestep"( @"t" ) == 604800.00000000 "s" )
   THEN
    "1 Weeks"
   ELSE
    IF ( "GetTimestep"( @"t" ) == 86400.00000000 "s" )
    THEN
     "1 Days"
    ELSE
     IF ( "GetTimestep"( @"t" ) == 43200.00000000 "s" )
     THEN
      "12 Hours"
     ELSE
      IF ( "GetTimestep"( @"t" ) == 21600.00000000 "s" )
      THEN
       "6 Hours"
      ELSE
       IF ( "GetTimestep"( @"t" ) == 3600.00000000 "s" )
       THEN
        "1 Hours"
       ELSE
        "1 Days"
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF;

    END;

    FUNCTION       "GetUnitlessDaysInMonth" ( DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " NONE ";
    DESCRIPTION    "Returns days in month as NONE units.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDaysInMonth"( datetime ) / 1.00000000 "day";

    END;

    FUNCTION       "GetUnitlessDayOfMonth" ( DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Returns day of month as NONE units<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDayOfMonth"( datetime ) / 1.00000000 "day";

    END;

    FUNCTION       "GetUnitlessDayOfYear" ( DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Returns unitless day of year.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDayOfYear"( datetime ) / 1.00000000 "day";

    END;

    FUNCTION       "JanuaryThruApril" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" <= @"24:00:00 April 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JanuaryThruMay" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" <= @"24:00:00 May 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JanuaryThruJuly" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" <= @"24:00:00 July 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JanuaryThruFebruary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" <= @"24:00:00 February Max DayOfMonth, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JanuaryThruMarch" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" <= @"24:00:00 March 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JulyThruOctober" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 June 30, Current Year" AND @"t" < @"24:00:00 November 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JulyThruSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 June 30, Current Year" AND @"t" < @"24:00:00 October 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JulyThruFebruary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" > @"24:00:00 June 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JulyThruNovember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 June 30, Current Year" AND @"t" < @"24:00:00 December 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JuneThruNovember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 May 31, Current Year" AND @"t" < @"24:00:00 December 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JuneThruSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 May 31, Current Year" AND @"t" < @"24:00:00 October 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruApril" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 May 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruMay" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 June 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruJune" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 July 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruJuly" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 August 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MayThruSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 April 30, Current Year" AND @"t" < @"24:00:00 October 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 October 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruNovember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 December 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MayThruAugust" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 April 30, Current Year" AND @"t" < @"24:00:00 September 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MonthlyDatesInCurrentYear" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of monthly dates (last day of each month) in current year.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDates"( @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year", "1 Months" );

    END;

    FUNCTION       "MonthlyDatesInLastYear" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of end of month dates for the last 12 months.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDates"( "EndOfMonthDate"( "OffsetDate"( @"t", - 11.00000000, "1 Months" ) ), "EndOfMonthDate"( @"t" ), "1 Months" );

    END;

    FUNCTION       "MonthlyDatesInPreviousYear" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of monthly dates (last day of each month) in previous year.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDates"( @"24:00:00 January 31, Previous Year", @"24:00:00 December 31, Previous Year", "1 Months" );

    END;

    FUNCTION       "MonthlyDatesInThisYear" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of end of month dates for the last 12 months including this month.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN "MakeForLoopList"( 12.00000000 ) ) WITH LIST result = {  } DO
  APPEND "OffsetDate"( @"t", index - 11.00000000, "1 Months" ) ONTO result
 ENDFOR;

    END;

    FUNCTION       "MonthlyTimeStep" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "GetTimestep"( @"t" ) > 2000000.00000000 "s" AND "GetTimestep"( @"t" ) < 3000000.00000000 "s" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "NovemberThruDecember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 October 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "NovemberThruFebruary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" > @"24:00:00 October 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "NovemberThruMarch" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 April 1, Current Year" OR @"t" > @"24:00:00 October 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "OctoberThruMarch" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 April 1, Current Year" OR @"t" > @"24:00:00 September 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "SeptemberThruApril" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 May 1, Current Year" OR @"t" > @"24:00:00 August 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "OctoberThruFebruary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" > @"24:00:00 September 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "OctoberThruDecember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 September 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "OctoberThruJune" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 July 1, Current Year" OR @"t" > @"24:00:00 September 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "OctoberThruNovember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 September Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 December 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "StringDay" ( NUMERIC day )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a string version of day of month given diminsionless day of month.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH LIST days = { "1" , "2" , "3" , "4" , "5" , "6" , "7" , "8" , "9" , "10" , "11" , "12" , "13" , "14" , "15" , "16" , "17" , "18" , "19" , "20" , "21" , "22" , "23" , "24" , "25" , "26" , "27" , "28" , "29" , "30" , "31" } DO
  GET @INDEX day - 1.00000000 FROM days
 ENDWITH;

    END;

    FUNCTION       "StringYear" ( NUMERIC numYear )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC firstDigit = "Floor"( numYear / 1000.00000000, 1.00000000 ) DO
  WITH NUMERIC secondDigit = "Floor"( "Mod"( numYear, 0.00000000, 1000.00000000, 0.00000000 ) / 100.00000000, 1.00000000 ) DO
   WITH NUMERIC thirdDigit = "Floor"( "Mod"( numYear, 0.00000000, 100.00000000, 0.00000000 ) / 10.00000000, 1.00000000 ) DO
    WITH NUMERIC fourthDigit = "Floor"( "Mod"( numYear, 0.00000000, 10.00000000, 0.00000000 ) / 1.00000000, 1.00000000 ) DO
     "StringDigit"( firstDigit ) CONCAT "StringDigit"( secondDigit ) CONCAT "StringDigit"( thirdDigit ) CONCAT "StringDigit"( fourthDigit )
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

  END;

  UTILITY_GROUP "Generic Functions";
  DESCRIPTION   "Functions that support generic rule set.";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AcrePrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "AcreFeetPrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "AcreFeetPerMonthPrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet/month]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "BooleanPrint" ( BOOLEAN booleanToPrint )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      booleanToPrint;

    END;

    FUNCTION       "CFSPrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Dummy function to print a cfs value.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "CountLessThanValuesInPeriod" ( SLOT slot, NUMERIC threshold, STRING timeStep, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Counts the number of values less than a specified threshold in a period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN "GetDates"( startDate, endDate, timeStep ) ) WITH NUMERIC result = 0.00000000 DO
  IF ( slot [index] < threshold )
  THEN
   result + 1.00000000
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "CountGreaterThanEqualValuesInPeriod" ( SLOT slot, NUMERIC threshold, STRING timeStep, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Counts the number of values greater than or equal a specified threshold in a period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN "GetDates"( startDate, endDate, timeStep ) ) WITH NUMERIC result = 0.00000000 DO
  IF ( slot [index] >= threshold )
  THEN
   result + 1.00000000
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "DatePrint" ( DATETIME datetime )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      datetime;

    END;

    FUNCTION       "DayPrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[day]";
    DESCRIPTION    "Prints a time period value as number of days.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "DaysToNone" ( NUMERIC duration )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Returns unitless days for a time period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      duration / 1.00000000 "24 hr";

    END;

    FUNCTION       "EveryDayFullFlowMonth" ( SLOT slotToTest, DATETIME monthlyDateTime )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines if a month is a full flow month.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "CountGreaterThanEqualValuesInPeriod"( slotToTest, 0.00000000 "cms", "GetTimeStepAsString"(  ), "BeginOfMonthDate"( monthlyDateTime ), "EndOfMonthDate"( monthlyDateTime ) ) >= "GetUnitlessDaysInMonth"( monthlyDateTime ) )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "FeetPrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[feet]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "FlowInElevationRange" ( OBJECT reservoir, NUMERIC elev1, NUMERIC elev2, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs]";
    DESCRIPTION    "Computes flow from a change in elevation.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "cms", "VolumeToFlow"( "Abs"( "ElevationToStorage"( reservoir, elev1 ) - "ElevationToStorage"( reservoir, elev2 ) ), datetime ) );

    END;

    FUNCTION       "FlowIsBetween" ( NUMERIC flowA, NUMERIC flowB, NUMERIC flowC )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Checks if flowA falls between flowB and flowC inclusively.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( flowC > flowB )
 THEN
  IF ( flowA > flowC )
  THEN
   FALSE
  ELSE
   IF ( flowA >= flowB )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDIF
 ELSE
  IF ( flowA > flowB )
  THEN
   FALSE
  ELSE
   IF ( flowA >= flowC )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDIF
 ENDIF;

    END;

    FUNCTION       "FullFlowMonth" ( SLOT slotToTest, DATETIME monthlyDateTime )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetMonth"( monthlyDateTime ) < 8.00000000 )
 THEN
  IF ( slotToTest ["OffsetDate"( monthlyDateTime, - 1.00000000, "1 MONTHS" ) + 1.00000000 "day"] > 0.00000000 "cms" )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF
 ELSE
  IF ( slotToTest [monthlyDateTime] > 0.00000000 "cms" )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF
 ENDIF;

    END;

    FUNCTION       "GetChangeInReservoirStorage" ( LIST reservoirs )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Takes a list of reservoirs and sums the change in storages";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( OBJECT index IN reservoirs ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + ( index & "Storage" [] - index & "Storage" [@"t - 1"] )
 ENDFOR;

    END;

    FUNCTION       "GetElementOfFlows" ( LIST flowList, NUMERIC flowToMatch )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Get element at requested flow.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN "MakeForLoopList"( LENGTH flowList ) ) WITH NUMERIC result = - 1.00000000 DO
  IF ( result == - 1.00000000 )
  THEN
   IF ( "Abs"( ( GET @INDEX index FROM flowList ) - flowToMatch ) < 0.00000001 "cms" )
   THEN
    index
   ELSE
    result
   ENDIF
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetElementOfVolumes" ( LIST volumeList, NUMERIC volumeToMatch )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Gets element at requested volume.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN "MakeForLoopList"( LENGTH volumeList ) ) WITH NUMERIC result = - 1.00000000 DO
  IF ( result == - 1.00000000 )
  THEN
   IF ( "Abs"( ( GET @INDEX index FROM volumeList ) - volumeToMatch ) < 0.00000001 "m3" )
   THEN
    index
   ELSE
    result
   ENDIF
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMaxFlowInList" ( LIST listToMax )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listToMax ) WITH NUMERIC result = 0.00000000 "cms" DO
  IF ( IsNaN index )
  THEN
   result
  ELSE
   "Max"( result, index )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMaxFlowInPeriod" ( SLOT slotToUse, LIST datesToUse )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes maximum flow during specified period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN datesToUse ) WITH NUMERIC result = - 99999999999999.00000000 "cms" DO
  IF ( IsNaN slotToUse [index] )
  THEN
   result
  ELSE
   "Max"( result, slotToUse [index] )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMaxVolumeInList" ( LIST listToMax )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listToMax ) WITH NUMERIC result = 0.00000000 "m3" DO
  IF ( IsNaN index )
  THEN
   result
  ELSE
   "Max"( result, index )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMeanArea" ( OBJECT reservoir, NUMERIC startStorage, NUMERIC endStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 [acre]";
    DESCRIPTION    "Computes mean surface area for 2 storage values.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      ( "StorageToArea"( reservoir, startStorage ) + "StorageToArea"( reservoir, endStorage ) ) * 0.50000000;

    END;

    FUNCTION       "GetMinFlowInList" ( LIST listToMin )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listToMin ) WITH NUMERIC result = 99999999999999.00000000 "cms" DO
  IF ( IsNaN index )
  THEN
   result
  ELSE
   "Min"( result, index )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMinFlowInPeriod" ( SLOT slotToUse, LIST datesToUse )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes minimum flow in a period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN datesToUse ) WITH NUMERIC result = 99999999999999.00000000 "cms" DO
  IF ( IsNaN slotToUse [index] )
  THEN
   result
  ELSE
   "Min"( result, slotToUse [index] )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMinVolumeInList" ( LIST listToMin )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listToMin ) WITH NUMERIC result = 99999999999999.00000000 "m3" DO
  IF ( IsNaN index )
  THEN
   result
  ELSE
   "Min"( result, index )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "MaximumExists" ( NUMERIC threshold, SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns true if threshold value was exceed in period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "PeriodMaximum"( slot, startDate, endDate ) > threshold )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MaxOutflowAtStorageOfRequestedFlow" ( OBJECT reservoir, NUMERIC request )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Given a flow, compute max q at storage of flow.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetMaxOutflowGivenStorage"( reservoir, "SolveStorage"( reservoir, reservoir & "Inflow" [], request, "PreviousStorage"( reservoir ), @"t" ), @"t" );

    END;

    FUNCTION       "MaxTwoItems" ( LIST list )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns maximum two items in a list.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC max1 = "MaxItem"( list ) DO
  WITH NUMERIC elem1 = FIND max1 WITHIN list DO
   WITH NUMERIC max2 = "MaxItem"( REMOVE ITEM @INDEX elem1 FROM list ) DO
    { max1 , max2 }
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "MeanPoolElevation" ( OBJECT reservoir, NUMERIC outflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Computes mean pool elevation given reservoir and a tenative outflow,<br>taking mean between previous storage and new storage at outflow.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      ( "StorageToElevation"( reservoir, "SolveStorage"( reservoir, reservoir & "Inflow" [], outflow, "PreviousStorage"( reservoir ), @"t" ) ) + "StorageToElevation"( reservoir, "PreviousStorage"( reservoir ) ) ) * 0.50000000;

    END;

    FUNCTION       "MinimumExists" ( NUMERIC threshold, SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns true if period minimum is less than threshold value.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "PeriodMinimum"( slot, startDate, endDate ) < threshold )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MinTwoItems" ( LIST list )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns minimum two items in a list.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC min1 = "MinItem"( list ) DO
  WITH NUMERIC elem1 = FIND min1 WITHIN list DO
   WITH NUMERIC min2 = "MinItem"( REMOVE ITEM @INDEX elem1 FROM list ) DO
    { min1 , min2 }
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "NonePrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Prints a value with NONE units.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "PeriodMaximum" ( SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Computes maximum in period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "MaxItem"( "GetSlotVals"( slot, startDate, endDate ) );

    END;

    FUNCTION       "PeriodMinimum" ( SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Computes Period Minimum";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "MinItem"( "GetSlotVals"( slot, startDate, endDate ) );

    END;

    FUNCTION       "PreviousElevation" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[feet]";
    DESCRIPTION    "Returns previous elevation of reservoir.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      reservoir & "Pool Elevation" [@"t - 1"];

    END;

    FUNCTION       "PreviousStorage" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Returns previous storage of reservoir.<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      reservoir & "Storage" [@"t - 1"];

    END;

    FUNCTION       "RegSpillwayCapacityCheck" ( OBJECT reservoir, NUMERIC request )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes max capacity of all outflow points when no unregulated spillway is involved.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "MonthlyTimeStep"(  ) )
 THEN
  request
 ELSE
  "Min"( request, "GetMaxOutflowGivenInflow"( reservoir, reservoir & "Inflow" [], @"t" ) )
 ENDIF;

    END;

    FUNCTION       "StringDigit" ( NUMERIC digit )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a string given a one digit number.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( digit > 9.00000000 )
 THEN
  ( STRINGIFY digit ) CONCAT "is invalid"
 ELSE
  WITH LIST values = { "0" , "1" , "2" , "3" , "4" , "5" , "6" , "7" , "8" , "9" } DO
   GET @INDEX digit FROM values
  ENDWITH
 ENDIF;

    END;

    FUNCTION       "StringPrint" ( STRING stringToPrint )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      stringToPrint;

    END;

    FUNCTION       "UnregSpillwayCapacityCheck" ( OBJECT reservoir, NUMERIC request )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  cfs";
    DESCRIPTION    "Checks a tenative outflow against outlet works and spillway capacities. <br>Also determines if we have to spill thru unregulated spillway.<br>Assumes that monthly spill calc is used for monthly time steps.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "MonthlyTimeStep"(  ) )
 THEN
  request
 ELSE
  "Min"( "GetMaxOutflowGivenInflow"( reservoir, reservoir & "Inflow" [], @"t" ), WITH NUMERIC release = "Min"( request, "GetMaxReleaseGivenInflow"( reservoir, reservoir & "Inflow" [], @"t" ) COMMENTED_BY "GetMaxReleaseGivenInflow is only Turbine or Outlet Works" ) DO
   release + "GetMinSpillGivenInflowRelease"( reservoir, reservoir & "Inflow" [], release, @"t" )
  ENDWITH )
 ENDIF;

    END;

  END;

  UTILITY_GROUP "List Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "FindFlowGivenDateFromLists" ( DATETIME date, LIST flowsList, LIST datesList )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Returns flow for given date from a lists of flows and dates.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC element = FIND date WITHIN datesList DO
  GET @INDEX element FROM flowsList
 ENDWITH;

    END;

    FUNCTION       "InsertValueDateSetIntoList" ( NUMERIC flow, DATETIME date )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Inserts a value and date set into a list of flows and dates.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      INSERT flow INTO INSERT date INTO {  };

    END;

    FUNCTION       "InsertDateValueSetIntoList" ( DATETIME date, NUMERIC value )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Inserts a date and value set into a list of flows and dates.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      INSERT date INTO INSERT value INTO {  };

    END;

    FUNCTION       "InsertFlowDateSetIntoList" ( NUMERIC flow, DATETIME date )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Inserts a flow and date set into a list of flows and dates.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      INSERT flow INTO INSERT date INTO {  };

    END;

    FUNCTION       "InsertSlotValueSetIntoList" ( SLOT slot, NUMERIC value )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Inserts specified slot and value into a list.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      INSERT slot INTO INSERT value INTO {  };

    END;

    FUNCTION       "MakeListFromValueAndDates" ( NUMERIC dailyValue, LIST datesToUse )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Makes a list of daily flows for a month given monthly flow.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN datesToUse ) WITH LIST result = {  } DO
  APPEND dailyValue ONTO result
 ENDFOR;

    END;

    FUNCTION       "MakeForLoopList" ( NUMERIC numberIndices )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Makes a list of indeces for use in a For Loop.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WHILE ( ( GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) < numberIndices - 1.00000000 ) WITH LIST result = { 0.00000000 } DO
  APPEND ( GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) + 1.00000000 ONTO result
 ENDWHILE;

    END;

    FUNCTION       "MakeIncrementalListGivenInitIncrMax" ( NUMERIC initial, NUMERIC increment, NUMERIC maximum )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Creates a list given an initial value, an inrement, and a maximum.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WHILE ( ( GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) + increment <= maximum ) WITH LIST result = { initial } DO
  APPEND ( GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) + increment ONTO result
 ENDWHILE;

    END;

    FUNCTION       "MakeIncrementalListGivenInitIncrPoints" ( NUMERIC initial, NUMERIC increment, NUMERIC numberPoints )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Creates a list of values given an inital value, an incremental value, and number of points.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN "MakeForLoopList"( numberPoints ) ) WITH LIST result = {  } DO
  IF ( index == 0.00000000 )
  THEN
   APPEND initial ONTO result
  ELSE
   APPEND increment + GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ONTO result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "MakeListGivenValuePoints" ( NUMERIC valueToList, NUMERIC numberPoints )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Make a list of values for a given value and number of points.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN "MakeForLoopList"( numberPoints ) ) WITH LIST result = {  } DO
  APPEND valueToList ONTO result
 ENDFOR;

    END;

    FUNCTION       "MakeListOfDatesAndValues" ( LIST values, LIST dates )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of dates and values.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST listOfDays = "GetNumbers"( 0.00000000, ( LENGTH dates ) - 1.00000000, 1.00000000 ) DO
  FOR ( NUMERIC index IN listOfDays ) WITH LIST result = {  } DO
   INSERT "InsertDateValueSetIntoList"( GET @INDEX index FROM dates, GET @INDEX index FROM values ) INTO result
  ENDFOR
 ENDWITH;

    END;

    FUNCTION       "MakeListOfValuesAndDates" ( LIST flows, LIST dates, LIST listOfDays )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of values and dates.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listOfDays ) WITH LIST result = {  } DO
  INSERT "InsertValueDateSetIntoList"( GET @INDEX index FROM flows, GET @INDEX index FROM dates ) INTO result
 ENDFOR;

    END;

    FUNCTION       "MakeListOfFlowsAndDates" ( LIST flows, LIST dates, LIST listOfDays )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of values and dates.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listOfDays ) WITH LIST result = {  } DO
  INSERT "InsertFlowDateSetIntoList"( GET @INDEX index FROM flows, GET @INDEX index FROM dates ) INTO result
 ENDFOR;

    END;

    FUNCTION       "MakeListOfSlotsAndValues" ( LIST slotsList, LIST valuesList, LIST numberInList )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Makes a list of lists of slots and values<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN numberInList ) WITH LIST result = {  } DO
  INSERT "InsertSlotValueSetIntoList"( GET @INDEX index FROM slotsList, GET @INDEX index FROM valuesList ) INTO result
 ENDFOR;

    END;

    FUNCTION       "ProportionDailyFlowList" ( NUMERIC ratio, SLOT slot )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Proportions a list of daily flow values by user provided ratio.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN "GetDates"( @"t - 1" + 1.00000000 "day", @"t", "1 Days" ) ) WITH LIST result = {  } DO
  APPEND slot [index] * ratio ONTO result
 ENDFOR;

    END;

    FUNCTION       "SubsetNumericList" ( LIST listToSubset, NUMERIC firstIndex, NUMERIC lastIndex )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Subsets a list for specified first and last indices.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( lastIndex < 0.00000000 OR firstIndex < 0.00000000 )
 THEN
  {  }
 ELSE
  FOR ( NUMERIC index IN "MakeForLoopList"( LENGTH listToSubset ) ) WITH LIST result = {  } DO
   IF ( index >= firstIndex AND index <= lastIndex )
   THEN
    APPEND GET @INDEX index FROM listToSubset ONTO result
   ELSE
    result
   ENDIF
  ENDFOR
 ENDIF;

    END;

    FUNCTION       "SubtractNumericLists" ( LIST firstList, LIST secondList )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a numeric list after subtracting 2 lists.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( ( LENGTH firstList ) == 0.00000000 OR ( LENGTH firstList ) != LENGTH secondList )
 THEN
  {  }
 ELSE
  FOR ( NUMERIC index IN "MakeForLoopList"( LENGTH firstList ) ) WITH LIST result = {  } DO
   APPEND ( GET @INDEX index FROM firstList ) - GET @INDEX index FROM secondList ONTO result
  ENDFOR
 ENDIF;

    END;

  END;

  UTILITY_GROUP "Operation Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "ComputeAvailableSpace" ( OBJECT reservoir, STRING column, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "ElevationToStorage"( reservoir, $ "ReservoirOperations.TargetElevation" [datetime, column] ) - "PreviousStorage"( reservoir );

    END;

    FUNCTION       "DailyFloodControlRelease" ( OBJECT reservoir, STRING column, DATETIME endDate, NUMERIC maxRelease, NUMERIC forecastVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes flood control release for a daily time step as function of today's maximum storage<br>and today's flood control storage.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC fcStorage = "DailyFloodControlStorage"( reservoir, column, endDate, maxRelease, forecastVolume ) DO
  WITH NUMERIC fcRelease = "Max"( 0.00000000 "cms", "SolveOutflow"( reservoir, reservoir & "Inflow" [], fcStorage, "PreviousStorage"( reservoir ), @"t" ) ) DO
   IF ( fcRelease > maxRelease )
   THEN
    WITH NUMERIC maxRelStorage = "Max"( 0.00000000 "m3", "SolveStorage"( reservoir, reservoir & "Inflow" [], maxRelease, "PreviousStorage"( reservoir ), @"t" ) ) DO
     WITH NUMERIC maxStorage = "DailyMaximumStorage"( reservoir, column, @"t" ) DO
      IF ( maxRelStorage > maxStorage )
      THEN
       "Max"( 0.00000000 "cms", "SolveOutflow"( reservoir, reservoir & "Inflow" [], maxStorage, "PreviousStorage"( reservoir ), @"t" ) )
      ELSE
       maxRelease
      ENDIF
     ENDWITH
    ENDWITH
   ELSE
    fcRelease
   ENDIF
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "DailyFloodControlStorage" ( OBJECT reservoir, STRING column, DATETIME endDate, NUMERIC maxRelease, NUMERIC forecastVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Computes maximum storage that we can be at today given a forecast thru endDate<br>and the maximum daily release (maxRelease).";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC maxEOPContent = "DailyMaximumStorage"( reservoir, column, endDate ) DO
  WITH NUMERIC maxPeriodRelease = "SumFlowValueToVolume"( "DateMin"( @"t + 1", endDate ), endDate, maxRelease ) DO
   "Max"( "DailyMinimumStorage"( reservoir, column, @"t" ), "Min"( maxEOPContent - forecastVolume + maxPeriodRelease, "DailyMaximumStorage"( reservoir, column, @"t" ) ) )
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "DailyMaximumStorage" ( OBJECT reservoir, STRING column, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Computes daily maximum storage as a function of daily maximum elevation.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "ElevationToStorage"( reservoir, $ "ReservoirData.MaxElevation" [datetime, column] );

    END;

    FUNCTION       "DailyMaximumStorageRelease" ( OBJECT reservoir, STRING column, DATETIME datetime, NUMERIC prevStorage, NUMERIC inflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( datetime < @"Start Timestep" )
 THEN
  0.00000000 "cms"
 ELSE
  "Max"( "SolveOutflow"( reservoir, inflow, "DailyMaximumStorage"( reservoir, column, datetime ), prevStorage, datetime ), 0.00000000 "cms" )
 ENDIF;

    END;

    FUNCTION       "DailyMinimumStorage" ( OBJECT reservoir, STRING column, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Computes daily minimum storage as a function of daily minimum elevation";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "ElevationToStorage"( reservoir, $ "ReservoirData.MinElevation" [datetime, column] );

    END;

    FUNCTION       "DailyMinimumStorageRelease" ( OBJECT reservoir, STRING column, DATETIME datetime, NUMERIC prevStorage, NUMERIC inflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( datetime < @"Start Timestep" )
 THEN
  0.00000000 "cms"
 ELSE
  "Max"( "SolveOutflow"( reservoir, inflow, "DailyMinimumStorage"( reservoir, column, datetime ), prevStorage, datetime ), 0.00000000 "cms" )
 ENDIF;

    END;

    FUNCTION       "DailyTargetStorage" ( OBJECT reservoir, STRING column, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Computes daily target storage as a function of daily target elevation.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "ElevationToStorage"( reservoir, $ "ReservoirOperations.TargetElevation" [datetime, column] );

    END;

    FUNCTION       "DailyTargetStorageRelease" ( OBJECT reservoir, STRING column, DATETIME datetime, NUMERIC prevStorage, NUMERIC inflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( "SolveOutflow"( reservoir, inflow, "DailyTargetStorage"( reservoir, column, datetime ), prevStorage, datetime ), 0.00000000 "cms" );

    END;

    FUNCTION       "EstimateEvaporation" ( OBJECT reservoir, NUMERIC meanArea, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "Estimates furture reservoir evaporation form startDate (usually current time step)<br>thru endDate.  Additional argument of meanArea is estimated average surface<br>area during interval.<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( ( reservoir & "Evaporation Rate" [date] - reservoir & "Precipitation Rate" [date] ) * meanArea, date )
 ENDFOR;

    END;

    FUNCTION       "EstimatedInflowForecast" ( SLOT forecastSlot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC inflowNoError = "SumFlowsToVolume"( forecastSlot, startDate, endDate ) DO
  inflowNoError
 ENDWITH;

    END;

    FUNCTION       "MaxMinElevationCheck" ( OBJECT reservoir, STRING column, NUMERIC request )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "Checks for maximum and minimum elevation constraints expressed in table <br>ReservoirData.MinElevation and ReservoirData.MaxElevation.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( "DailyMaximumStorageRelease"( reservoir, column, @"t", "PreviousStorage"( reservoir ), reservoir & "Inflow" [] ), "Min"( "DailyMinimumStorageRelease"( reservoir, column, @"t", "PreviousStorage"( reservoir ), reservoir & "Inflow" [] ), request ) );

    END;

    FUNCTION       "SurplusVolumeBySlotNoEvap" ( OBJECT reservoir, STRING column, SLOT forecastSlot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "m3", "SumFlowsToVolumeSkipNaN"( forecastSlot, startDate, endDate ) - ( "ComputeAvailableSpace"( reservoir, column, startDate ) + "SumPeriodicFlowToVolume"( $ "ReservoirData.AverageRelease", startDate, endDate, STRINGIFY reservoir ) ) );

    END;

    FUNCTION       "SurplusVolumeBySlot" ( OBJECT reservoir, STRING column, SLOT forecastSlot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " acre-feet ";
    DESCRIPTION    "Computes surplus volume for a reservoir by slot with no forecast error applied.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "m3", "SumFlowsToVolume"( forecastSlot, startDate, endDate ) - ( "ComputeAvailableSpace"( reservoir, column, endDate ) + ( "SumPeriodicFlowToVolume"( $ "ReservoirData.AverageRelease", @"t", endDate, column ) + "EstimateEvaporation"( reservoir, "GetMeanArea"( reservoir, "PreviousStorage"( reservoir ), "DailyTargetStorage"( reservoir, column, endDate ) ), startDate, endDate ) ) ) );

    END;

    FUNCTION       "SurplusVolumeBySlotWithLosses" ( OBJECT reservoir, STRING column, SLOT forecastSlot, NUMERIC anticipatedLoss, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Computes surplus volume from inflows less depletions stored in specified slot.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "m3", "SumFlowsToVolume"( forecastSlot, startDate, endDate ) - ( "ComputeAvailableSpace"( reservoir, column, endDate ) + ( "SumPeriodicFlowToVolume"( $ "ReservoirData.AverageRelease", @"t", endDate, column ) + ( "EstimateEvaporation"( reservoir, "GetMeanArea"( reservoir, "PreviousStorage"( reservoir ), "DailyTargetStorage"( reservoir, column, endDate ) ), startDate, endDate ) + anticipatedLoss ) ) ) );

    END;

  END;

  PREDEFINED_GROUP "Numeric / Math";
  DESCRIPTION   "Predefined functions which perform generic numerical computations.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "Floor" ( NUMERIC arg1, NUMERIC arg2 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "Mod" ( NUMERIC arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "SumFlowsToVolume" ( SLOT arg1, DATETIME arg2, DATETIME arg3 )
    SCALE_UNITS    "1  acre-feet ";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "SumFlowsToVolumeSkipNaN" ( SLOT arg1, DATETIME arg2, DATETIME arg3 )
    SCALE_UNITS    "1 acre-feet";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Date / Time";
  DESCRIPTION   "Predefined functions which access and manipulate date/times.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "GetDate" ( STRING arg1 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetDates" ( DATETIME arg1, DATETIME arg2, STRING arg3 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetDaysInMonth" ( DATETIME arg1 )
    SCALE_UNITS    " day ";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetDayOfMonth" ( DATETIME arg1 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetDayOfYear" ( DATETIME arg1 )
    SCALE_UNITS    " day ";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetYear" ( DATETIME arg1 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "NumberToDate" ( NUMERIC arg1 )
    SCALE_UNITS    " FullDateTime ";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Engineering";
  DESCRIPTION   "Predefined functions similar to methods on objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "GetMaxOutflowGivenInflow" ( OBJECT arg1, NUMERIC arg2, DATETIME arg3 )
    SCALE_UNITS    "1  cfs";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetMaxReleaseGivenInflow" ( OBJECT arg1, NUMERIC arg2, DATETIME arg3 )
    SCALE_UNITS    "1 cfs";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetMinSpillGivenInflowRelease" ( OBJECT arg1, NUMERIC arg2, NUMERIC arg3, DATETIME arg4 )
    SCALE_UNITS    "1 cfs";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "SolveOutflow" ( OBJECT arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4, DATETIME arg5 )
    SCALE_UNITS    "1 cfs";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "SolveStorage" ( OBJECT arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4, DATETIME arg5 )
    SCALE_UNITS    "1 acre-feet";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Workspace";
  DESCRIPTION   "Predefined functions which access information on slots and objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "ElevationToStorage" ( OBJECT arg1, NUMERIC arg2 )
    SCALE_UNITS    "1 acre-feet";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "StorageToElevation" ( OBJECT arg1, NUMERIC arg2 )
    SCALE_UNITS    "1 feet";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "VolumeToFlow" ( NUMERIC arg1, DATETIME arg2 )
    SCALE_UNITS    "1 cfs";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

  END;

END
