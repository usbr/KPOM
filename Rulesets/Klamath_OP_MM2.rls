# RiverWare_Ruleset 7.4.2 Patch
# Created 21:22 March 10, 2019
# 
RULESET
NAME "Klamath Operations RBS ruleset";
AGENDA_ORDER ASCENDING;
DESCRIPTION "";
PRECISION   3;
NOTES "";
BEGIN

  POLICY_GROUP   "OLD Distribute Energy To On Peak and Off Peak";
  DESCRIPTION    "";
  ACTIVE         FALSE;
  NOTES          "";
  BEGIN

    RULE                 "Total Energy";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.OffPeakEnergy" [] := $ "ReservoirOperations.OffPeakEnergy" [@"t", "Boyle"] + $ "ReservoirOperations.OffPeakEnergy" [@"t", "Copco 1"] + $ "ReservoirOperations.OffPeakEnergy" [@"t", "Copco 2"] + $ "ReservoirOperations.OffPeakEnergy" [@"t", "Iron Gate"];

      $ "ReservoirOperations.OnPeakEnergy" [] := $ "ReservoirOperations.OnPeakEnergy" [@"t", "Boyle"] + $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 1"] + $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 2"] + $ "ReservoirOperations.OnPeakEnergy" [@"t", "Iron Gate"];

    END;

    RULE                 "Off Peak Distribution";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.OffPeakEnergy" [@"t", "Boyle"] := $ "JC Boyle Power Plant.Energy" [] - $ "ReservoirOperations.OnPeakEnergy" [@"t", "Boyle"];

      $ "ReservoirOperations.OffPeakEnergy" [@"t", "Copco 1"] := $ "Copco 1.Energy" [] - $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 1"];

      $ "ReservoirOperations.OffPeakEnergy" [@"t", "Copco 2"] := $ "Copco 2 Power Plant.Energy" [] - $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 2"];

      $ "ReservoirOperations.OffPeakEnergy" [@"t", "Iron Gate"] := $ "IGD.Energy" [] - $ "ReservoirOperations.OnPeakEnergy" [@"t", "Iron Gate"];

    END;

    RULE                 "On Peak Distribution";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.OnPeakEnergy" [@"t", "Boyle"] := IF ( @"t" == @"Sunday" )
 THEN
  0.00000000 "MWH"
 ELSE
  WITH NUMERIC peakVolume = "Min"( 0.66666660 * "FlowToVolume"( $ "ReservoirData.TurbineCapacities" ["Boyle", "Flow"], @"t" ), "FlowToVolume"( $ "JC Boyle Power Plant.Outflow" [], @"t" ) ) DO
   IF ( $ "JC Boyle Power Plant.Outflow" [] <= 0.00000000 "cms" )
   THEN
    0.00000000 "MWH"
   ELSE
    $ "JC Boyle Power Plant.Energy" [] * ( peakVolume / "FlowToVolume"( $ "JC Boyle Power Plant.Outflow" [], @"t" ) )
   ENDIF
  ENDWITH
 ENDIF;

      $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 1"] := IF ( @"t" == @"Sunday" )
 THEN
  0.00000000 "MWH"
 ELSE
  0.66666660 * $ "Copco 1.Energy" []
 ENDIF;

      $ "ReservoirOperations.OnPeakEnergy" [@"t", "Copco 2"] := IF ( @"t" == @"Sunday" )
 THEN
  0.00000000 "MWH"
 ELSE
  0.66666660 * $ "Copco 2 Power Plant.Energy" []
 ENDIF;

      $ "ReservoirOperations.OnPeakEnergy" [@"t", "Iron Gate"] := IF ( @"t" == @"Sunday" )
 THEN
  0.00000000 "MWH"
 ELSE
  0.66666660 * $ "IGD.Energy" []
 ENDIF;

    END;

  END;

  POLICY_GROUP   "OLD Power Reservoir Operations";
  DESCRIPTION    "";
  ACTIVE         FALSE;
  NOTES          "";
  BEGIN

    RULE                 "Iron Gate Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "IGD.Outflow" [] := "IronGateCapacityCheck"( "MaxMinElevationCheck"( % "IGD", "IGD", $ "ReservoirOperations.IGD Constrained Release" [] ) );

    END;

    RULE                 "IGD Constrained Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IGD Constrained Release" [] := IF ( @"t" < "OffsetDate"( @"Start Timestep", 2.00000000, "1 Days" ) )
 THEN
  $ "ReservoirOperations.IGD Unconstrained Release" []
 ELSE
  "Max"( $ "ReservoirOperations.IGD Hatchery Release" [], WITH NUMERIC flowChange = $ "ReservoirOperations.IGD Unconstrained Release" [] - $ "IGD.Outflow" [@"t - 1"] DO
   "Max"( $ "ReservoirOperations.IGD ENV Release" [] + $ "ReservoirOperations.IGD Hatchery Release" [], IF ( flowChange < 0.00000000 "cms" AND NOT ( "IronGatePreviousUnregulated"( @"t - 1" ) >= 0.00000000 "cfs" AND "IronGatePreviousUnregulated"( @"t - 2" ) >= 0.00000000 "cfs" ) )
   THEN
    ( $ "IGD.Outflow" [@"t - 1"] - "Min"( - 1.00000000 * flowChange, IF ( $ "ReservoirOperations.IGD Unconstrained Release" [] <= ( $ "ReservoirData.Iron Gate Ramping Criteria" ["Threshold", "Middle Descending"] + $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Middle Descending"] ) AND $ "ReservoirOperations.IGD Unconstrained Release" [] > ( $ "ReservoirData.Iron Gate Ramping Criteria" ["Threshold", "Low Descending"] + $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"] ) )
    THEN
     $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Middle Descending"]
    ELSE
     IF ( $ "ReservoirOperations.IGD Unconstrained Release" [] <= ( $ "ReservoirData.Iron Gate Ramping Criteria" ["Threshold", "Low Descending"] + $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"] ) )
     THEN
      $ "ReservoirData.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"]
     ELSE
      $ "ReservoirOperations.IGD Unconstrained Release" []
     ENDIF
    ENDIF ) ) COMMENTED_BY "Descening limit is, <br>  if (proposed flow > 3000) then rate of decline is net UKL inflow + Keno to IG accretions<br>  else if (1750 < flow <= 3000) then rate of decline is 300 cfs<br>  else if (flow <= 1750) then rate of decline is 150 cfs"
   ELSE
    $ "ReservoirOperations.IGD Unconstrained Release" [] COMMENTED_BY "Ascending ramping is not restricted"
   ENDIF )
  ENDWITH )
 ENDIF COMMENTED_BY "Respect ascending and descending criteria while meeting instream flow requirement.";

    END;

    RULE                 "IGD Unconstrained Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IGD Unconstrained Release" [] := "MaxItem"( { $ "ReservoirOperations.IFRRelease" [@"t", "Iron Gate"] , $ "ReservoirOperations.IGD ENV Release" [] , $ "ReservoirOperations.TargetPowerRelease" [@"t", "Iron Gate"] , $ "ReservoirOperations.TargetRelease" [@"t", "Iron Gate"] } ) COMMENTED_BY "Release that we want to make without ascending and descending criteria." + $ "ReservoirOperations.IGD Hatchery Release" [];

    END;

    RULE                 "Iron Gate Target Power Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetPowerRelease" [@"t", "Iron Gate"] := "Min"( $ "ReservoirData.TurbineCapacities" ["Iron Gate", "Flow"], "Max"( "Min"( "Max"( $ "ReservoirOperations.TargetRelease" [@"t", "Iron Gate"] + ( $ "ReservoirOperations.IGD Hatchery Release" [] + $ "ReservoirOperations.IFRRelease" [@"t", "Iron Gate"] ), "SolveOutflow"( % "IGD", $ "IGD.Inflow" [], "ElevationToStorage"( % "IGD", $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] ), "PreviousStorage"( % "IGD" ), @"t" ) ), "SolveOutflow"( % "IGD", $ "IGD.Inflow" [], "ElevationToStorage"( % "IGD", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ), "PreviousStorage"( % "IGD" ), @"t" ) COMMENTED_BY "Check for low reservoir conditons" ) - $ "ReservoirOperations.IGD Hatchery Release" [], 0.00000000 "cms" ) );

    END;

    RULE                 "IGD IFR Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Iron Gate"] := "Max"( "Min"( $ "ReservoirOperations.IGD ENV Release" [] - $ "ReservoirOperations.IGD Hatchery Release" [], "SolveOutflow"( % "IGD", $ "IGD.Inflow" [], "ElevationToStorage"( % "IGD", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Iron Gate"] ), "PreviousStorage"( % "IGD" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

    END;

    RULE                 "Iron Gate Fish Hatchery Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IGD Hatchery Release" [] := "Max"( "Min"( $ "ReservoirData.Iron Gate Hatchery Request" [], "SolveOutflow"( % "IGD", $ "IGD.Inflow" [], "ElevationToStorage"( % "IGD", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Iron Gate"] ), "PreviousStorage"( % "IGD" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), IF ( $ "IGD.Pool Elevation" [@"t - 1"] > $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] )
 THEN
  "TableInterpolation"( $ "IGD.Bypass Table", 0.00000000, 1.00000000, $ "IGD.Pool Elevation" [@"t - 1"], @"t" )
 ELSE
  0.00000000 "cms"
 ENDIF );

    END;

    RULE                 "Iron Gate Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Iron Gate"] := "DailyTargetStorageRelease"( % "IGD", "IGD", @"t", "PreviousStorage"( % "IGD" ), $ "IGD.Inflow" [] );

    END;

    RULE                 "Copco 2 Power Diversion";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "Copco 2.Diversion" [] := $ "ReservoirOperations.TargetPowerRelease" [@"t", "Copco 2"];

    END;

    RULE                 "Copco 2 Target Power Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetPowerRelease" [@"t", "Copco 2"] := "Min"( $ "ReservoirData.TurbineCapacities" ["Copco 2", "Flow"], "Max"( 0.00000000 "cms", $ "Copco 2.Inflow" [] - $ "ReservoirOperations.IFRRelease" [@"t", "Copco 1"] ) );

    END;

    RULE                 "Copco 1 Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Copco 1.Outflow" [] := "Min"( "MaxMinElevationCheck"( % "Copco 1", "Copco 1", "MaxItem"( { $ "ReservoirOperations.IFRRelease" [@"t", "Copco 1"] , $ "ReservoirOperations.TargetPowerRelease" [@"t", "Copco 1"] , $ "ReservoirOperations.TargetRelease" [@"t", "Copco 1"] , $ "ReservoirOperations.Copco To Iron Gate Pass Thru" [] } ) ), "Max"( 0.00000000 "cms", "GetMaxOutflowGivenInflow"( % "Copco 1", $ "Copco 1.Inflow" [], @"t" ) ) );

    END;

    RULE                 "Copco 1 Target Power Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetPowerRelease" [@"t", "Copco 1"] := "Min"( $ "ReservoirData.TurbineCapacities" ["Copco 1", "Flow"], "Max"( "Min"( "Max"( "Max"( $ "ReservoirOperations.TargetRelease" [@"t", "Copco 1"] + $ "ReservoirOperations.IFRRelease" [@"t", "Copco 1"], $ "ReservoirOperations.Copco To Iron Gate Pass Thru" [] ), "SolveOutflow"( % "Copco 1", $ "Copco 1.Inflow" [], "ElevationToStorage"( % "Copco 1", $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Copco 1"] ), "PreviousStorage"( % "Copco 1" ), @"t" ) ), "SolveOutflow"( % "Copco 1", $ "Copco 1.Inflow" [], "ElevationToStorage"( % "Copco 1", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"] ), "PreviousStorage"( % "Copco 1" ), @"t" ) COMMENTED_BY "Check for low reservoir condiitons" ), 0.00000000 "cms" ) );

    END;

    RULE                 "Copco Iron Gate Pass Thru IFR Release";
    DESCRIPTION          "Releases water intended for Pass Thru IGD IFR requirement.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Copco To Iron Gate Pass Thru" [] := "Min"( $ "ReservoirData.TurbineCapacities" ["Copco 1", "Flow"], "Max"( "Min"( "Max"( $ "ReservoirOperations.IGD ENV Release" COMMENTED_BY "IGD IFR minus downstream gains" [] - $ "Copco to Iron Gate Gain.Local Inflow" [], $ "ReservoirOperations.IFRRelease" COMMENTED_BY "Copco IFR minus downstream gains" [@"t", "Copco 1"] - $ "Copco to Iron Gate Gain.Local Inflow" [] ), "SolveOutflow"( % "Copco 1", $ "Copco 1.Inflow" [], "ElevationToStorage"( % "Copco 1", 0.50000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Copco 1"] + $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"] ) ), "PreviousStorage"( % "Copco 1" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions" ), 0.00000000 "cms" ) );

    END;

    RULE                 "Copco IFR Release";
    DESCRIPTION          "Compute local IFR (fish bypass) (as opposed to water needed for Iron Gate Pass Thru IFR.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Copco 1"] := "Max"( "Min"( "Min"( $ "Copco 1.Inflow" [], "Min"( $ "ReservoirData.MinRelease" [@"t", "Copco 1"], "GetMaxReleaseGivenInflow"( % "Copco 1", $ "Copco 1.Inflow" [], @"t" ) ) ), "SolveOutflow"( % "Copco 1", $ "Copco 1.Inflow" [], "ElevationToStorage"( % "Copco 1", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Copco 1"] ), "PreviousStorage"( % "Copco 1" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

    END;

    RULE                 "Copco 1 Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Copco 1"] := "DailyTargetStorageRelease"( % "Copco 1", "Copco 1", @"t", "PreviousStorage"( % "Copco 1" ), $ "Copco 1.Inflow" [] );

    END;

    RULE                 "Boyle Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "JC Boyle.Regulated Spill" [] := "Max"( 0.00000000 "cms", "Min"( "MaxMinElevationCheck"( % "JC Boyle", "JC Boyle", "Max"( "Max"( 0.00000000 "cms", $ "ReservoirOperations.TargetRelease" [@"t", "Boyle"] + $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"] - $ "JC Boyle.Diversion" [] ) COMMENTED_BY "Target release plus IFR release minus power diversion", "Max"( 0.00000000 "cms", $ "ReservoirOperations.Boyle To Iron Gate Pass Thru" [] - $ "JC Boyle.Diversion" [] ) COMMENTED_BY "Pass Thru Keno IFR minus power diversion and fish release" ) ), "GetMaxOutflowGivenInflow"( % "JC Boyle", $ "JC Boyle.Inflow" [], @"t" ) ) - "Min"( $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"], "GetMaxReleaseGivenInflow"( % "JC Boyle", $ "JC Boyle.Inflow" [], @"t" ) ) COMMENTED_BY "IFR fish bypass" );

      $ "JC Boyle.Release" [] := "Min"( $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"], "GetMaxReleaseGivenInflow"( % "JC Boyle", $ "JC Boyle.Inflow" [], @"t" ) );

    END;

    RULE                 "Boyle Power Diversion";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "JC Boyle.Diversion" [] := $ "ReservoirOperations.TargetPowerRelease" [@"t", "Boyle"];

    END;

    RULE                 "Boyle Target Power Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetPowerRelease" [@"t", "Boyle"] := "Min"( $ "ReservoirData.TurbineCapacities" ["Boyle", "Flow"], "Max"( "Min"( "Max"( "Max"( $ "ReservoirOperations.TargetRelease" [@"t", "Boyle"] + $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"], $ "ReservoirOperations.Boyle To Iron Gate Pass Thru" COMMENTED_BY "Pass Thru Keno IFR" [] ), "SolveOutflow"( % "JC Boyle", $ "JC Boyle.Inflow" [], "ElevationToStorage"( % "JC Boyle", $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Boyle"] ), "PreviousStorage"( % "JC Boyle" ), @"t" ) ), "SolveOutflow"( % "JC Boyle", $ "JC Boyle.Inflow" [], "ElevationToStorage"( % "JC Boyle", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"] ), "PreviousStorage"( % "JC Boyle" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions" ) - $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"], 0.00000000 "cms" ) );

    END;

    RULE                 "Boyle Iron Gate Pass Thru IFR Release";
    DESCRIPTION          "Releases water intended for Pass Thru IGD IFR requirement.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Boyle To Iron Gate Pass Thru" [] := "Max"( "Min"( "Max"( ( $ "ReservoirOperations.IGD ENV Release" COMMENTED_BY "IGD IFR minus downstream gains" [] - ( $ "Boyle Bypass Reach.Local Inflow" [] + $ "Boyle Gage to Copco Gain.Local Inflow" [] + $ "Copco to Iron Gate Gain.Local Inflow" [] ) ) COMMENTED_BY "IGD IFR minus downstream gains", $ "ReservoirOperations.IFRRelease" COMMENTED_BY "Boyle IFR minus downstream gains" [@"t", "Boyle"] - ( $ "Boyle Bypass Reach.Local Inflow" [] + $ "Boyle Gage to Copco Gain.Local Inflow" [] ) ), "SolveOutflow"( % "JC Boyle", $ "JC Boyle.Inflow" [], "ElevationToStorage"( % "JC Boyle", 0.50000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Boyle"] + $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"] ) ), "PreviousStorage"( % "JC Boyle" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions" ), 0.00000000 "cms" );

    END;

    RULE                 "Boyle IFR Release";
    DESCRIPTION          "Compute local IFR (fish bypass) (as opposed to Pass Thru IFR at Keno that is needed for Iron Gate Pass Thru IFR.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Boyle"] := "Max"( "Min"( "Min"( $ "JC Boyle.Inflow" [], "Min"( $ "ReservoirData.MinRelease" [@"t", "JC Boyle"] - "Min"( $ "Boyle Bypass Reach.Local Inflow" [], 0.00000000 "cms" ), "GetMaxOutflowGivenInflow"( % "JC Boyle", $ "JC Boyle.Inflow" [], @"t" ) ) ), "SolveOutflow"( % "JC Boyle", $ "JC Boyle.Inflow" [], "ElevationToStorage"( % "JC Boyle", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Boyle"] ), "PreviousStorage"( % "JC Boyle" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

    END;

    RULE                 "Boyle Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Boyle"] := "DailyTargetStorageRelease"( % "JC Boyle", "JC Boyle", @"t", "PreviousStorage"( % "JC Boyle" ), $ "JC Boyle.Inflow" [] );

    END;

    RULE                 "Power Reservoirs Target Elevation Releases";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Boyle"] := "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "JC Boyle", "JC Boyle", $ "Keno To Iron Gate Routing.Outflow", @"t", "DateMin"( @"t + 2", "RunEndDate"(  ) ) ), @"t", "DateMin"( @"t + 2", "RunEndDate"(  ) ) );

      $ "ReservoirOperations.TargetRelease" [@"t", "Copco 1"] := "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "Copco 1", "Copco 1", $ "Keno To Iron Gate Routing.Outflow", @"t", "DateMin"( @"t + 6", "RunEndDate"(  ) ) ), @"t", "DateMin"( @"t + 6", "RunEndDate"(  ) ) );

      $ "ReservoirOperations.TargetRelease" [@"t", "Iron Gate"] := "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "IGD", "IGD", $ "Keno To Iron Gate Routing.Outflow", @"t", "DateMin"( @"t + 6", "RunEndDate"(  ) ) ), @"t", "DateMin"( @"t + 6", "RunEndDate"(  ) ) );

    END;

    RULE                 "Power Reservoirs Target Elevations";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetElevation" [@"t", "JC Boyle"] := IF ( "SumFlowsToVolumeSkipNaN"( $ "UKL To Keno Routing.Outflow", "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 2", "RunEndDate"(  ) ) ) - "SumFlowValueToVolume"( "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 2", "RunEndDate"(  ) ), $ "ReservoirData.TurbineCapacities" ["Boyle", "Flow"] ) > "Max"( 0.00000000 "m3", "PreviousStorage"( % "JC Boyle" ) - "ElevationToStorage"( % "JC Boyle", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"] ) ) )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"]
 ELSE
  $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Boyle"]
 ENDIF;

      $ "ReservoirOperations.TargetElevation" [@"t", "Copco 1"] := IF ( "SumFlowsToVolumeSkipNaN"( $ "UKL To Keno Routing.Outflow", "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 6", "RunEndDate"(  ) ) ) - "SumFlowValueToVolume"( "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 6", "RunEndDate"(  ) ), $ "ReservoirData.TurbineCapacities" ["Copco 1", "Flow"] ) > "Max"( 0.00000000 "m3", "PreviousStorage"( % "Copco 1" ) - "ElevationToStorage"( % "Copco 1", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"] ) ) )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"]
 ELSE
  $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Copco 1"]
 ENDIF;

      $ "ReservoirOperations.TargetElevation" [@"t", "IGD"] := IF ( "SumFlowsToVolumeSkipNaN"( $ "Keno To Iron Gate Routing.Outflow", "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 6", "RunEndDate"(  ) ) ) - "SumFlowValueToVolume"( "DateMax"( @"t", "RunStartDate"(  ) ), "DateMin"( @"t + 6", "RunEndDate"(  ) ), $ "ReservoirData.TurbineCapacities" ["Iron Gate", "Flow"] ) > "Max"( 0.00000000 "m3", "PreviousStorage"( % "IGD" ) - "ElevationToStorage"( % "IGD", $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) ) )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"]
 ELSE
  $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"]
 ENDIF;

    END;

    RULE                 "Power Reservoirs Target Elevations No Forecast";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetElevation" [@"t", "JC Boyle"] := IF ( $ "JC Boyle.Pool Elevation" [@"t - 1"] > $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Boyle"] OR $ "IGD.Unregulated Spill" [@"t - 1"] > 0.00000000 "cms" )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"]
 ELSE
  IF ( $ "UKL.Spill" [@"t"] > 0.00000000 "cms" )
  THEN
   $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Boyle"]
  ELSE
   $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Boyle"]
  ENDIF
 ENDIF;

      $ "ReservoirOperations.TargetElevation" [@"t", "Copco 1"] := IF ( $ "Copco 1.Pool Elevation" [@"t - 1"] > $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Copco 1"] OR $ "IGD.Unregulated Spill" [@"t - 1"] > 0.00000000 "cms" )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"]
 ELSE
  IF ( $ "UKL.Spill" [@"t"] > 0.00000000 "cms" )
  THEN
   $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Copco 1"]
  ELSE
   $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Copco 1"]
  ENDIF
 ENDIF;

      $ "ReservoirOperations.TargetElevation" [@"t", "IGD"] := IF ( $ "IGD.Pool Elevation" [@"t - 1"] > $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] OR $ "IGD.Unregulated Spill" [@"t - 1"] > 0.00000000 "cms" OR $ "IGD.Unregulated Spill" [@"t - 2"] > 0.00000000 "cms" )
 THEN
  $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"]
 ELSE
  IF ( $ "UKL.Spill" [@"t"] > 0.00000000 "cms" )
  THEN
   $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"]
  ELSE
   $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"]
  ENDIF
 ENDIF;

    END;

    RULE                 "Set Keno Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Keno.Outflow" [] := "MaxMinElevationCheck"( % "Keno", "Keno Reservoir", "MaxItem"( { $ "ReservoirOperations.TargetRelease" [@"t", "Keno"] , $ "ReservoirOperations.Keno To IGD Pass Thru" [] , $ "ReservoirOperations.IFRRelease" [@"t", "Keno"] } ) );

    END;

    RULE                 "Keno Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Keno"] := "DailyTargetStorageRelease"( % "Keno", "Keno Reservoir", @"t", "PreviousStorage"( % "Keno" ), $ "Keno.Inflow" [] );

    END;

    RULE                 "Keno Iron Gate Pass Thru IFR Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.Keno To IGD Pass Thru" [] := "Max"( "Min"( "Max"( ( $ "ReservoirOperations.IGD ENV Release" COMMENTED_BY "IGD IFR minus downstream gains" [] - $ "Keno To Iron Gate Gain.Local Inflow" [] ), $ "ReservoirOperations.IFRRelease" [@"t", "Keno"] COMMENTED_BY "Keno IFR minus downstream gains" - $ "Keno to Boyle Gain.Local Inflow" [] ), "SolveOutflow"( % "Keno", $ "Keno.Inflow" [], "ElevationToStorage"( % "Keno", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Keno"] ), "PreviousStorage"( % "Keno" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions" ), 0.00000000 "cms" );

    END;

    RULE                 "Keno Instream Flow Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Keno"] := "Max"( "Min"( "Min"( $ "Keno.Inflow" [], "Min"( $ "ReservoirData.MinRelease" [@"t", "Keno Reservoir"], "GetMaxReleaseGivenInflow"( % "Keno", $ "Keno.Inflow" [], @"t" ) ) ), "SolveOutflow"( % "Keno", $ "Keno.Inflow" [], "ElevationToStorage"( % "Keno", $ "ReservoirData.ReservoirAllocations" ["Inactive", "Keno"] ), "PreviousStorage"( % "Keno" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

    END;

  END;

  POLICY_GROUP   "OLD Klamath Project Operations";
  DESCRIPTION    "";
  ACTIVE         FALSE;
  NOTES          "";
  BEGIN

    RULE                 "Compute Lagged Refuge Returns";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "LaggedRefugePermanentWetlandsReturns.Inflow" [] := 0.00000000 "cms";

      $ "LaggedRefugePermanentWetlandsReturns.Inflow" [] := $ "RefugeData.AccumulatedSupplies" [@"t", "Permanent Wetlands"] * ( $ "RefugeData.KBPMRefugeReturnFractions" [@"t", "Permanent Wetlands"] / "GetDaysInMonth"( @"t" ) );

      $ "LaggedRefugeSeasonalWetlandsReturns.Return Flow" [] := $ "RefugeData.AccumulatedSupplies" [@"t", "Seasonal Wetlands"] * ( $ "RefugeData.KBPMRefugeReturnFractions" [@"t", "Seasonal Wetlands"] / "GetDaysInMonth"( @"t" ) );

      $ "LaggedRefugeOpenWaterReturns.Return Flow" [] := $ "RefugeData.AccumulatedSupplies" [@"t", "Open Water"] * ( $ "RefugeData.KBPMRefugeReturnFractions" [@"t", "Open Water"] / "GetDaysInMonth"( @"t" ) );

      $ "LaggedRefugeCropReturns.Return Flow" [] := $ "RefugeData.AccumulatedSupplies" [@"t", "Crops"] * ( $ "RefugeData.KBPMRefugeReturnFractions" [@"t", "Crops"] / "GetDaysInMonth"( @"t" ) );

    END;

    RULE                 "Accumulate Refuge Supplies";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "RefugeData.AccumulatedSupplies" [@"t", "Permanent Wetlands"] := IF ( @"t" == @"Start Timestep" )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( @"t" == "NumberToDate"( $ "RefugeData.DeliveryFactors" ["Permanent Wetlands", "Supply Rollover Date"] ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "RefugeData.AccumulatedSupplies" [@"t - 1", "Permanent Wetlands"] + "FlowToVolume"( $ "Refuge:Permanent Wetlands.Diversion" [], @"t" )
  ENDIF
 ENDIF;

      $ "RefugeData.AccumulatedSupplies" [@"t", "Seasonal Wetlands"] := IF ( @"t" == @"Start Timestep" )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( @"t" == "NumberToDate"( $ "RefugeData.DeliveryFactors" ["Seasonal Wetlands", "Supply Rollover Date"] ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "RefugeData.AccumulatedSupplies" [@"t - 1", "Seasonal Wetlands"] + "FlowToVolume"( $ "Refuge:Seasonal Wetlands.Diversion" [], @"t" )
  ENDIF
 ENDIF;

      $ "RefugeData.AccumulatedSupplies" [@"t", "Open Water"] := IF ( @"t" == @"Start Timestep" )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( @"t" == "NumberToDate"( $ "RefugeData.DeliveryFactors" ["Open Water", "Supply Rollover Date"] ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "RefugeData.AccumulatedSupplies" [@"t - 1", "Open Water"] + "FlowToVolume"( $ "Refuge:Open Water.Diversion" [], @"t" )
  ENDIF
 ENDIF;

      $ "RefugeData.AccumulatedSupplies" [@"t", "Crops"] := IF ( @"t" == @"Start Timestep" )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( @"t" == "NumberToDate"( $ "RefugeData.DeliveryFactors" ["Crops", "Supply Rollover Date"] ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "RefugeData.AccumulatedSupplies" [@"t - 1", "Crops"] + "FlowToVolume"( $ "Refuge:Crops.Diversion" [], @"t" )
  ENDIF
 ENDIF;

    END;

    RULE                 "Accumulate Area 2 Diversion Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.AccumulatedArea2Supply" [] := IF ( @"t" == @"24:00:00 October 1, Current Year" )
 THEN
  "FlowToVolume"( $ "ProjectData.IrrigationSupplies" [@"t", "Area2"], @"t" )
 ELSE
  $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"] + "FlowToVolume"( $ "ProjectData.IrrigationSupplies" [@"t", "Area2"], @"t" )
 ENDIF;

    END;

    RULE                 "Set Available to Area2";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Area2 Supply.Outflow" [] := "Min"( $ "Area2.Diversion Requested" [], "Max"( "VolumeToFlow"( "PreviousStorage"( % "Area2 Supply" ) - "ElevationToStorage"( % "Area2 Supply", $ "InitialConditions.Area 2 Supply" [] ), @"t" ) + $ "North Canal.Diversion" [] + $ "Ady Canal.Diversion" [] - $ "Refuge.Total Available Water" [], 0.00000000 "cms" ) );

    END;

    RULE                 "Reconcile Total Supplies";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "KDDWaterRight"] := $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"];

      $ "ProjectData.KDDWaterRightSupply" [] := $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"];

      $ "ProjectData.IrrigationSupplies" [@"t", "Area1"] := $ "Klamath River To Area1.Diversion" [] + $ "A Canal.Diversion" [] + $ "Lost River To Area1.Diversion" [];

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1"] := $ "Klamath River To Area1.Diversion" [] + $ "A Canal.Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"];

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectViaUKL"] := $ "A Canal.Available For Diversion" [] + $ "Klamath River To Area1.Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"];

      $ "ProjectData.LostToArea2SpringSummer" [] := $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"];

      $ "ProjectData.IrrigationSupplies" [@"t", "Project"] := $ "A Canal.Available For Diversion" [] + $ "Klamath River To Area1.Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"] + ( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] );

      $ "ProjectData.IrrigationSupplies" [@"t", "IrrigationTotal"] := $ "A Canal.Available For Diversion" [] + $ "Klamath River To Area1.Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + ( $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] ) + ( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectIrrigation"] := $ "A Canal.Available For Diversion" [] + $ "Klamath River To Area1.Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"];

    END;

    RULE                 "Reconcile Supplies";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "NorthCanal"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "NorthCanal"] COMMENTED_BY "Initial North Supply" - $ "North Canal.Diversion Shortage" [] COMMENTED_BY "North Shortage", 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "AdyCanal"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "AdyCanal"] COMMENTED_BY "Initial Ady Supply" - $ "Ady Canal.Diversion Shortage" [] COMMENTED_BY "Ady Shortage", 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] COMMENTED_BY "Initial Supply" - $ "North Canal.Diversion Shortage" [] COMMENTED_BY "Shortage", 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] COMMENTED_BY "Initial Supply" - $ "Ady Canal.Diversion Shortage" [] COMMENTED_BY "Shortage", 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "Area2"] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"], 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] COMMENTED_BY "Initial Supply" - $ "North Canal.Diversion Shortage" [] COMMENTED_BY "Shortage", 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] COMMENTED_BY "Initial Supply" - $ "Klamath River To Area1.Diversion Shortage" [] COMMENTED_BY "Shortage", 0.00000000 "cms" );

    END;

    RULE                 "Set Available To Refuge";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC RefugeShortage = "Min"( $ "ProjectData.IrrigationSupplies" [@"t", "Refuge"], $ "Ady Canal.Diversion Shortage" [] )) DO
            $ "ProjectData.RefugeSupplyShortage" [] := RefugeShortage;

            $ "Refuge.Total Available Water" [] := "MinItem"( { $ "Refuge.Total Diversion Requested" [] , $ "ProjectData.IrrigationSupplies" [@"t", "Refuge"] - RefugeShortage , "VolumeToFlow"( "PreviousStorage"( % "Area2 Supply" ), @"t" ) } );

            $ "ProjectData.IrrigationSupplies" [@"t", "Refuge"] := $ "ProjectData.IrrigationSupplies" [@"t", "Refuge"] - RefugeShortage;

            $ "ProjectData.AdyToArea2SupplyShortage" [] := $ "Ady Canal.Diversion Shortage" [] - RefugeShortage;

            $ "ProjectData.IrrigationSupplies" [@"t", "Area2"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "Area2"] COMMENTED_BY "Initial Area 2 Supply" - ( $ "North Canal.Diversion Shortage" [] + ( $ "Ady Canal.Diversion Shortage" [] - RefugeShortage COMMENTED_BY "Refuge Shortage" ) ) COMMENTED_BY "Area 2 Shortage", 0.00000000 "cms" );

            $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] COMMENTED_BY "Initial Supply" - $ "North Canal.Diversion Shortage" [] COMMENTED_BY "Shortage", 0.00000000 "cms" );

            $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] := "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] COMMENTED_BY "Initial Supply" - ( $ "Ady Canal.Diversion Shortage" [] - RefugeShortage COMMENTED_BY "Refuge Shortage" ) COMMENTED_BY "Shortage", 0.00000000 "cms" );

      END_WITH_STATEMENT;

    END;

    RULE                 "Set Available to Ady Canal";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Ady Canal.Available For Diversion" [] := "MinItem"( { $ "ProjectData.IrrigationSupplies" [@"t", "AdyCanal"] , "Max"( $ "Diversion To Ady.Inflow" [] - "Max"( $ "ReservoirOperations.UKL To IGD Total IFR Pass Thru" [], $ "ReservoirOperations.UKL To Keno IFR Pass Thru" [] ), 0.00000000 "cms" ) , $ "Ady Canal.Max Diversion" [0.00000000, 0.00000000] } );

      $ "Ady Canal.Diversion Request" [] := $ "ProjectData.IrrigationSupplies" [@"t", "AdyCanal"];

    END;

    RULE                 "Set Available to North Canal";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "North Canal.Available For Diversion" [] := "MinItem"( { $ "ProjectData.IrrigationSupplies" [@"t", "NorthCanal"] , "Max"( $ "Diversion To North.Inflow" [] - "Max"( $ "ReservoirOperations.UKL To IGD Total IFR Pass Thru" [], $ "ReservoirOperations.UKL To Keno IFR Pass Thru" [] ), 0.00000000 "cms" ) , $ "North Canal.Max Diversion" [0.00000000, 0.00000000] } );

      $ "North Canal.Diversion Request" [] := $ "ProjectData.IrrigationSupplies" [@"t", "NorthCanal"];

    END;

    RULE                 "Set Available to Area 1 via Klamath River";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Klamath River To Area1.Available For Diversion" [] := "MinItem"( { $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] , "Max"( $ "Diversion to Miller.Inflow" [] - "Max"( $ "ReservoirOperations.UKL To IGD Total IFR Pass Thru" [], $ "ReservoirOperations.UKL To Keno IFR Pass Thru" [] ), 0.00000000 "cms" ) , $ "Klamath River To Area1.Max Diversion" [0.00000000, 0.00000000] } );

      $ "Klamath River To Area1.Diversion Request" [] := $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"];

    END;

    RULE                 "Route UKL To Iron Gate Pass Thru Water";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "UKL To Keno Gain.Inflow" [] := $ "ReservoirOperations.UKL To IGD Total IFR Pass Thru" [];

      $ "UKL To Keno Gain.Local Inflow" [] := $ "Lost River To Klamath River.Inflow2" [] + $ "Lake Ewuana Gain.Local Inflow" [] - $ "ProjectData.LostToArea2SpringSummer" [];

    END;

    RULE                 "Compute EWA Used";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.EWAUsed" [] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( @"t" == @"24:00:00 March 1, Current Year" )
  THEN
   "FlowToVolume"( $ "ReservoirOperations.UKL Environmental Release" [], @"t" ) + "FlowToVolume"( $ "ReservoirOperations.UKL Incremental Excess Water" COMMENTED_BY "C1_EXC" [], @"t" )
  ELSE
   $ "ProjectData.EWAUsed" [@"t - 1"] + "FlowToVolume"( $ "ReservoirOperations.UKL Environmental Release" [], @"t" ) + "FlowToVolume"( $ "ReservoirOperations.UKL Incremental Excess Water" COMMENTED_BY "C1_EXC" [], @"t" ) - "FlowToVolume"( $ "ProjectData.ProjectReleaseForIronGateMin" [], @"t" )
  ENDIF
 ENDIF;

    END;

    RULE                 "Set UKL Incremental Excess Water";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Incremental Excess Water" [] := "Max"( 0.00000000 "cms", $ "UKL.Outflow" [@"t"] - $ "ReservoirOperations.UKL Environmental Release" [@"t"] - $ "ReservoirOperations.UKL Demand Release" [@"t"] );

    END;

    RULE                 "Set UKL Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "UKL.Outflow" [] := "MinItem"( { $ "ReservoirData.MaxRelease" [@"t", "UKL"] , "MaxMinElevationCheck"( % "UKL", "UKL", $ "ReservoirOperations.UKL Tentative Release" [] ) , "GetMaxOutflowGivenInflow"( % "UKL", $ "UKL.Inflow" [], @"t" ) } );

    END;

    RULE                 "UKL Tenative Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Tentative Release" [] := "MaxItem"( { $ "ReservoirOperations.UKL Excess Water Release" [] , ( $ "ReservoirOperations.UKL Demand Release" [] + $ "ReservoirOperations.UKL Environmental Release" [] ) , $ "ReservoirOperations.IFRRelease" [@"t", "Upper Klamath"] } );

    END;

    RULE                 "UKL Demand Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Demand Release" [] := ( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"] + $ "ProjectData.KDDWaterRightSupply" [] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] ) COMMENTED_BY "Committed deliveries" - "Min"( $ "Lake Ewuana Gain.Local Inflow" [@"t - 1"], 0.00000000 "cms" ) COMMENTED_BY "Protect demands from negative gains";

    END;

    RULE                 "Set Total Supplies";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "NorthCanal"] := $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"];

      $ "ProjectData.IrrigationSupplies" [@"t", "AdyCanal"] := $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"];

      $ "ProjectData.IrrigationSupplies" [@"t", "Refuge"] := $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"];

      $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] := "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" );

      $ "ProjectData.IrrigationSupplies" [@"t", "ACanal"] := $ "A Canal.Available For Diversion" [];

      $ "ProjectData.LostToArea2SpringSummer" [] := $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"];

      $ "ProjectData.IrrigationSupplies" [@"t", "Area1ViaUKL"] := $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + $ "A Canal.Diversion" [];

      $ "ProjectData.IrrigationSupplies" [@"t", "Drain2ToArea1"] := "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] );

      $ "ProjectData.IrrigationSupplies" [@"t", "Area1"] := $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + $ "A Canal.Diversion" [] + $ "Lost River To Area1.Diversion" [];

      $ "ProjectData.IrrigationSupplies" [@"t", "Area2"] := $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDWaterRight"] + ( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1"] := $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + $ "A Canal.Diversion" [] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectViaLRDC"] := "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" ) + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"];

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectViaUKL"] := $ "A Canal.Available For Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ) + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"];

      $ "ProjectData.IrrigationSupplies" [@"t", "Project"] := $ "A Canal.Available For Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ) + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"] + ( "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" ) COMMENTED_BY "LRDC to Area1" + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] );

      $ "ProjectData.IrrigationSupplies" [@"t", "IrrigationTotal"] := $ "A Canal.Available For Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ) + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDWaterRight"] + ( "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" ) COMMENTED_BY "LRDC to Area1" + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] );

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectIrrigation"] := $ "A Canal.Available For Diversion" [] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ) + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + ( "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" ) COMMENTED_BY "LRDC to Area1" + $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] );

    END;

    RULE                 "Compute Project Refuge Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToRefuge"] := WITH NUMERIC canalCapacity = "Max"( $ "Diversion To Ady.Diversion Capacity" [] - ( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] + $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] ), 0.00000000 "cms" ) DO
  WITH NUMERIC remainingWaterSupply = "Max"( IF ( "NovemberThruFebruary"(  ) )
  THEN
   $ "ProjectData.FallWinterAvailableWater" []
  ELSE
   $ "ProjectData.SpringSummerAvailableWater" []
  ENDIF - ( ( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] + $ "A Canal.Diversion" [] + "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ) ) COMMENTED_BY "Project to Area 1" + $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"] ), 0.00000000 "cms" ) DO
   WITH NUMERIC kbpmSupply = IF ( "MarchThruJuly"(  ) AND NOT "ProjectIsFull"(  ) )
   THEN
    0.00000000 "cms"
   ELSE
    IF ( "AugustThruNovember"(  ) AND NOT "ProjectIsFull"(  ) )
    THEN
     $ "Refuge.Total Diversion Requested" [@"t"] COMMENTED_BY "should be refuge target volume divided by number of days..."
    ELSE
     IF ( "JuneThruNovember"(  ) AND "ProjectIsFull"(  ) AND $ "UKL.Pool Elevation" [@"t - 1"] > $ "KBPMOperationsData.UKL_refuge_upper_thresh" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] )
     THEN
      $ "Refuge.Total Diversion Requested" [@"t"] COMMENTED_BY "should be refuge demand"
     ELSE
      IF ( "AugustThruNovember"(  ) AND "ProjectIsFull"(  ) AND $ "UKL.Pool Elevation" [@"t - 1"] <= $ "KBPMOperationsData.UKL_refuge_upper_thresh" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] )
      THEN
       "Min"( $ "Refuge.Total Diversion Requested" [@"t"], "VolumeToFlow"( "RemainingProjectSupply"( @"t" ) * "AugNovRefugeProportion"( "RemainingProjectSupply"( @"t" ) ) * ( 1.00000000 - "Min"( $ "KBPMOperationsData.UKLAugNovAdjusttThreshold" [], "Max"( $ "KBPMOperationsData.UKL_refuge_adjust_thresh" [@"t"] - $ "UKL.Pool Elevation" [@"t - 1"], 0.00000000 "m" ) ) / $ "KBPMOperationsData.UKLAugNovAdjusttThreshold" [] ), @"t" ) ) COMMENTED_BY "KBPM is refuge target volume divided by number of days"
      ELSE
       IF ( "DecemberThruFebruary"(  ) )
       THEN
        "Min"( $ "Refuge.Total Diversion Requested" [@"t"], $ "ProjectData.FallWinterAvailableWater" [@"t"] * $ "KBPMOperationsData.PercentRefugeSurFW" [] ) COMMENTED_BY "should be min of refuge demand and FWavail*pctRfgsurFW"
       ELSE
        0.00000000 "cms"
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF DO
    "MinItem"( { canalCapacity , remainingWaterSupply , kbpmSupply } )
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    RULE                 "Distribute Project To North and Ady";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC ProjectToNorth = IF ( "OctoberThruFebruary"(  ) )
 THEN
  "Min"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"], $ "Diversion To North.Diversion Capacity" [] )
 ELSE
  "Min"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"], "Max"( $ "Diversion To North.Diversion Capacity" [] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToNorth"], 0.00000000 "cms" ) )
 ENDIF) DO
            $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToNorth"] := ProjectToNorth;

            $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToAdy"] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"] - ProjectToNorth, 0.00000000 "cms" ), "Max"( $ "Diversion To Ady.Diversion Capacity" [] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToAdy"], 0.00000000 "cms" ) )
 ENDIF;

      END_WITH_STATEMENT;

    END;

    RULE                 "Project Supply To Area2";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea2"] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  IF ( "SumFlowsToVolumeSkipNaN"( $ "ProjectData.KDDWaterRightSupply", IF ( "OctoberThruDecember"(  ) )
  THEN
   @"24:00:00 October 1, Current Year"
  ELSE
   @"24:00:00 October 1, Previous Year"
  ENDIF, @"t" ) >= $ "ProjectData.KDDVolumeRight" [] )
  THEN
   "MinItem"( { $ "ProjectData.FallWinterAvailableWater" [] , $ "Diversion To North.Diversion Capacity" [] + $ "Diversion To Ady.Diversion Capacity" [] , $ "ProjectData.DistributedArea2HeadgateDemand" [] } )
  ELSE
   0.00000000 "cms"
  ENDIF
 ELSE
  "MinItem"( { "Max"( $ "ProjectData.SpringSummerAvailableWater" [] - ( $ "A Canal.Available For Diversion" [] + $ "Klamath River To Area1.Available For Diversion" [] ) COMMENTED_BY "Area 1 Project Supply", 0.00000000 "cms" ) , $ "Diversion To North.Diversion Capacity" [] + $ "Diversion To Ady.Diversion Capacity" [] , "Max"( ( $ "ProjectData.DistributedArea2HeadgateDemand" [] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] ), 0.00000000 "cms" ) } )
 ENDIF;

    END;

    RULE                 "Area1 Project Supply From UKL Via Klamath River";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "ProjectToArea1ViaKlamathR"] := IF ( "DecemberThruFebruary"(  ) OR $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] > 0.00000000 "cms" OR $ "Area1:A1SouthOfLRDC.Supplemental Use Request" [] <= 0.00000000 "cms" )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( $ "Klamath River To Area1.Max Diversion" [0.00000000, 0.00000000], WITH NUMERIC remainingArea1Demand = "Max"( $ "Area1.Total Diversion Requested" [] - $ "Lost River To Area1.Diversion" [], 0.00000000 "cms" ) DO
   WITH NUMERIC remainingProjectDemand = remainingArea1Demand + "Max"( $ "ProjectData.DistributedArea2HeadgateDemand" [] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"], 0.00000000 "cms" ) DO
    IF ( remainingProjectDemand == 0.00000000 "cms" )
    THEN
     0.00000000 "cms"
    ELSE
     "Min"( "Max"( remainingArea1Demand / remainingProjectDemand * IF ( "MarchThruSeptember"(  ) )
     THEN
      $ "ProjectData.SpringSummerAvailableWater" []
     ELSE
      $ "ProjectData.FallWinterAvailableWater" []
     ENDIF - $ "A Canal.Diversion" [], 0.00000000 "cms" ), $ "Area1:A1SouthOfLRDC.Supplemental Use Request" [] )
    ENDIF
   ENDWITH
  ENDWITH COMMENTED_BY "Maintain Area 1 portion of project supply used for A Canal allocation." )
 ENDIF;

    END;

    RULE                 "A Canal Project Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "A Canal.Diversion Request" [] := $ "Area1.Total Diversion Requested" [];

      $ "A Canal.Available For Diversion" [] := "Min"( $ "A Canal.Max Diversion" [0.00000000, 0.00000000], WITH NUMERIC remainingArea1Demand = "Max"( $ "Area1.Total Diversion Requested" [] - $ "Lost River To Area1.Diversion" [], 0.00000000 "cms" ) DO
  WITH NUMERIC remainingProjectDemand = IF ( "MarchThruSeptember"(  ) )
  THEN
   remainingArea1Demand + "Max"( $ "ProjectData.DistributedArea2HeadgateDemand" [] - $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"], 0.00000000 "cms" )
  ELSE
   remainingArea1Demand
  ENDIF DO
   IF ( remainingProjectDemand == 0.00000000 "cms" )
   THEN
    0.00000000 "cms"
   ELSE
    "Min"( remainingArea1Demand / remainingProjectDemand * $ "ProjectData.SpringSummerAvailableWater" [], $ "Area1.Total Diversion Requested" [] - $ "Lost River To Area1.Diversion" [] )
   ENDIF
  ENDWITH
 ENDWITH );

      $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea1"] := "Max"( $ "Lost River To Area1.Diversion" [] - "Min"( $ "Lost River Diversion Channel.Return Flow" [], $ "Lost River To Area1.Diversion" [] ), 0.00000000 "cms" );

    END;

    RULE                 "Distribute LRDC To North and Ady";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC LRDCToNorth = IF ( "OctoberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"], $ "Diversion To North.Diversion Capacity" [] )
 ENDIF) DO
            $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToNorth"] := LRDCToNorth;

            $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToAdy"] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( "Max"( $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] - LRDCToNorth, 0.00000000 "cms" ), $ "Diversion To Ady.Diversion Capacity" [] )
 ENDIF;

      END_WITH_STATEMENT;

    END;

    RULE                 "LRDC To Area2";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "LRDCToArea2"] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "MinItem"( { $ "Diversion To Station 48.Outflow" [] , $ "Diversion To North.Diversion Capacity" [] + $ "Diversion To Ady.Diversion Capacity" [] , $ "ProjectData.DistributedArea2HeadgateDemand" [] } )
 ENDIF;

    END;

    RULE                 "Distribute KDD Supply To North and Ady";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.IrrigationSupplies" [@"t", "KDDWaterRight"] := $ "ProjectData.KDDWaterRightSupply" [];

      WITH_STATEMENT (NUMERIC KDDToNorth = IF ( "OctoberThruFebruary"(  ) )
 THEN
  "Min"( $ "ProjectData.KDDWaterRightSupply" [], $ "Diversion To North.Diversion Capacity" [] )
 ELSE
  0.00000000 "cms"
 ENDIF) DO
            $ "ProjectData.IrrigationSupplies" [@"t", "KDDToNorth"] := KDDToNorth;

            $ "ProjectData.IrrigationSupplies" [@"t", "KDDToAdy"] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  "Min"( "Max"( $ "ProjectData.KDDWaterRightSupply" [] - KDDToNorth, 0.00000000 "cms" ), $ "Diversion To Ady.Diversion Capacity" [] )
 ELSE
  0.00000000 "cms"
 ENDIF;

      END_WITH_STATEMENT;

    END;

    RULE                 "Adjust Area 2 Demands After KDD Is Supplied";
    DESCRIPTION          "Reduces Area 2 canal demands after KDD is supplied so that not too much project water is diverted in winter.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.DistributedArea2HeadgateDemand" [] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  IF ( "SumFlowsToVolumeSkipNaN"( $ "ProjectData.KDDWaterRightSupply", IF ( "OctoberThruDecember"(  ) )
  THEN
   @"24:00:00 October 1, Current Year"
  ELSE
   @"24:00:00 October 1, Previous Year"
  ENDIF, @"t" ) >= $ "ProjectData.KDDVolumeRight" [] )
  THEN
   $ "Area2.Diversion Requested" []
  ELSE
   $ "ProjectData.DistributedArea2HeadgateDemand" []
  ENDIF
 ENDIF;

    END;

    RULE                 "KDD Water Right Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.KDDWaterRightSupply" [] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  "MinItem"( { "Max"( $ "UKL.Inflow" [@"t - 1"] - ( ( $ "A Canal.Available For Diversion" [@"t - 1"] + $ "ReservoirOperations.UKL Demand Release" [@"t - 1"] ) COMMENTED_BY "yesterday deliveries" + IF ( @"t" == "RunStartDate"(  ) )
  THEN
   0.00000000 "cms"
  ELSE
   "VolumeToFlow"( $ "UKL.Evaporation" [@"t - 1"] - $ "UKL.Precipitation Volume" [@"t - 1"], @"t - 1" )
  ENDIF COMMENTED_BY "net evaporation" ), 0.00000000 "cms" ) COMMENTED_BY "Using this in lieu of a distributed historical supply" , "Min"( "Max"( $ "ProjectData.KDDFlowLimit" [], $ "Area2.Diversion Requested" [] ) COMMENTED_BY "Max of a reasonable daily limit and ET diversion request to avoid inadvertant shortages.", $ "ProjectData.KDDFlowRight" COMMENTED_BY "Min of actual daily water right" [] ) , "VolumeToFlow"( "Max"( $ "ProjectData.KDDVolumeRight" [] - IF ( @"t" == @"24:00:00 October 1, Current Year" )
  THEN
   0.00000000 "m3"
  ELSE
   "SumFlowsToVolumeSkipNaN"( $ "ProjectData.KDDWaterRightSupply", IF ( "OctoberThruDecember"(  ) )
   THEN
    @"24:00:00 October 1, Current Year"
   ELSE
    @"24:00:00 October 1, Previous Year"
   ENDIF, @"t - 1" )
  ENDIF, 0.00000000 "m3" ), @"t" ) , $ "Diversion To North.Diversion Capacity" [] + $ "Diversion To Ady.Diversion Capacity" [] } )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    RULE                 "KDD Water Right Supply NM1";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.KDDWaterRightSupply" [] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  "MinItem"( { "Max"( $ "UKL.Inflow" [@"t - 1"] - ( 0.50000000 * ( $ "ReservoirOperations.UKL Environmental Release" [] + "MaxItem"( { $ "ProjectData.SpringSummerAvailableWater" [] , $ "ProjectData.FallWinterAvailableWater" [] , IF ( "OctoberThruNovember"(  ) )
  THEN
   "AverageDailyFlowForVolume"( "RemainingProjectSupply"( @"t" ), @"t", "GetDate"( "November 30, Current Year" ) )
  ELSE
   0.00000000 "cms"
  ENDIF } ) ) + IF ( @"t" == "RunStartDate"(  ) )
  THEN
   0.00000000 "cms"
  ELSE
   "VolumeToFlow"( $ "UKL.Evaporation" [@"t - 1"] - $ "UKL.Precipitation Volume" [@"t - 1"], @"t - 1" )
  ENDIF COMMENTED_BY "net evaporation" ), 0.00000000 "cms" ) COMMENTED_BY "Using this in lieu of a distributed historical supply" , "Min"( "Max"( $ "ProjectData.KDDFlowLimit" [], $ "Area2.Diversion Requested" [] ) COMMENTED_BY "Max of a reasonable daily limit and ET diversion request to avoid inadvertant shortages.", $ "ProjectData.KDDFlowRight" COMMENTED_BY "Min of actual daily water right" [] ) , "VolumeToFlow"( "Max"( $ "ProjectData.KDDVolumeRight" [] - IF ( @"t" == @"24:00:00 October 1, Current Year" )
  THEN
   0.00000000 "m3"
  ELSE
   "SumFlowsToVolumeSkipNaN"( $ "ProjectData.KDDWaterRightSupply", IF ( "OctoberThruDecember"(  ) )
   THEN
    @"24:00:00 October 1, Current Year"
   ELSE
    @"24:00:00 October 1, Previous Year"
   ENDIF, @"t - 1" )
  ENDIF, 0.00000000 "m3" ), @"t" ) , $ "Diversion To North.Diversion Capacity" [] + $ "Diversion To Ady.Diversion Capacity" [] } )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    RULE                 "Set Available Fall Winter Water";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.FallWinterAvailableWater" [] := IF ( "OctoberThruFebruary"(  ) )
 THEN
  "MinItem"( { "Max"( $ "UKL.Inflow" [@"t - 1"] - ( $ "ReservoirOperations.UKL Environmental Release" [] + $ "ReservoirOperations.UKLFillingFlow" [] + IF ( @"t" == "RunStartDate"(  ) )
  THEN
   0.00000000 "cms"
  ELSE
   "VolumeToFlow"( $ "UKL.Evaporation" [@"t - 1"] - $ "UKL.Precipitation Volume" [@"t - 1"], @"t - 1" )
  ENDIF COMMENTED_BY "net evaporation" ), 0.00000000 "cms" ) , $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] , "Max"( "SolveOutflow"( % "UKL", $ "UKL.Inflow" [], "ElevationToStorage"( % "UKL", $ "KBPMOperationsData.MinFishElevation" [@"t", "Minimum"] ), "PreviousStorage"( % "UKL" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions.", 0.00000000 "cms" ) } )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    RULE                 "Set UKL Filling Flow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKLFillingFlow" [] := IF ( "OctoberThruDecember"(  ) )
 THEN
  "MaxItem"( { "AverageDailyFlowForVolume"( "ElevationToStorage"( % "UKL", $ "ReservoirOperations.TargetElevation" [@"24:00:00 December 31, Current Year", "UKL"] ) - "PreviousStorage"( % "UKL" ), @"t", @"24:00:00 December 31, Current Year" ) , "AverageDailyFlowForVolume"( "ElevationToStorage"( % "UKL", $ "KBPMOperationsData.UKL_Fill_Target" [] ) - "PreviousStorage"( % "UKL" ), @"t", @"24:00:00 February Max DayOfMonth, Next Year" ) , 0.00000000 "cms" } )
 ELSE
  IF ( "JanuaryThruFebruary"(  ) )
  THEN
   IF ( "EstimatedUKLInflow"( "GetDate"( "March 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) >= $ "KBPMOperationsData.UKLHighForecastThreshold" [] )
   THEN
    0.00000000 "cms"
   ELSE
    "MaxItem"( { "AverageDailyFlowForVolume"( "ElevationToStorage"( % "UKL", $ "ReservoirOperations.TargetElevation" [@"24:00:00 April 30, Current Year", "UKL"] ) - "PreviousStorage"( % "UKL" ), @"t", @"24:00:00 April 30, Current Year" COMMENTED_BY "End date" ) , "AverageDailyFlowForVolume"( "ElevationToStorage"( % "UKL", $ "KBPMOperationsData.UKL_Fill_Target" [] ) - "PreviousStorage"( % "UKL" ), @"t", @"24:00:00 February Max DayOfMonth, Current Year" ) , 0.00000000 "cms" } )
   ENDIF
  ELSE
   0.00000000 "cms"
  ENDIF
 ENDIF;

    END;

    RULE                 " Set Today Spring Summer Available Water";
    DESCRIPTION          "This setup produces too many shortages.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.SpringSummerAvailableWater" [] := IF ( "DecemberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( WITH NUMERIC remainingProjectSupply = "RemainingProjectSupply"( @"t" ) DO
   "Min"( WITH NUMERIC remainingDemand = IF ( "MarchThruSeptember"(  ) )
   THEN
    "SumFlowsToVolume"( $ "Area1.Total Diversion Requested", @"t", "DateMin"( @"24:00:00 November 30, Current Year", "RunEndDate"(  ) ) ) + "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"t", "DateMin"( @"24:00:00 November 30, Current Year", "RunEndDate"(  ) ) )
   ELSE
    "SumFlowsToVolume"( $ "Area1.Total Diversion Requested", @"t", "DateMin"( @"24:00:00 November 30, Current Year", "RunEndDate"(  ) ) )
   ENDIF DO
    WITH NUMERIC todaysDemand = IF ( "MarchThruSeptember"(  ) )
    THEN
     $ "Area1.Total Diversion Requested" [] + $ "Area2.Diversion Requested" []
    ELSE
     $ "Area1.Total Diversion Requested" []
    ENDIF DO
     "Max"( IF ( remainingDemand == 0.00000000 "m3" )
     THEN
      todaysDemand
     ELSE
      remainingProjectSupply / remainingDemand * todaysDemand
     ENDIF, "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "DateMin"( @"24:00:00 November 30, Current Year", "RunEndDate"(  ) ) ) )
    ENDWITH
   ENDWITH, $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] )
  ENDWITH, "Max"( "SolveOutflow"( % "UKL", $ "UKL.Inflow" [], "ElevationToStorage"( % "UKL", $ "KBPMOperationsData.MinFishElevation" [@"t", "Minimum"] ), "PreviousStorage"( % "UKL" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions.", 0.00000000 "cms" ) )
 ENDIF;

    END;

    RULE                 " Set Today Spring Summer Available Water V4";
    DESCRIPTION          "This setup produces too many shortages.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.SpringSummerAvailableWater" [] := IF ( "DecemberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  WITH NUMERIC remainingProjectSupply = "RemainingProjectSupply"( @"t" ) DO
   "Min"( WITH NUMERIC remainingDistPercent = IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
   THEN
    1.00000000
   ELSE
    ( 1.00000000 - "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", "GetDate"( "March 1, Current Year" ), @"t - 1" ) )
   ENDIF DO
    "Max"( IF ( remainingDistPercent == 0.00000000 )
    THEN
     "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" )
    ELSE
     IF ( "OctoberThruNovember"(  ) )
     THEN
      "VolumeToFlow"( remainingProjectSupply / remainingDistPercent * $ "ProjectData.ProjectSupplyDailyDistribution" [], @"t" )
     ELSE
      "VolumeToFlow"( remainingProjectSupply / remainingDistPercent * ( $ "ProjectData.ProjectSupplyDailyDistribution" [] / "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", @"24:00:00 March 1, Current Year", @"24:00:00 September 30, Current Year" ) ), @"t" )
     ENDIF
    ENDIF, "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ) )
   ENDWITH, $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] )
  ENDWITH
 ENDIF;

    END;

    RULE                 " Set Today Spring Summer Available Water V2";
    DESCRIPTION          "This setup produces too many shortages.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.SpringSummerAvailableWater" [] := IF ( "DecemberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  WITH NUMERIC remainingProjectSupply = "RemainingProjectSupply"( @"t" ) DO
   "Min"( WITH NUMERIC remainingDistPercent = IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
   THEN
    1.00000000
   ELSE
    ( 1.00000000 - "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", "GetDate"( "March 1, Current Year" ), @"t - 1" ) )
   ENDIF DO
    "Max"( IF ( remainingDistPercent == 0.00000000 )
    THEN
     "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" )
    ELSE
     "VolumeToFlow"( remainingProjectSupply / remainingDistPercent * $ "ProjectData.ProjectSupplyDailyDistribution" [], @"t" )
    ENDIF, "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ) )
   ENDWITH, $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] )
  ENDWITH
 ENDIF;

    END;

    RULE                 " Set Today Spring Summer Available Water V2";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.SpringSummerAvailableWater" [] := IF ( "DecemberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  WITH NUMERIC remainingProjectSupply = "RemainingProjectSupply"( @"t" ) DO
   "Min"( IF ( "OctoberThruNovember"(  ) )
   THEN
    "Max"( "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ), "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" ) )
   ELSE
    WITH NUMERIC remainingDistPercent = IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
    THEN
     1.00000000
    ELSE
     ( 1.00000000 - "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", "GetDate"( "March 1, Current Year" ), @"t - 1" ) )
    ENDIF DO
     "Max"( IF ( remainingDistPercent == 0.00000000 )
     THEN
      "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" )
     ELSE
      "VolumeToFlow"( remainingProjectSupply / remainingDistPercent * $ "ProjectData.ProjectSupplyDailyDistribution" [], @"t" )
     ENDIF, "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ) )
    ENDWITH
   ENDIF, $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] )
  ENDWITH
 ENDIF;

    END;

    RULE                 " Set Today Spring Summer Available Water V1";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.SpringSummerAvailableWater" [] := IF ( "DecemberThruFebruary"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  WITH NUMERIC remainingProjectSupply = "RemainingProjectSupply"( @"t" ) DO
   "Min"( IF ( "OctoberThruNovember"(  ) )
   THEN
    "Max"( "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ), "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" ) )
   ELSE
    WITH NUMERIC MarchSeptDistribution = "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", @"24:00:00 March 1, Current Year", @"24:00:00 September 30, Current Year" ) DO
     WITH NUMERIC remainingDistPercent = IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
     THEN
      1.00000000
     ELSE
      ( 1.00000000 - "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", "GetDate"( "March 1, Current Year" ), @"t - 1" ) )
     ENDIF DO
      "Max"( IF ( remainingDistPercent == 0.00000000 )
      THEN
       "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [] * remainingProjectSupply, @"t" )
      ELSE
       "VolumeToFlow"( remainingProjectSupply / remainingDistPercent * ( $ "ProjectData.ProjectSupplyDailyDistribution" [] / MarchSeptDistribution ), @"t" )
      ENDIF, "AverageDailyFlowForVolume"( remainingProjectSupply, @"t", "GetDate"( "November 30, Current Year" ) ) )
     ENDWITH
    ENDWITH
   ENDIF, $ "ProjectData.MonthlyDeliveryCapacity" [@"t", "UKL"] )
  ENDWITH
 ENDIF;

    END;

    RULE                 "Accumulate UKL Project Deliveries";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.CumAgSpringSummerDelivery" [] := IF ( @"t" == @"Start Timestep" )
 THEN
  $ "ProjectData.CumAgSpringSummerDelivery" [@"t - 1"]
 ELSE
  IF ( "MarchThruSeptember"(  ) )
  THEN
   IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
   THEN
    0.00000000 "m3"
   ELSE
    $ "ProjectData.CumAgSpringSummerDelivery" [@"t - 1"] + "Max"( "FlowToVolume"( $ "ProjectData.IrrigationSupplies" [@"t - 1", "ProjectViaUKL"] - $ "ProjectData.IrrigationSupplies" [@"t - 1", "ProjectToRefuge"], @"t - 1" ), 0.00000000 "m3" )
   ENDIF
  ELSE
   $ "ProjectData.CumAgSpringSummerDelivery" [@"t - 1"]
  ENDIF
 ENDIF;

      $ "ProjectData.CumAgMarchThruFebruaryDelivery" [] := IF ( @"t" == @"Start Timestep" )
 THEN
  $ "ProjectData.CumAgMarchThruFebruaryDelivery" [@"t - 1"]
 ELSE
  IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "ProjectData.CumAgMarchThruFebruaryDelivery" [@"t - 1"] + "FlowToVolume"( $ "ProjectData.IrrigationSupplies" [@"t - 1", "ProjectViaUKL"], @"t - 1" )
  ENDIF
 ENDIF;

      $ "ProjectData.CumAgMarchThruNovDelivery" [] := IF ( @"t" == @"Start Timestep" )
 THEN
  $ "ProjectData.CumAgMarchThruNovDelivery" [@"t - 1"]
 ELSE
  IF ( "MarchThruNovember"(  ) )
  THEN
   IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
   THEN
    0.00000000 "m3"
   ELSE
    $ "ProjectData.CumAgSpringSummerDelivery" [@"t - 1"] + "FlowToVolume"( $ "ProjectData.IrrigationSupplies" [@"t - 1", "ProjectViaUKL"], @"t - 1" )
   ENDIF
  ELSE
   $ "ProjectData.CumAgSpringSummerDelivery" [@"t - 1"]
  ENDIF
 ENDIF;

    END;

    RULE                 "UKL Cumulative Excess Water Resease Volume";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Cumulative Excess Water Release Volume" [] := IF ( "MarchThruSeptember"(  ) )
 THEN
  IF ( "GetMonth"( @"t" ) == 3.00000000 AND "GetUnitlessDayOfMonth"( @"t" ) == 1.00000000 )
  THEN
   "FlowToVolume"( $ "ReservoirOperations.UKL Excess Water Release" [], @"t" )
  ELSE
   $ "ReservoirOperations.UKL Cumulative Excess Water Release Volume" [@"t - 1"] + "FlowToVolume"( $ "ReservoirOperations.UKL Excess Water Release" [], @"t" ) - "FlowToVolume"( $ "ProjectData.ProjectReleaseForIronGateMin" [], @"t" )
  ENDIF
 ELSE
  0.00000000 "m3"
 ENDIF;

    END;

    RULE                 "UKL Excess Water Release";
    DESCRIPTION          "This variable is intended to represent KBPM's C1_EXC variable.  It is water above release need to meet demands and Iron Gate and Keno instream flow requirements.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Excess Water Release" [] := "Min"( $ "ReservoirData.MaxRelease" [@"t", "UKL"], "Max"( $ "ReservoirData.UKL ExcessRelease Adjustment" [@"t", "UKL"] * $ "ReservoirOperations.TargetRelease" [@"t", "Upper Klamath"] + $ "ReservoirOperations.UKL Demand Release" ["DateMax"( "RunStartDate"(  ), @"t - 1" )] + $ "ReservoirOperations.UKL Environmental Release" [], $ "ReservoirOperations.UKL Flood Control Release" [] ) );

    END;

    RULE                 "UKL Flood Control Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Flood Control Release" [] := IF ( "JanuaryThruApril"(  ) )
 THEN
  WITH NUMERIC coeFloodControl = "DailyFloodControlRelease"( % "UKL", "UKL", "GetDate"( "April 30, Current Year" ), $ "ReservoirData.MaxRelease" [@"t", "UKL"], "EstimatedUKLInflow"( @"t", "GetDate"( "April 30, Current Year" ) ) ) DO
   "MaxItem"( { coeFloodControl , "DailyMaximumStorageRelease"( % "UKL", "UKL", @"t", "PreviousStorage"( % "UKL" ), 0.50000000 * ( $ "UKL.Inflow" [] + $ "UKL.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ) , "DailyFloodControlRelease"( % "UKL", "UKL", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ), $ "ReservoirData.MaxRelease" [@"t", "UKL"], "SumFlowsToVolumeSkipNaN"( $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) ) } )
  ENDWITH
 ELSE
  "Max"( "DailyMaximumStorageRelease"( % "UKL", "UKL", @"t", "PreviousStorage"( % "UKL" ), 0.50000000 * ( $ "UKL.Inflow" [] + $ "UKL.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ), "DailyFloodControlRelease"( % "UKL", "UKL", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ), $ "ReservoirData.MaxRelease" [@"t", "UKL"], "SumFlowsToVolumeSkipNaN"( $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) ) )
 ENDIF;

    END;

    RULE                 "UKL Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Upper Klamath"] := IF ( "DecisionDate"( @"t", $ "ReservoirData.DecisionDates", "Normal" ) OR $ "UKL.Pool Elevation" [@"t - 1"] > 0.50000000 * ( $ "ReservoirOperations.TargetElevation" [@"t", "UKL"] + $ "ReservoirData.MaxElevation" [@"t", "UKL"] ) OR $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"] > 0.00000000 "cms" )
 THEN
  "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "UKL", "UKL", $ "UKLShortTermForecast.Local Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
 ELSE
  $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"]
 ENDIF;

    END;

    RULE                 "UKL Target Release Jan thru April Forecast";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Upper Klamath"] := IF ( "DecisionDate"( @"t", $ "ReservoirData.DecisionDates", "Normal" ) OR $ "UKL.Pool Elevation" [@"t - 1"] > 0.50000000 * ( $ "ReservoirOperations.TargetElevation" [@"t", "UKL"] + $ "ReservoirData.MaxElevation" [@"t", "UKL"] ) OR $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"] > 0.00000000 "cms" )
 THEN
  IF ( "OctoberThruDecember"(  ) )
  THEN
   "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "UKL", "UKL", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
  ELSE
   IF ( "JanuaryThruApril"(  ) )
   THEN
    "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "UKL", "UKL", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
   ELSE
    "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "UKL", "UKL", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "May through September"
   ENDIF
  ENDIF
 ELSE
  $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"]
 ENDIF;

    END;

    RULE                 "UKL Target Release With June thru Sept Forecast";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.TargetRelease" [@"t", "Upper Klamath"] := IF ( "DecisionDate"( @"t", $ "ReservoirData.DecisionDates", "Normal" ) OR $ "UKL.Pool Elevation" [@"t - 1"] > $ "ReservoirOperations.TargetElevation" [@"t", "UKL"] OR $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"] > 0.00000000 "cms" )
 THEN
  IF ( "OctoberThruDecember"(  ) )
  THEN
   "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "UKL", "UKL", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
  ELSE
   IF ( "JanuaryThruApril"(  ) )
   THEN
    "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "UKL", "UKL", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) )
   ELSE
    "AverageDailyFlowForVolume"( "SurplusVolumeBySlot"( % "UKL", "UKL", $ "UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "Error is bulit into UKLShortTermForecast.Local Inflow", "DateMin"( @"t + 1", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "UKLShortTermForecast.Forecast Period" [], "1 days" ), @"Finish Timestep" ) ) COMMENTED_BY "May through September"
   ENDIF
  ENDIF
 ELSE
  $ "ReservoirOperations.TargetRelease" [@"t - 1", "Upper Klamath"]
 ENDIF;

    END;

    RULE                 "Initial UKL Demand Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      IF_STATEMENT (@"t" == "RunStartDate"(  )) THEN
            $ "ReservoirOperations.UKL Demand Release" [] := 1.00000000 "cfs";

      END_IF_STATEMENT;

    END;

    RULE                 "UKL Environmental Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL Environmental Release" [] := "Min"( "MaxItem"( { $ "ReservoirOperations.IFRRelease" [@"t", "Upper Klamath"] , $ "ReservoirOperations.UKL To IGD Total IFR Pass Thru" [] , $ "ReservoirOperations.UKL To Keno IFR Pass Thru" [] } ), "Max"( "SolveOutflow"( % "UKL", $ "UKL.Inflow" [], "ElevationToStorage"( % "UKL", $ "KBPMOperationsData.MinFishElevation" [@"t", "Minimum"] ), "PreviousStorage"( % "UKL" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions.", 0.00000000 "cms" ) );

    END;

    RULE                 "UKL Instream Flow Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IFRRelease" [@"t", "Upper Klamath"] := "Min"( IF ( "OctoberThruFebruary"(  ) )
 THEN
  "Max"( ( $ "Williamson Near Chiloquin.Gage Inflow" [@"t - 1"] * "LinkDamIFRWilliamsonProportion"( $ "Williamson Near Chiloquin.Gage Inflow" [@"t - 1"] ) * "LinkDamIFRAccretionAdjustment"( "UKLToIronGateNetAccretion"( @"t - 1", @"t - 1" ) ) * "FillRateAdjustment"( @"t" ) ) COMMENTED_BY "KBPM's FallWinterRelease" + IF ( "OctoberThruNovember"(  ) )
  THEN
   "AverageDailyFlowForVolume"( ( $ "ProjectData.EWARiver" ["GetDate"( "September 30, Current Year" )] - $ "ProjectData.EWAUsed" ["GetDate"( "September 30, Current Year" )] ), "GetDate"( "October 1, Current Year" ), "GetDate"( "November 30, Current Year" ) )
  ELSE
   0.00000000 "cms"
  ENDIF COMMENTED_BY "KMPM Oct Nov Augmentation Water", $ "ReservoirData.MinRelease" [@"t", "UKL"] )
 ELSE
  $ "ReservoirData.MinRelease" [@"t", "UKL"]
 ENDIF, "Max"( "SolveOutflow"( % "UKL", $ "UKL.Inflow" [], "ElevationToStorage"( % "UKL", $ "ReservoirData.ReservoirAllocations" ["Inactive", "UKL"] COMMENTED_BY "Using minimum fish elevation here caused problems for temperature model." ), "PreviousStorage"( % "UKL" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions.", 0.00000000 "cms" ) );

    END;

    RULE                 "Compute Total UKL To IGD IFR Pass Thru Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL To IGD Total IFR Pass Thru" [] := $ "ReservoirOperations.UKL To IGD IFR Pass Thru" [] + $ "ReservoirOperations.IGD Supplemental Water" [] + $ "ReservoirOperations.JC JC JC Boyle Supplemental Water" [];

    END;

    RULE                 "Compute IGD Supplemental Water Release ZERO";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IGD Supplemental Water" [] := 0.00000000 "cms";

    END;

    RULE                 "JC JC JC Boyle Supplemental Water";
    DESCRIPTION          "Water to compensate Boyle for negative downstream gains case.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.JC JC JC Boyle Supplemental Water" [] := IF ( @"t" > "RunStartDate"(  ) )
 THEN
  "Max"( $ "ReservoirOperations.IFRRelease" [@"t - 1", "Boyle"] - $ "ReservoirData.MinRelease" [@"t - 1", "JC Boyle"], 0.00000000 "cms" )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    RULE                 "Debug";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      PRINT $ "ReservoirData.MaxElevation" [@"t", 0.00000000];

      PRINT IF ( @"t" > "RunStartDate"(  ) )
 THEN
  "Max"( $ "ReservoirOperations.IFRRelease" [@"t - 1", "Boyle"] - $ "ReservoirData.MinRelease" [@"t - 1", "JC Boyle"], 0.00000000 "cms" )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    RULE                 "Compute IGD Supplemental Water Release";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IGD Supplemental Water" [] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "MaxItem"( { ( $ "ReservoirOperations.IGD Constrained Release" [@"t - 1"] - $ "ReservoirOperations.IGD Unconstrained Release" [@"t - 1"] ) , IF ( $ "IGD.Pool Elevation" [@"t - 1"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] <= ( 0.25000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) ) )
  THEN
   "Max"( 0.00000000 "cms", "VolumeToFlow"( "ElevationToStorage"( % "IGD", ( 0.25000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) ) + $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) - $ "IGD.Storage" [@"t - 1"], @"t" ) )
  ELSE
   0.00000000 "cms"
  ENDIF , 0.00000000 "cms" } )
 ENDIF;

    END;

    RULE                 "Compute IGD Supplemental Water Release OUTFLOW_UNCONST";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IGD Supplemental Water" [] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "MaxItem"( { ( $ "ReservoirOperations.IGD Constrained Release" [@"t - 1"] - $ "ReservoirOperations.IGD Unconstrained Release" [@"t - 1"] ) , IF ( $ "IGD.Pool Elevation" [@"t - 1"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] <= ( 0.25000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) ) )
  THEN
   "Max"( ( $ "ReservoirOperations.IGD Unconstrained Release" [@"t - 1"] - $ "IGD.Outflow" [@"t - 1"] ), "VolumeToFlow"( "ElevationToStorage"( % "IGD", ( 0.25000000 * ( $ "ReservoirData.ReservoirAllocations" ["Normal Maximum", "Iron Gate"] - $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) ) + $ "ReservoirData.ReservoirAllocations" ["Normal Minimum", "Iron Gate"] ) - $ "IGD.Storage" [@"t - 1"], @"t" ) )
  ELSE
   0.00000000 "cms"
  ENDIF , 0.00000000 "cms" } )
 ENDIF;

    END;

    RULE                 "Compute IGD Supplemental Water Release With Ramping Only";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IGD Supplemental Water" [] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Max"( ( $ "ReservoirOperations.IGD Constrained Release" [@"t - 1"] - $ "ReservoirOperations.IGD Unconstrained Release" [@"t - 1"] ), 0.00000000 "cms" )
 ENDIF;

    END;

    RULE                 "UKL To IGD IFR Pass Thru Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL To IGD IFR Pass Thru" [] := "Min"( "Max"( $ "ReservoirOperations.IGD ENV Release" COMMENTED_BY "IGD IFR minus downstream gains" [] - $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] + $ "ProjectData.ProjectReleaseForIronGateMin" [@"t - 1"] - "UKLToIronGateNetAccretion"( @"t - 1", @"t - 1" ), 0.00000000 "cms" ), $ "KBPMOperationsData.Max_UKL_To_IG" [] );

    END;

    RULE                 "UKL To Keno IFR Pass Thru Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.UKL To Keno IFR Pass Thru" [] := "Min"( "MaxItem"( { 0.00000000 "cms" , $ "ReservoirData.MinRelease" [@"t", "Keno Reservoir"] - $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] + $ "ProjectData.ProjectReleaseForIronGateMin" [@"t - 1"] - "UKLToKenoNetAccretion"( @"t - 1", @"t - 1" ) , "VolumeToFlow"( "ElevationToStorage"( % "Keno", $ "ReservoirData.ReservoirAllocations" ["Active", "Keno"] ) - "PreviousStorage"( % "Keno" ), @"t" ) } ), $ "KBPMOperationsData.Max_UKL_To_IG" [] );

    END;

    RULE                 "Request Area1 From Lost Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Lost River To Area1.Diversion Request" [] := $ "Area1:A1SouthOfLRDC.Diversion Requested" [];

    END;

    RULE                 "Iron Gate Environmental Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ReservoirOperations.IGD ENV Release" [] := IF ( "MarchThruMay"(  ) )
 THEN
  "Max"( "UKL_FillRateRatioSpring"( @"t" ) * $ "ProjectData.WilliamsonProportionCum" [] * "VolumeToFlow"( $ "ProjectData.EWARiver" [@"t"] - "TableInterpolation"( $ "KBPMOperationsData.EWA_reserve", 0.00000000, 1.00000000, $ "ProjectData.EWARiver" [@"t"], @"t" ) - $ "ProjectData.EWAUsed" [@"t - 1"], @"t" ) + $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] + "UKLToIronGateNetAccretion"( @"t - 1", @"t - 1" ) - $ "ProjectData.ProjectReleaseForIronGateMin" [], $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"] )
 ELSE
  IF ( "GetMonth"( @"t" ) == 6.00000000 )
  THEN
   "Max"( $ "ProjectData.WilliamsonProportionCum" [] * "VolumeToFlow"( $ "ProjectData.EWARiver" [@"t"] - ( $ "KBPMOperationsData.EWAReserveAdjustment" [] * "TableInterpolation"( $ "KBPMOperationsData.EWA_reserve", 0.00000000, 1.00000000, $ "ProjectData.EWARiver" [@"t"], @"t" ) ) - $ "ProjectData.EWAUsed" [@"t - 1"], @"t" ) + $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] + "UKLToIronGateNetAccretion"( @"t - 1", @"t - 1" ) - $ "ProjectData.ProjectReleaseForIronGateMin" [], $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"] )
  ELSE
   IF ( "GetMonth"( @"t" ) == 7.00000000 )
   THEN
    "Max"( "Min"( "TableInterpolation"( $ "KBPMOperationsData.IG_max", 0.00000000, 1.00000000, $ "ProjectData.EWARiver" [@"t"], @"t" ), $ "KBPMOperationsData.EWARemainJulSepFactors" [@"t", "Adjustment"] * $ "ProjectData.EWARemain" [@"t"] / "GetDaysInMonth"( @"t" ) ), $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"] )
   ELSE
    IF ( "GetMonth"( @"t" ) == 8.00000000 )
    THEN
     "Max"( "Min"( "TableInterpolation"( $ "KBPMOperationsData.IG_max", 2.00000000, 3.00000000, $ "ProjectData.EWARiver" [@"t"], @"t" ), $ "KBPMOperationsData.EWARemainJulSepFactors" [@"t", "Adjustment"] * $ "ProjectData.EWARemain" [@"t"] / "GetDaysInMonth"( @"t" ) ), $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"] )
    ELSE
     IF ( "GetMonth"( @"t" ) == 9.00000000 )
     THEN
      "Max"( "Min"( "TableInterpolation"( $ "KBPMOperationsData.IG_max", 4.00000000, 5.00000000, $ "ProjectData.EWARiver" [@"t"], @"t" ), $ "KBPMOperationsData.EWARemainJulSepFactors" [@"t", "Adjustment"] * $ "ProjectData.EWARemain" [@"t"] / "GetDaysInMonth"( @"t" ) ), $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"] )
     ELSE
      $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t", "IronGate2"]
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF;

    END;

    RULE                 "Accumulate Project Release For Iron Gate Minimum";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectCumForIronGateMin" [] := IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
 THEN
  0.00000000 "m3"
 ELSE
  IF ( "AprilThruJune"(  ) AND $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] > 0.00000000 "cms" )
  THEN
   $ "ProjectData.ProjectCumForIronGateMin" [@"t - 1"] + "FlowToVolume"( $ "ProjectData.ProjectReleaseForIronGateMin" [], @"t" )
  ELSE
   $ "ProjectData.ProjectCumForIronGateMin" [@"t - 1"]
  ENDIF
 ENDIF;

    END;

    RULE                 "Compute Project Release For Iron Gate Minimum";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectReleaseForIronGateMin" [] := IF ( "OctoberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( IF ( "FlowIsBetween"( "Max"( $ "ReservoirOperations.IGD ENV Release" [@"t - 1"] + ( $ "IGD.Outflow" [@"t - 1"] - $ "ReservoirOperations.IGD Hatchery Release" [@"t - 1"] - $ "ReservoirOperations.IGD Unconstrained Release" [@"t - 1"] ) COMMENTED_BY "Ramping (by policy or unregulated spilling)", 0.00000000 "cms" ), $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate1"], $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate2"] ) )
  THEN
   "Max"( $ "ReservoirOperations.IGD ENV Release" [@"t - 1"] + ( $ "IGD.Outflow" [@"t - 1"] - $ "ReservoirOperations.IGD Hatchery Release" [@"t - 1"] - $ "ReservoirOperations.IGD Unconstrained Release" [@"t - 1"] ) - $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate1"], 0.00000000 "cms" )
  ELSE
   0.00000000 "cms"
  ENDIF COMMENTED_BY "Env portion of release was between IronGate1 and IronGate2 IFR's", "Min"( "Max"( "VolumeToFlow"( "ElevationToStorage"( % "UKL", $ "ReservoirData.MaxElevation" [@"t - 1", "UKL"] ) - "PreviousStorage"( % "UKL" ), @"t" ), 0.00000000 "cms" ), $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] ) COMMENTED_BY "min of water that was released yesterday beyond what was required to get reservoir below maximum storage (UKL max storage minus UKL actual <br>storage), UKL excess water release)" )
 ENDIF;

    END;

    RULE                 "Compute Project Release For Iron Gate Minimum Pseudo KBPM";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectReleaseForIronGateMin" [] := IF ( "OctoberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( "Max"( ( "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate2"], "Max"( $ "IGD.Outflow" [@"t - 1"] - "IronGatePreviousUnregulated"( @"t - 1" ) - ( $ "ReservoirOperations.IGD Constrained Release" [@"t - 1"] - $ "ReservoirOperations.IGD Unconstrained Release" [@"t - 1"] ), 0.00000000 "cms" ) ) COMMENTED_BY "max of (IG incremental MIF (IGMIF2, lower bound of IG Ramping)" - "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate1"], "Max"( $ "IGD.Outflow" [@"t - 1"] - "IronGatePreviousUnregulated"( @"t - 1" ) - ( $ "ReservoirOperations.IGD Constrained Release" [@"t - 1"] - $ "ReservoirOperations.IGD Unconstrained Release" [@"t - 1"] ), 0.00000000 "cms" ) ) COMMENTED_BY "max of (IG MIF (IGMIF1), lower bound of IG ramping)" ), 0.00000000 "cms" ), "Min"( "Max"( "VolumeToFlow"( "ElevationToStorage"( % "UKL", $ "ReservoirData.TargetElevation" [@"t - 1", "UKL"] ) - "PreviousStorage"( % "UKL" ), @"t" ), 0.00000000 "cms" ), $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] ) COMMENTED_BY "min of water that was released yesterday beyond what was required to get reservoir below maximum storage (UKL max storage minus UKL actual <br>storage), UKL excess water release)" )
 ENDIF;

    END;

    RULE                 "Compute Project Release For Iron Gate Minimum Env Minus Ramping Constraint";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectReleaseForIronGateMin" [] := IF ( "OctoberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( "Max"( ( "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate2"], "Max"( $ "ReservoirOperations.IGD ENV Release" [@"t - 1"] + ( $ "ReservoirOperations.IGD Constrained Release" [@"t - 1"] - $ "ReservoirOperations.IGD Unconstrained Release" [@"t - 1"] ), 0.00000000 "cms" ) ) COMMENTED_BY "max of (IG incremental MIF (IGMIF2, lower bound of IG Ramping)" - "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate1"], "Max"( $ "ReservoirOperations.IGD ENV Release" [@"t - 1"] + ( $ "ReservoirOperations.IGD Constrained Release" [@"t - 1"] - $ "ReservoirOperations.IGD Unconstrained Release" [@"t - 1"] ), 0.00000000 "cms" ) ) COMMENTED_BY "max of (IG MIF (IGMIF1), lower bound of IG ramping)" ), 0.00000000 "cms" ), "Min"( "Max"( "VolumeToFlow"( "ElevationToStorage"( % "UKL", $ "ReservoirData.TargetElevation" [@"t - 1", "UKL"] ) - "PreviousStorage"( % "UKL" ), @"t" ), 0.00000000 "cms" ), $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] ) COMMENTED_BY "min of water that was released yesterday beyond what was required to get reservoir below maximum storage (UKL max storage minus UKL actual <br>storage), UKL excess water release)" )
 ENDIF;

    END;

    RULE                 "Compute Project Release For Iron Gate Minimum Lower Bound Function";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectReleaseForIronGateMin" [] := IF ( "OctoberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "Min"( "Max"( ( "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate2"], "IronGateRampingLowerBound"( @"t - 1" ) ) COMMENTED_BY "max of (IG incremental MIF (IGMIF2, lower bound of IG Ramping)" - "Max"( $ "KBPMOperationsData.LinkIronGateInstreamFlowFRequirements" [@"t - 1", "IronGate1"], "IronGateRampingLowerBound"( @"t - 1" ) ) COMMENTED_BY "max of (IG MIF (IGMIF1), lower bound of IG ramping)" ), 0.00000000 "cms" ), "Min"( "Max"( "VolumeToFlow"( "ElevationToStorage"( % "UKL", $ "ReservoirData.TargetElevation" [@"t - 1", "UKL"] ) - "PreviousStorage"( % "UKL" ), @"t" ), 0.00000000 "cms" ), $ "ReservoirOperations.UKL Incremental Excess Water" [@"t - 1"] ) COMMENTED_BY "min of water that was released yesterday beyond what was required to get reservoir below maximum storage (UKL max storage minus UKL actual <br>storage), UKL excess water release)" )
 ENDIF;

    END;

    RULE                 "Compute Williamson Proportion Accumulation";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.WilliamsonProportionCum" [] := IF ( "MarchThruSeptember"(  ) )
 THEN
  WITH NUMERIC remainingWilliamson = $ "ProjectData.Williamson50Volume" [@"t"] - IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
  THEN
   0.00000000 "m3"
  ELSE
   "SumFlowsToVolumeSkipNaN"( $ "Williamson Near Chiloquin.Gage Outflow", "GetDate"( "March 1, Current Year" ), @"t - 1" )
  ENDIF DO
   WITH NUMERIC yesterdayWilliamson = "FlowToVolume"( $ "Williamson Near Chiloquin.Gage Outflow" [@"t - 1"], @"t - 1" ) DO
    IF ( remainingWilliamson < yesterdayWilliamson )
    THEN
     0.00000000
    ELSE
     IF ( @"t" == "GetDate"( "March 1, Current Year" ) )
     THEN
      yesterdayWilliamson / remainingWilliamson
     ELSE
      "Min"( yesterdayWilliamson / remainingWilliamson, "Max"( 1.00000000 - "SumSlot"( $ "ProjectData.WilliamsonProportionCum", "GetDate"( "March 1, Current Year" ), @"t - 1" ), 0.00000000 ) )
     ENDIF
    ENDIF
   ENDWITH
  ENDWITH
 ELSE
  0.00000000
 ENDIF;

    END;

    RULE                 "Set Area 2 Headgate Demand";
    DESCRIPTION          "Adjust headgate and depletion demands to reflect supply conditions.  Uses water year ratio but apply to next calendar year.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.DistributedArea2HeadgateDemand" [] := "Min"( WITH NUMERIC remainingSoilMoistureSpace = "Max"( "ElevationToStorage"( % "Area2 Supply", $ "InitialConditions.Area 2 Supply" [] ) + $ "ProjectData.Area2 Soil Moisture Limit" [] - "PreviousStorage"( % "Area2 Supply" ), 0.00000000 "m3" ) DO
  IF ( "OctoberThruFebruary"(  ) )
  THEN
   $ "Area2.Diversion Requested" [] + "VolumeToFlow"( remainingSoilMoistureSpace, @"t" )
  ELSE
   WITH NUMERIC supplyToDate = $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"] DO
    WITH NUMERIC demandToDate = "SumFlowsToVolume"( $ "Area2.Diversion", @"24:00:00 October 1, Previous Year", @"t - 1" ) DO
     WITH NUMERIC remainingSupply = supplyToDate - demandToDate DO
      WITH NUMERIC remainingDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"t", @"24:00:00 September 30, Current Year" ) DO
       WITH NUMERIC unsuppliedDemand = "Max"( remainingDemand - remainingSupply, 0.00000000 "m3" ) DO
        IF ( "GetMonth"( @"t" ) == 9.00000000 )
        THEN
         "Min"( $ "Area2.Diversion Requested" [@"t"] / remainingDemand * unsuppliedDemand, "VolumeToFlow"( unsuppliedDemand, @"t" ) )
        ELSE
         "Max"( IF ( remainingDemand != 0.00000000 )
         THEN
          "PeriodAverage"( $ "Area2.Diversion Requested", "OffsetDate"( @"t", - 10.00000000, "1 days" ), "OffsetDate"( @"t", 10.00000000, "1 days" ) ) / remainingDemand * unsuppliedDemand
         ELSE
          0.00000000
         ENDIF, IF ( "GetMonth"( @"t" ) < 7.00000000 )
         THEN
          $ "Area2.Diversion Requested" [] + "VolumeToFlow"( remainingSoilMoistureSpace, @"t" )
         ELSE
          0.00000000 "cms"
         ENDIF )
        ENDIF
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDIF
 ENDWITH, $ "ProjectData.MaximumToArea2" [] );

    END;

    RULE                 "Set Area 2 Headgate Demand No Storage Check After Feb";
    DESCRIPTION          "Adjust headgate and depletion demands to reflect supply conditions.  Uses water year ratio but apply to next calendar year.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.DistributedArea2HeadgateDemand" [] := "Min"( WITH NUMERIC remainingSoilMoistureSpace = "Max"( "ElevationToStorage"( % "Area2 Supply", $ "InitialConditions.Area 2 Supply" [] ) + $ "ProjectData.Area2 Soil Moisture Limit" [] - "PreviousStorage"( % "Area2 Supply" ), 0.00000000 "m3" ) DO
  IF ( "OctoberThruFebruary"(  ) )
  THEN
   $ "Area2.Diversion Requested" [] + "VolumeToFlow"( remainingSoilMoistureSpace, @"t" )
  ELSE
   WITH NUMERIC supplyToDate = $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"] DO
    WITH NUMERIC demandToDate = "SumFlowsToVolume"( $ "Area2.Diversion", @"24:00:00 October 1, Previous Year", @"t - 1" ) DO
     WITH NUMERIC remainingSupply = supplyToDate - demandToDate DO
      WITH NUMERIC remainingDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"t", @"24:00:00 September 30, Current Year" ) DO
       WITH NUMERIC unsuppliedDemand = "Max"( remainingDemand - remainingSupply, 0.00000000 "m3" ) DO
        IF ( "GetMonth"( @"t" ) == 9.00000000 )
        THEN
         "Min"( $ "Area2.Diversion Requested" [@"t"] / remainingDemand * unsuppliedDemand, "VolumeToFlow"( unsuppliedDemand, @"t" ) )
        ELSE
         "PeriodAverage"( $ "Area2.Diversion Requested", "OffsetDate"( @"t", - 10.00000000, "1 days" ), "OffsetDate"( @"t", 10.00000000, "1 days" ) ) / remainingDemand * unsuppliedDemand
        ENDIF
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDIF
 ENDWITH, $ "ProjectData.MaximumToArea2" [] );

    END;

    RULE                 "Distribute Area 2 Headgate Demand On First of Month";
    DESCRIPTION          "Adjust headgate and depletion demands to reflect supply conditions.  Uses water year ratio but apply to next calendar year.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "GetMonth"( @"t" ) > 2.00000000 AND "GetMonth"( @"t" ) < 10.00000000 AND "GetDayOfMonth"( @"t" ) == 1.00000000 "day" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC supplyToDate = $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"]) DO
            WITH_STATEMENT (NUMERIC demandToDate = "SumFlowsToVolume"( $ "Area2.Diversion", @"24:00:00 October 1, Previous Year", @"t - 1" )) DO
            WITH_STATEMENT (NUMERIC remainingSupply = supplyToDate - demandToDate) DO
            WITH_STATEMENT (NUMERIC remainingDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"t", @"24:00:00 September 30, Current Year" )) DO
            WITH_STATEMENT (NUMERIC unsuppliedDemand = "Max"( remainingDemand - remainingSupply, 0.00000000 "m3" )) DO
            FOREACH (DATETIME monthlyDate IN "GetDates"( @"t", @"24:00:00 September 30, Current Year", "1 Months" )) DO
            WITH_STATEMENT (NUMERIC monthlyDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", "BeginOfMonthDate"( monthlyDate ), "EndOfMonthDate"( monthlyDate ) )) DO
            IF_STATEMENT ("GetMonth"( @"t" ) == 9.00000000) THEN
            FOREACH (DATETIME date IN "GetDates"( "BeginOfMonthDate"( monthlyDate ), "EndOfMonthDate"( monthlyDate ), "1 days" )) DO
            $ "ProjectData.DistributedArea2HeadgateDemand" [date] := $ "Area2.Diversion Requested" [date] / remainingDemand * unsuppliedDemand;

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( "BeginOfMonthDate"( monthlyDate ), "EndOfMonthDate"( monthlyDate ), "1 days" )) DO
            $ "ProjectData.DistributedArea2HeadgateDemand" [date] := "VolumeToFlow"( monthlyDemand / remainingDemand * unsuppliedDemand / "GetUnitlessDaysInMonth"( date ), date );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Distribute Area 2 Headgate Demand On First of Month From KBPM Supply Distrbution";
    DESCRIPTION          "Adjust headgate and depletion demands to not be more than historic as a function of UKL inflow.  Use water year ratio but apply to next calendar year.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "GetMonth"( @"t" ) > 2.00000000 AND "GetMonth"( @"t" ) < 10.00000000 AND "GetDayOfMonth"( @"t" ) == 1.00000000 "day" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC supplyToDate = $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"]) DO
            WITH_STATEMENT (NUMERIC demandToDate = "SumFlowsToVolume"( $ "Area2.Diversion", @"24:00:00 October 1, Previous Year", @"t - 1" )) DO
            WITH_STATEMENT (NUMERIC remainingSupply = supplyToDate - demandToDate) DO
            WITH_STATEMENT (NUMERIC remainingDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"t", @"24:00:00 September 30, Current Year" )) DO
            WITH_STATEMENT (NUMERIC unsuppliedDemand = "Max"( remainingDemand - remainingSupply, 0.00000000 "m3" )) DO
            WITH_STATEMENT (NUMERIC MarchSeptDistribution = "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", @"t", @"24:00:00 September 30, Current Year" )) DO
            FOREACH (DATETIME date IN "GetDates"( @"t", @"24:00:00 September 30, Current Year", "1 days" )) DO
            $ "ProjectData.DistributedArea2HeadgateDemand" [date] := "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [date] / MarchSeptDistribution * unsuppliedDemand, date );

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Distribute Area 2 Headgate Demand On March 1 KBPM Supply Distribution";
    DESCRIPTION          "Adjust headgate and depletion demands to not be more than historic as a function of UKL inflow.  Use water year ratio but apply to next calendar year.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == "GetDate"( "March 1, Current Year" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC supplyToDate = $ "ProjectData.AccumulatedArea2Supply" [@"t - 1"]) DO
            WITH_STATEMENT (NUMERIC demandToDate = "SumFlowsToVolume"( $ "Area2.Diversion", @"24:00:00 October 1, Previous Year", @"t - 1" )) DO
            WITH_STATEMENT (NUMERIC remainingSupply = supplyToDate - demandToDate) DO
            WITH_STATEMENT (NUMERIC remainingDemand = "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"24:00:00 March 1, Current Year", @"24:00:00 September 30, Current Year" )) DO
            WITH_STATEMENT (NUMERIC unsuppliedDemand = "Max"( remainingDemand - remainingSupply, 0.00000000 "m3" )) DO
            WITH_STATEMENT (NUMERIC MarchSeptDistribution = "SumSlot"( $ "ProjectData.ProjectSupplyDailyDistribution", @"24:00:00 March 1, Current Year", @"24:00:00 September 30, Current Year" )) DO
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 1, Current Year", @"24:00:00 September 30, Current Year", "1 days" )) DO
            $ "ProjectData.DistributedArea2HeadgateDemand" [date] := "VolumeToFlow"( $ "ProjectData.ProjectSupplyDailyDistribution" [date] / MarchSeptDistribution * unsuppliedDemand, date );

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Adjust Demands For Historic Supply On March 1";
    DESCRIPTION          "Adjust headgate and depletion demands to not be more than historic as a function of UKL inflow.  Use water year ratio but apply to next calendar year.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == "GetDate"( "March 1, Current Year" );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC historicSupply = "TableInterpolation"( $ "ProjectData.Historic Ranked Irrigation Supplies", 0.00000000, 1.00000000, $ "ProjectData.March50Volume" [@"t"], @"t" )) DO
            WITH_STATEMENT (NUMERIC etDemand = "SumFlowsToVolume"( $ "Area1.Total Diversion Requested", @"24:00:00 October 1, Previous Year", @"24:00:00 September 30, Current Year" ) + "SumFlowsToVolume"( $ "Area2.Diversion Requested", @"24:00:00 October 1, Previous Year", @"24:00:00 September 30, Current Year" )) DO
            WITH_STATEMENT (NUMERIC adjustmentRatio = IF ( etDemand == 0.00000000 "m3" )
 THEN
  1.00000000
 ELSE
  "Max"( historicSupply / etDemand, 1.00000000 )
 ENDIF) DO
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 1, Current Year", "DateMin"( @"24:00:00 February Max DayOfMonth, Next Year", "RunEndDate"(  ) ), "1 days" )) DO
            $ "Area1:A1NorthOfLRDC.Diversion Requested" [date] := adjustmentRatio * $ "Area1:A1NorthOfLRDC.Diversion Requested" [date];

            $ "Area1:A1NorthOfLRDC.Depletion Requested" [date] := adjustmentRatio * $ "Area1:A1NorthOfLRDC.Depletion Requested" [date];

            $ "Area1:A1SouthOfLRDC.Diversion Requested" [date] := adjustmentRatio * $ "Area1:A1SouthOfLRDC.Diversion Requested" [date];

            $ "Area1:A1SouthOfLRDC.Depletion Requested" [date] := adjustmentRatio * $ "Area1:A1SouthOfLRDC.Depletion Requested" [date];

            $ "Area2.Diversion Requested" [date] := adjustmentRatio * $ "Area2.Diversion Requested" [date];

            $ "Area2.Depletion Requested" [date] := adjustmentRatio * $ "Area2.Depletion Requested" [date];

            $ "Lost River Irrigation Depletions.Diversion Requested" [date] := adjustmentRatio * $ "Lost River Irrigation Depletions.Diversion Requested" [date];

            $ "Lost River Irrigation Depletions.Depletion Requested" [date] := adjustmentRatio * $ "Lost River Irrigation Depletions.Depletion Requested" [date];

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Set Project Supply Distribution on March 1";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == "GetDate"( "March 1, Current Year" );
    NOTES                "";
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( "GetDate"( "March 1, Current Year" ), "DateMin"( @"24:00:00 February Max DayOfMonth, Next Year", @"Finish Timestep" ), "1 days" )) DO
            $ "ProjectData.ProjectSupplyDailyDistribution" [date] := $ "ProjectData.ProjectSupplyMonthlyDistribution" [date, "TableLookup"( $ "ProjectData.SupplyTemporalDistriibutionType", 0.00000000, 1.00000000, $ "ProjectData.March50Volume" [@"t - 1"], @"t - 1", TRUE ) - 1.00000000] / "GetUnitlessDaysInMonth"( date );

      ENDFOREACH;

    END;

    RULE                 "Compute Project Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.ProjectSupply" [] := IF ( "JulyThruFebruary"(  ) )
 THEN
  $ "ProjectData.ProjectSupply" [@"t - 1"]
 ELSE
  IF ( "MarchThruJune"(  ) AND "ProjectIsFull"(  ) )
  THEN
   $ "KBPMOperationsData.ProjectMaximumSupply" []
  ELSE
   IF ( "MarchThruApril"(  ) )
   THEN
    "Min"( "Max"( $ "ProjectData.UKLSupply" [] - $ "ProjectData.EWARiver" [], 0.00000000 "m3" ), $ "KBPMOperationsData.ProjectMaximumSupply" [] )
   ELSE
    IF ( "GetMonth"( @"t" ) == 5.00000000 )
    THEN
     IF ( $ "ProjectData.UKLSupply" [] > $ "ProjectData.UKLSupply" [@"t - 1"] )
     THEN
      "Max"( $ "ProjectData.ProjectSupply" ["GetDate"( "April 30, Current Year" )], "Min"( "Max"( $ "ProjectData.UKLSupply" [] - $ "ProjectData.EWARiver" [], 0.00000000 "m3" ), $ "KBPMOperationsData.ProjectMaximumSupply" [] ) ) COMMENTED_BY "Supply is increasing"
     ELSE
      $ "ProjectData.ProjectSupply" [@"t - 1"]
     ENDIF
    ELSE
     IF ( "GetMonth"( @"t" ) == 6.00000000 )
     THEN
      IF ( $ "ProjectData.UKLSupply" [] > $ "ProjectData.UKLSupply" ["GetDate"( "April 30, Current Year" )] )
      THEN
       "Max"( $ "ProjectData.ProjectSupply" [@"t - 1"], "Min"( "Max"( $ "ProjectData.UKLSupply" [] - $ "ProjectData.EWARiver" [], 0.00000000 "m3" ), $ "KBPMOperationsData.ProjectMaximumSupply" [] ) ) COMMENTED_BY "Supply is increasing"
      ELSE
       "Max"( $ "ProjectData.ProjectSupply" ["GetDate"( "April 30, Current Year" )], "Min"( "Max"( $ "ProjectData.UKLSupply" [] - $ "ProjectData.EWARiver" [], 0.00000000 "m3" ), $ "KBPMOperationsData.ProjectMaximumSupply" [] ) ) COMMENTED_BY "Supply is decreasing"
      ENDIF
     ELSE
      $ "ProjectData.ProjectSupply" [@"t - 1"]
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF;

    END;

    RULE                 "Compute EWA Remain";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ProjectData.EWARemain" [] := IF ( "MarchThruSeptember"(  ) )
 THEN
  IF ( "GetUnitlessDayOfMonth"( @"t" ) == 1.00000000 )
  THEN
   "Max"( "EWARemainingMinimumVolume"(  ), $ "ProjectData.EWARiver" [@"t"] - $ "ProjectData.EWAUsed" [@"t - 1"] )
  ELSE
   $ "ProjectData.EWARemain" [@"t - 1"]
  ENDIF
 ELSE
  0.00000000 "m3"
 ENDIF;

    END;

    RULE                 "Compute EWA River";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.EWARiver" [] := IF ( "MarchThruJune"(  ) AND "GetUnitlessDayOfMonth"( @"t" ) == 1.00000000 )
 THEN
  "Max"( $ "KBPMOperationsData.EWARiverMinimum" [], $ "ProjectData.UKLSupply" [@"t"] * "TableInterpolation"( $ "KBPMOperationsData.EWASupplyPercent", 0.00000000, 1.00000000, $ "ProjectData.UKLSupply" [@"t"], @"t" ) ) COMMENTED_BY "Max (Minimum EWA, UKL Supply times EWA portion of UKL Supply)"
 ELSE
  IF ( "OctoberThruFebruary"(  ) )
  THEN
   0.00000000 "m3"
  ELSE
   $ "ProjectData.EWARiver" [@"t - 1"]
  ENDIF
 ENDIF;

    END;

    RULE                 "Compute UKL Supply";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.UKLSupply" [] := IF ( "GetUnitlessDayOfMonth"( @"t" ) == 1.00000000 AND "GetMonth"( @"t" ) >= 3.00000000 AND "GetMonth"( @"t" ) <= 6.00000000 )
 THEN
  ( $ "ProjectData.March50Volume" [@"t"] + "Max"( $ "UKL.Storage" [@"24:00:00 February Max DayOfMonth, Current Year"] - "ElevationToStorage"( % "UKL", "TableInterpolation"( $ "KBPMOperationsData.UKL_EOS_target_level", 0.00000000, 1.00000000, $ "ProjectData.March50Volume" [@"t"], @"t" ) ), 0.00000000 "m3" ) ) COMMENTED_BY "Forecasted March thru September Inflow + (End of February UKL Storage - End of September Target Storage)"
 ELSE
  $ "ProjectData.UKLSupply" [@"t - 1"]
 ENDIF;

    END;

    RULE                 "Compute March 50 Volume";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.March50Volume" [] := IF ( "MarchThruSeptember"(  ) AND "GetUnitlessDayOfMonth"( @"t" ) == 1.00000000 )
 THEN
  IF ( "GetMonth"( @"t" ) == 3.00000000 )
  THEN
   "EstimatedUKLInflow"( "GetDate"( "March 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) COMMENTED_BY "March thru September Forecasted Inflow"
  ELSE
   IF ( "GetMonth"( @"t" ) == 4.00000000 )
   THEN
    ( "EstimatedUKLInflow"( "GetDate"( "April 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + ( "SumFlowsToVolumeSkipNaN"( $ "UKL.Inflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "March 31, Current Year" ) ) - "SumSlot"( $ "UKL.Evaporation", "GetDate"( "March 1, Current Year" ), "GetDate"( "March 31, Current Year" ) ) ) ) COMMENTED_BY "April thru September Forecasted Inflow Plus March Actual Inflow"
   ELSE
    IF ( "GetMonth"( @"t" ) == 5.00000000 )
    THEN
     ( "EstimatedUKLInflow"( "GetDate"( "May 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + ( "SumFlowsToVolumeSkipNaN"( $ "UKL.Inflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "April 30, Current Year" ) ) - "SumSlot"( $ "UKL.Evaporation", "GetDate"( "March 1, Current Year" ), "GetDate"( "April 30, Current Year" ) ) ) ) COMMENTED_BY "May thru September Forecasted Inflow Plus March thru April Actual Inflow"
    ELSE
     IF ( ( "GetMonth"( @"t" ) == 6.00000000 ) COMMENTED_BY "June thru September Forecasted Inflow Plus March thru May Actual Inflow" )
     THEN
      "EstimatedUKLInflow"( "GetDate"( "June 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + ( "SumFlowsToVolumeSkipNaN"( $ "UKL.Inflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "May 31, Current Year" ) ) - "SumSlot"( $ "UKL.Evaporation", "GetDate"( "March 1, Current Year" ), "GetDate"( "May 31, Current Year" ) ) )
     ELSE
      $ "ProjectData.March50Volume" [@"t - 1"]
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ELSE
  $ "ProjectData.March50Volume" [@"t - 1"]
 ENDIF;

    END;

    RULE                 "Compute Williamson 50 Volume";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "ProjectData.Williamson50Volume" [] := IF ( "MarchThruSeptember"(  ) )
 THEN
  IF ( "GetMonth"( @"t" ) == 3.00000000 )
  THEN
   "Max"( "EstimatedWilliamsonForecast"( "GetDate"( "March 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ), $ "KBPMOperationsData.Will50Maximum" [] ) COMMENTED_BY "March thru September Forecasted Inflow"
  ELSE
   IF ( "GetMonth"( @"t" ) == 4.00000000 )
   THEN
    ( "EstimatedWilliamsonForecast"( "GetDate"( "April 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + "SumFlowsToVolumeSkipNaN"( $ "Williamson Near Chiloquin.Gage Outflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "March 31, Current Year" ) ) ) COMMENTED_BY "April thru September Forecasted Inflow Plus March Actual Inflow"
   ELSE
    IF ( "GetMonth"( @"t" ) == 5.00000000 )
    THEN
     ( "EstimatedWilliamsonForecast"( "GetDate"( "May 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + "SumFlowsToVolumeSkipNaN"( $ "Williamson Near Chiloquin.Gage Outflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "April 30, Current Year" ) ) ) COMMENTED_BY "May thru September Forecasted Inflow Plus March thru April Actual Inflow"
    ELSE
     IF ( ( "GetMonth"( @"t" ) == 6.00000000 ) COMMENTED_BY "June thru September Forecasted Inflow Plus March thru May Actual Inflow" )
     THEN
      ( "EstimatedWilliamsonForecast"( "GetDate"( "June 1, Current Year" ), "GetDate"( "September 30, Current Year" ) ) + "SumFlowsToVolumeSkipNaN"( $ "Williamson Near Chiloquin.Gage Outflow", "GetDate"( "March 1, Current Year" ), "GetDate"( "May 3, Current Year" ) ) )
     ELSE
      $ "ProjectData.Williamson50Volume" [@"t - 1"]
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ELSE
  $ "ProjectData.Williamson50Volume" [@"t - 1"]
 ENDIF;

    END;

  END;

  POLICY_GROUP   "Winter Operations";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NAMES_COLOR  "#000000";
  NOTES          "";
  BEGIN

    RULE                 "Set IGD Outflow and Compute Rampdown";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
  NAMES_COLOR  "#0000ff";
    NOTES                "";
    BEGIN

      IF_STATEMENT ("WinterOps"(  )) THEN
            WITH_STATEMENT (NUMERIC RampAdj = IF ( $ "IGD.Outflow" [@"t - 1"] < $ "IGD.Ramping Adjustments" [0.00000000, "IGD Outflow"] )
 THEN
  $ "IGD.Ramping Adjustments" [0.00000000, "Ramping Adj"]
 ELSE
  $ "IGD.Outflow" [@"t - 1"] - $ "IGD.Ramping Adjustments" [2.00000000, "Ramping Adj"]
 ENDIF
 ELSEIF_COND ( $ "IGD.Outflow" [@"t - 1"] < $ "IGD.Ramping Adjustments" [1.00000000, "IGD Outflow"] )
 ELSEIF_CLAUSE ( $ "IGD.Ramping Adjustments" [1.00000000, "Ramping Adj"] )
 END_ELSEIF) DO
            WITH_STATEMENT (NUMERIC NoRampdown = "Max"( $ "IGD.MinRelease" [], $ "IGD.WFloodorTargetFlow" [] )) DO
            WITH_STATEMENT (NUMERIC ScheduledRampdown = "Max"( $ "IGD.ScheduledRampdownFlow" [@"t - 1"] - RampAdj, NoRampdown )) DO
            $ "IGD.ActualRampdownFlow" [] := "Max"( $ "IGD.Outflow" [@"t - 1"] - RampAdj, NoRampdown );

            $ "IGD.NoRampdownFlow" [] := NoRampdown;

            $ "IGD.ScheduledRampdownFlow" [] := ScheduledRampdown;

            IF_STATEMENT ("Operations Period"(  )) THEN
            $ "IGD.Outflow" [] := ScheduledRampdown;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Compute IGD General Flow Components";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      BREAKPOINT BEFORE_EXEC TRUE;
    BREAKPOINT AFTER_EXEC TRUE;
      IF_STATEMENT ("WinterOps"(  )) THEN
            $ "IGD.WLinkMinFlow" [] := $ "Ag Sheet.Net Accrete" [@"t - 6"] + $ "Link River.Min Release" [@"t - 6"];

            $ "IGD.WLinkReleaseFlow" [] := $ "Ag Sheet.Net Accrete" [@"t - 6"] + $ "Link River.Fall Winter Release" [@"t - 6"];

            $ "IGD.WFloodorTargetFlow" [] := $ "Ag Sheet.Net Accrete" [@"t - 6"] + "Max"( $ "Link River.Fall Winter Target" [@"t - 6"], $ "UKL.Flood Release" [@"t - 6"] );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Local Inflow to Excess Ag Allocation";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
  NAMES_COLOR  "#0000ff";
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            IF_STATEMENT ($ "JC Boyle.Inflow" [] > $ "IGD.Outflow" []) THEN
            $ "Copco to Iron Gate Gain.Local Inflow" [] := $ "IGD.Outflow" [] - $ "JC Boyle.Inflow" [];

      ELSE
            $ "Copco to Iron Gate Gain.Local Inflow" [] := 0.00000000 "cfs";

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Keno PE to Previous Value";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
  NAMES_COLOR  "#0000ff";
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Keno.Pool Elevation" [] := $ "Keno.Pool Elevation" [@"t - 1"];

      END_IF_STATEMENT;

    END;

    RULE                 "Set UKL Outflow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
  NAMES_COLOR  "#0000ff";
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "UKL.Outflow" [] := $ "Link River.Fall Winter Target" [] + $ "UKL.Ag Demand" [];

      END_IF_STATEMENT;

    END;

    RULE                 "Compute Link Fall Winter Target";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("WinterOps"(  )) THEN
            WITH_STATEMENT (NUMERIC OptRelease = IF ( IsNaN $ "UKL.FillRateAdjust" [] )
 THEN
  0.00000000 "cfs"
 ELSE
  $ "Link River.Fall Winter Release" []
 ENDIF) DO
            $ "Link River.Fall Winter Target" [] := "MaxItem"( { $ "Link River.Min Release" [] , $ "Link River.Release for IGD Min" [] , OptRelease } );

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Compute Link Release Fall Winter";
    DESCRIPTION          "Rewrite cutoff dates to work for any given years, possibly assigning a user-defined function or an and logic constraint";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("WinterOps"(  )) THEN
            WITH_STATEMENT (NUMERIC OctNovAug = IF ( @"t" < @"24:00:00 November 9, 2018" )
 THEN
  $ "Ag Sheet.OctNov Augment" []
 ELSE
  0.00000000 "cfs"
 ENDIF) DO
            WITH_STATEMENT (NUMERIC AdjFactor = IF ( @"t" < @"24:00:00 November 9, 2018" )
 THEN
  1.00000000
 ELSE
  1.00000000
 ENDIF
 ELSEIF_COND ( $ "UKL.CumInfIndex" [] < 0.30000000 )
 ELSEIF_CLAUSE ( IF ( IsNaN $ "UKL.FillRateAdjust" [] )
 THEN
  1.00000000
 ELSE
  $ "UKL.FillRateAdjust" []
 ENDIF )
 END_ELSEIF) DO
            $ "Link River.Fall Winter Release" [] := $ "Williamson River Inflow.Inflow" [@"t - 1"] * $ "Ag Sheet.Accrete Adj Factor" [] * $ "Williamson River Inflow.Proportion Factor" [] * AdjFactor + OctNovAug;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Compute Link Release for IGD Min";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("WinterOps"(  )) THEN
            $ "Link River.Release for IGD Min" [] := $ "IGD.MinRelease" [@"t + 7"] - $ "Ag Sheet.Net Accrete" [];

      END_IF_STATEMENT;

    END;

    RULE                 "Compute Accretion Adj Factor";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("WinterOps"(  )) THEN
            $ "Ag Sheet.Accrete Adj Factor" [] := "TableInterpolation"( $ "Ag Sheet.Net Accrete Adj Table", "GetColumnIndex"( $ "Ag Sheet.Net Accrete Adj Table", "GetMonthAsString"( @"t" ) CONCAT " Net Accrete" ), "GetColumnIndex"( $ "Ag Sheet.Net Accrete Adj Table", "GetMonthAsString"( @"t" ) CONCAT " Accrete Adj" ), $ "Ag Sheet.Net Accrete" [], @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Compute Net Accrete";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      BREAKPOINT BEFORE_EXEC FALSE;
    BREAKPOINT AFTER_EXEC FALSE;
      $ "Ag Sheet.Net Accrete" [] := $ "Lost River To Klamath River.Inflow2" [] + $ "F and FF Pump.Outflow" [] + $ "Lake Ewuana Gain.Local Inflow" [] + $ "Keno to Boyle Gain.Local Inflow" [@"t + 7"];

    END;

    RULE                 "Compute UKL Fill Rate Adjust";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("WinterOps"(  )) THEN
            WITH_STATEMENT (NUMERIC ColumnNum = IF ( $ "UKL.CumInfIndex" [] < 0.30000000 )
 THEN
  2.00000000
 ELSE
  1.00000000
 ENDIF) DO
            $ "UKL.FillRateAdjust" [] := "TableInterpolation"( $ "UKL.Fill Rate Adj Table", 0.00000000, ColumnNum, $ "UKL.FillRateDiff" [], @"t" );

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Compute UK Fill Rates";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      BREAKPOINT BEFORE_EXEC FALSE;
    BREAKPOINT AFTER_EXEC FALSE;
      IF_STATEMENT ("WinterOps"(  )) THEN
            WITH_STATEMENT (NUMERIC Recent = ( $ "UKL.Pool Elevation" [@"t"] - $ "UKL.Pool Elevation" [@"t - 7"] ) / 7.00000000 "day") DO
            WITH_STATEMENT (NUMERIC Needed = ( $ "UKL.TargetElevation" [@"24:00:00 March 1, 2019"] - $ "UKL.Pool Elevation" [] ) / ( 151.00000000 "day" - ( @"t" - @"24:00:00 October 1, 2018" ) )) DO
            $ "UKL.FillRateDiff" [] := Recent - Needed;

            $ "UKL.RecentFillRate" [] := Recent;

            $ "UKL.NeededFillRate" [] := Needed;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Compute Cumulative Inflow Index";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      BREAKPOINT BEFORE_EXEC FALSE;
    BREAKPOINT AFTER_EXEC FALSE;
      IF_STATEMENT ("SeptemberThruFebruary"(  )) THEN
            WITH_STATEMENT (NUMERIC CumInflow = $ "UKL.CumInflow" [@"t - 1"] + "FlowToVolume"( $ "UKL.Inflow" [], @"t" )) DO
            $ "UKL.CumInflow" [] := CumInflow;

            IF_STATEMENT ("OctoberThruFebruary"(  )) THEN
            $ "UKL.CumInfIndex" [] := ( CumInflow - $ "UKL.POR Cum Inf" [@"t", "MIN"] ) / ( $ "UKL.POR Cum Inf" [@"t", "MAX"] - $ "UKL.POR Cum Inf" [@"t", "MIN"] );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Compute Williamson Proportion Factor";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("WinterOps"(  )) THEN
            $ "Williamson River Inflow.Proportion Factor" [] := "TableInterpolation"( $ "Williamson River Inflow.Williamson Proportion Table", "GetColumnIndex"( $ "Williamson River Inflow.Williamson Proportion Table", "GetMonthAsString"( @"t" ) CONCAT " Williamson Flow" ), "GetColumnIndex"( $ "Williamson River Inflow.Williamson Proportion Table", "GetMonthAsString"( @"t" ) CONCAT " Prop Factor" ), $ "Williamson River Inflow.Inflow" [@"t - 1"], @"t" );

      END_IF_STATEMENT;

    END;

  END;

  POLICY_GROUP   "General Klamath Project Operations";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Compute UKL Flood Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC Scenario = IF ( $ "UKL.Inflow Scenario" [] < 2.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF) DO
            WITH_STATEMENT (NUMERIC RampdownDays = IF ( $ "UKL.Pool Elevation" [@"t - 1"] <= $ "UKL.Flood Elevation Table" [@"t - 1", Scenario] )
 THEN
  0.00000000
 ELSE
  $ "UKL.RampdownPeriod" []
 ENDIF
 ELSEIF_COND ( $ "UKL.Pool Elevation" [@"t - 1"] <= $ "UKL.Flood Elev Correction" [@"t - 1"] )
 ELSEIF_CLAUSE ( $ "UKL.RampdownDays" [] - 1.00000000 )
 END_ELSEIF) DO
            WITH_STATEMENT (NUMERIC IncrementalChange = IF ( RampdownDays > 0.00000000 )
 THEN
  ( $ "UKL.Flood Elevation Table" ["OffsetDate"( @"t - 1", RampdownDays, "1 day" ), Scenario] - $ "UKL.Pool Elevation" ["OffsetDate"( @"t - 1", RampdownDays - $ "UKL.RampdownPeriod" [], "1 day" )] ) / $ "UKL.RampdownPeriod" []
 ELSE
  0.00000000 "ft"
 ENDIF) DO
            WITH_STATEMENT (NUMERIC FloodElevCorrection = IF ( RampdownDays > 0.00000000 )
 THEN
  $ "UKL.Pool Elevation" ["OffsetDate"( @"t - 1", RampdownDays - $ "UKL.RampdownPeriod" [], "1 day" )] + IncrementalChange * ( $ "UKL.RampdownPeriod" [] + 1.00000000 - RampdownDays )
 ELSE
  $ "UKL.Flood Elevation Table" [@"t", Scenario]
 ENDIF) DO
            $ "UKL.Flood Release" [] := "Max"( 0.00000000 "cfs", "Min"( $ "UKL.Max Outflow" [], "VolumeToFlow"( $ "UKL.Storage" [@"t - 1"] - "ElevationToStorage"( % "UKL", FloodElevCorrection ), @"t" ) + $ "UKL.Inflow" [] - $ "UKL.Ag Demand" [] - $ "UKL.Flood Override Correction" [] ) );

            $ "UKL.RampdownDays" [] := RampdownDays;

            $ "UKL.Flood Elev Correction" [] := FloodElevCorrection;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Set Klamath to LRDC Diversion Request";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
  NAMES_COLOR  "#0000ff";
    NOTES                "";
    BEGIN

      IF_STATEMENT ($ "Station 48.Diversion Request" [] + $ "Miller Hill Pump.Diversion Request" [] > $ "Lost River Diversion Channel.Outflow" []) THEN
            $ "Div To LRDC.Diversion Request" [] := $ "Miller Hill Pump.Diversion Request" [] + $ "Station 48.Diversion Request" [] - $ "Lost River Diversion Channel.Outflow" [];

      END_IF_STATEMENT;

    END;

    RULE                 "Set UKL Inflow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
  NAMES_COLOR  "#0000ff";
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC scenario = IF ( $ "UKL.Inflow Scenario" [] == 1.00000000 )
 THEN
  $ "UKL.Dry Scenario" []
 ELSE
  $ "UKL.Wet Scenario" []
 ENDIF
 ELSEIF_COND ( $ "UKL.Inflow Scenario" [] == 2.00000000 )
 ELSEIF_CLAUSE ( $ "UKL.Med Scenario" [] )
 END_ELSEIF) DO
            WITH_STATEMENT (NUMERIC AdjFactor = IF ( @"t" - $ "UKL.Short Season Adj Period" [] < "NumberToDate"( $ "Dashboard Controls.Operation Start" [] ) )
 THEN
  $ "UKL.Short Season Adj Factor" []
 ELSE
  1.00000000
 ENDIF
 ELSEIF_COND ( @"t" - $ "UKL.Season Adj Period" [] < "NumberToDate"( $ "Dashboard Controls.Operation Start" [] ) )
 ELSEIF_CLAUSE ( $ "UKL.Season Adj Factor" [] )
 END_ELSEIF) DO
            IF_STATEMENT ("Operations Period"(  )) THEN
            $ "UKL.Inflow" [] := $ "UKL.Historical Inflows" [@"t", scenario] * AdjFactor;

            $ "UKL.Projected Inflow" [] := $ "UKL.Historical Inflows" [@"t", scenario] * AdjFactor;

      ELSE
            $ "UKL.Projected Inflow" [] := $ "UKL.Historical Inflows" [@"t", scenario] * AdjFactor;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Compute UKL Ag Demand";
    DESCRIPTION          "Correct for Miller Hill and Station 48 cosiderations for pre Operation Start scenarios - in winter season";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            IF_STATEMENT ("DecemberThruFebruary"(  )) THEN
            WITH_STATEMENT (NUMERIC AdditionalDemands = IF ( $ "Ag Sheet.2016 Demands" [] > $ "Ag Sheet.2015 LRDC" [] )
 THEN
  "VolumeToFlow"( $ "Ag Sheet.2016 Demands" [] - $ "Ag Sheet.2015 LRDC" [], @"t" )
 ELSE
  0.00000000 "cfs"
 ENDIF) DO
            $ "UKL.Ag Demand" [] := AdditionalDemands + $ "Ady Canal.Diversion Request" [] + $ "North Canal.Diversion Request" [];

      END_WITH_STATEMENT;

      ELSE
            $ "UKL.Ag Demand" [] := ( $ "Ag Sheet.Total Deliveries" [] - "SumFlowsToVolume"( $ "UKL.Ag Demand", @"24:00:00 Current Month 1, Current Year", @"t - 1" ) ) / ( "GetDaysInMonth"( @"t" ) - "GetDayOfMonth"( @"t - 1" ) );

      END_IF_STATEMENT
      ELSEIF_COND ( "FirstDayOfMonth"(  ) )
      ELSEIF_CLAUSE
            $ "UKL.Ag Demand" [] := $ "Ag Sheet.Total Deliveries" [] / "GetDaysInMonth"( @"t" );
      END_ELSEIF;

      ELSE
            WITH_STATEMENT (NUMERIC AgConsiderations = $ "A Canal.Diversion" [] + $ "North Canal.Diversion" [] + $ "Ady Canal.Diversion" [] - $ "Area 2 Supply.Outflow" [] - ( $ "Lost River Diversion Channel.Inflow" [] - $ "Station 48.Diversion" [] - $ "Miller Hill Pump.Diversion" [] )) DO
            WITH_STATEMENT (NUMERIC SetDemand = IF ( "WinterOps"(  ) )
 THEN
  $ "A Canal.Diversion" []
 ELSE
  AgConsiderations
 ENDIF
 ELSEIF_COND ( AgConsiderations < 0.00000000 "cfs" )
 ELSEIF_CLAUSE ( 0.00000000 "cfs" )
 END_ELSEIF
 ELSEIF_COND ( AgConsiderations < $ "A Canal.Diversion" [] )
 ELSEIF_CLAUSE ( $ "A Canal.Diversion" [] )
 END_ELSEIF) DO
            $ "UKL.Ag Demand" [] := SetDemand;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set KDD Accounting Supplies";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "OctoberThruFebruary"(  );
  NAMES_COLOR  "#0000ff";
    NOTES                "";
    BEGIN

      $ "Upper Klamath Lake KDD Winter to Link River KDD Winter.Supply" [] := IF ( "Operations Period"(  ) )
 THEN
  $ "North Canal.Diversion" [] + $ "Ady Canal.Diversion" []
 ELSE
  $ "North Canal.Diversion" [] + ( $ "Ady Canal.Diversion" [] - $ "Area 2 Supply.Outflow" [] )
 ENDIF;

      $ "Diversion To North KDD Winter to North Canal KDD Winter Div.Supply" [] := $ "North Canal.Diversion" [];

      $ "Diversion To Ady KDD Winter to Ady Canal KDD Winter Div.Supply" [] := IF ( "Operations Period"(  ) )
 THEN
  $ "Ady Canal.Diversion" []
 ELSE
  $ "Ady Canal.Diversion" [] - $ "Area 2 Supply.Outflow" []
 ENDIF;

    END;

    RULE                 "Set Ady and North Diversion Request";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
  NAMES_COLOR  "#0000ff";
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Ady Canal.Diversion Request" [] := $ "Ag Sheet.KlamathToAdy" [@"t", $ "Ag Sheet.KDD Irrigation Scenario" []] * $ "Ag Sheet.KDDtoAdy adj" [];

            $ "North Canal.Diversion Request" [] := $ "Ag Sheet.KlamathToNorth" [@"t", $ "Ag Sheet.KDD Irrigation Scenario" []] * $ "Ag Sheet.KDDtoNorth adj" [];

      END_IF_STATEMENT;

    END;

    RULE                 "Set LRDC Flow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
  NAMES_COLOR  "#0000ff";
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period - 3"(  )) THEN
            IF_STATEMENT (@"t - 10" <= "NumberToDate"( $ "Dashboard Controls.Operation Start" [] )) THEN
            $ "Lost River Diversion Channel.Inflow" [@"t + 3"] := FOR ( DATETIME date IN "GetDates"( @"t - 4", @"t + 2", "1 Days" ) ) STAT_AVE
  $ "Lost River Diversion Channel.Inflow" [date]
 ENDFOR;

      ELSE
            $ "Lost River Diversion Channel.Inflow" [@"t + 3"] := $ "Lost River Diversion Channel.LRDC Historic Flows" [@"t + 3", $ "Dashboard Controls.OpPercentile" []];

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Williamson Inflow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
  NAMES_COLOR  "#0000ff";
    NOTES                "";
    BEGIN

      BREAKPOINT BEFORE_EXEC FALSE;
    BREAKPOINT AFTER_EXEC FALSE;
      IF_STATEMENT ("Operations Period"(  )) THEN
            WITH_STATEMENT (NUMERIC AdjFactor = IF ( @"t - 5" <= "NumberToDate"( $ "Dashboard Controls.Operation Start" [] ) )
 THEN
  $ "Williamson River Inflow.Short Adj Factor" []
 ELSE
  $ "Williamson River Inflow.Season Adj Factor" []
 ENDIF) DO
            $ "Williamson River Inflow.Inflow" [] := $ "Williamson River Inflow.CNRFC Forecast Flows" [@"t", "CNRFC " CONCAT "IntegerToString"( $ "Williamson River Inflow.CNRFC" [] )] * AdjFactor;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

  END;

  POLICY_GROUP   "Lost River Operations";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Lost River Irrigation Supply";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Lost River Irrigation Depletions.Incoming Available Water" [] := "Max"( "Min"( $ "Lost River Irrigation Diversions.Inflow" [], $ "Lost River Irrigation Depletions.Diversion Requested" [] ), 0.00000000 "cms" );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Gerber Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Gerber.Outflow" [] := "UnregSpillwayCapacityCheck"( % "Gerber", "MaxMinElevationCheck"( % "Gerber", "Gerber", "MaxItem"( { "GerberIrrigationRelease"(  ) + $ "Gerber.TargetRelease" [] , $ "Gerber.Custom Flood Control Release" [] , $ "Gerber.InstreamFlowRelease" [] } ) ) );

      END_IF_STATEMENT;

    END;

    RULE                 "Gerber Seepage";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Gerber.Seepage" [] := "ComputeAvgSeepageOverPeriod"( $ "Gerber.SeepageRates", "Gerber", $ "Gerber.Surface Area" [@"t - 1"], $ "Gerber.Surface Area" [@"t - 1"], @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Gerber Lake Flood Control Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Gerber.Custom Flood Control Release" [] := IF ( "JanuaryThruApril"(  ) )
 THEN
  WITH NUMERIC coeFloodControl = "DailyFloodControlRelease"( % "Gerber", "Gerber", "GetDate"( "April 30, Current Year" ), $ "Gerber.MaxRelease" [], "EstimatedInflowForecast"( $ "Gerber.Inflow", @"t", "GetDate"( "April 30, Current Year" ) ) ) DO
   "MaxItem"( { coeFloodControl , "DailyMaximumStorageRelease"( % "Gerber", "Gerber", @"t", % "Gerber" & "Storage" [@"t - 1"], 0.50000000 * ( $ "Gerber.Inflow" [] + $ "Gerber.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ) , "DailyFloodControlRelease"( % "Gerber", "Gerber", "DateMin"( "OffsetDate"( @"t", $ "Gerber.Fcst Period" [], "1 days" ), @"Finish Timestep" ), $ "Gerber.MaxRelease" [], "EstimatedInflowForecast"( $ "Gerber.Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "Gerber.Fcst Period" [], "1 days" ), @"Finish Timestep" ) ) ) } )
  ENDWITH
 ELSE
  "Max"( "DailyMaximumStorageRelease"( % "Gerber", "Gerber", @"t", % "Gerber" & "Storage" [@"t - 1"], 0.50000000 * ( $ "Gerber.Inflow" [] + $ "Gerber.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ), "DailyFloodControlRelease"( % "Gerber", "Gerber", "DateMin"( "OffsetDate"( @"t", $ "Gerber.Fcst Period" [], "1 days" ), @"Finish Timestep" ), $ "Gerber.MaxRelease" [], "EstimatedInflowForecast"( $ "Gerber.Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "Gerber.Fcst Period" [], "1 days" ), @"Finish Timestep" ) ) ) )
 ENDIF;

      END_IF_STATEMENT;

    END;

    RULE                 "Gerber Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Gerber.TargetRelease" [] := IF ( $ "Gerber.Pool Elevation" [@"t - 1"] >= $ "Gerber.DailyTargetElevation" [] )
 THEN
  "AverageDailyFlowForVolume"( "SurplusVolumeBySlotWithLosses"( % "Gerber", "Gerber", $ "Gerber.Inflow", "EstimateSeepage"( $ "Gerber.SeepageRates", "Gerber", "GetMeanArea"( % "Clear", % "Gerber" & "Storage" [@"t - 1"], "DailyTargetStorage"( % "Gerber", "Gerber", "DateMin"( "OffsetDate"( @"t", $ "Gerber.Fcst Period" [], "1 days" ), @"Finish Timestep" ) ) ), "DateMin"( @"t", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "Gerber.Fcst Period" [], "1 days" ), @"Finish Timestep" ) ), @"t", "DateMin"( "OffsetDate"( @"t", $ "Gerber.Fcst Period" [], "1 days" ), @"Finish Timestep" ) ), @"t", "DateMin"( "OffsetDate"( @"t", $ "Gerber.Fcst Period" [], "1 days" ), @"Finish Timestep" ) )
 ELSE
  $ "Gerber.TargetRelease" [@"t - 1"]
 ENDIF;

    END;

    RULE                 "Max Storage Failsafe Clear";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("SolveStorage"( % "Clear", $ "Clear.Total Inflows" [], $ "Clear.Outflow" [], $ "Clear.Storage" [@"t - 1"], @"t" ) >= "ElevationToStorage"( % "Clear", $ "Clear.MaxElevation" [@"t", 0.00000000] )) THEN
            $ "Clear.Release" [] := "Min"( "Reservoir Outflow at Drawdown to Rule Curve"( % "Clear" ), "GetMaxReleaseGivenInflow"( % "Clear", $ "Clear.Total Inflows" [], @"t" ) );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Clear Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Clear.Outflow" [] := "UnregSpillwayCapacityCheck"( % "Clear", "MaxMinElevationCheck"( % "Clear", "Clear", "MaxItem"( { "ClearLakeIrrigationRelease"(  ) + $ "Clear.TargetRelease" [] , $ "Clear.Custom Flood Control Release" [] , $ "Clear.InstreamFlowRelease" [] } ) ) );

      END_IF_STATEMENT;

    END;

    RULE                 "Clear Seepage";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Clear.Seepage" [] := "ComputeAvgSeepageOverPeriod"( $ "Clear.SeepageRates", "Clear", $ "Clear.Surface Area" [@"t - 1"], $ "Clear.Surface Area" [@"t - 1"], @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Clear Flood Control Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Clear.Custom Flood Control Release" [] := IF ( "JanuaryThruApril"(  ) )
 THEN
  WITH NUMERIC coeFloodControl = "DailyFloodControlRelease"( % "Clear", "Clear", "GetDate"( "April 30, Current Year" ), $ "Clear.MaxRelease" [], "EstimatedInflowForecast"( $ "Clear.Inflow", @"t", "GetDate"( "April 30, Current Year" ) ) ) DO
   "MaxItem"( { coeFloodControl , "DailyMaximumStorageRelease"( % "Clear", "Clear", @"t", % "Clear" & "Storage" [@"t - 1"], 0.50000000 * ( $ "Clear.Inflow" [] + $ "Clear.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ) , "DailyFloodControlRelease"( % "Clear", "Clear", "DateMin"( "OffsetDate"( @"t", $ "Clear.Fcst Period" [], "1 days" ), @"Finish Timestep" ), $ "Clear.MaxRelease" [], "EstimatedInflowForecast"( $ "Clear.Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "Clear.Fcst Period" [], "1 days" ), @"Finish Timestep" ) ) ) } )
  ENDWITH
 ELSE
  "Max"( "DailyMaximumStorageRelease"( % "Clear", "Clear", @"t", % "Clear" & "Storage" [@"t - 1"], 0.50000000 * ( $ "Clear.Inflow" [] + $ "Clear.Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )] ) ), "DailyFloodControlRelease"( % "Clear", "Clear", "DateMin"( "OffsetDate"( @"t", $ "Clear.Fcst Period" [], "1 days" ), @"Finish Timestep" ), $ "Clear.MaxRelease" [], "EstimatedInflowForecast"( $ "Clear.Inflow", @"t", "DateMin"( "OffsetDate"( @"t", $ "Clear.Fcst Period" [], "1 days" ), @"Finish Timestep" ) ) ) )
 ENDIF;

      END_IF_STATEMENT;

    END;

    RULE                 "Clear Target Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      $ "Clear.TargetRelease" [] := IF ( $ "Clear.Pool Elevation" [@"t - 1"] >= $ "Clear.DailyTargetElevation" [] )
 THEN
  "AverageDailyFlowForVolume"( "SurplusVolumeBySlotWithLosses"( % "Clear", "Clear", $ "Clear.Inflow", "EstimateSeepage"( $ "Clear.SeepageRates", "Clear", "GetMeanArea"( % "Clear", % "Clear" & "Storage" [@"t - 1"], "DailyTargetStorage"( % "Clear", "Clear", "DateMin"( "OffsetDate"( @"t", $ "Clear.Fcst Period" [], "1 days" ), @"Finish Timestep" ) ) ), "DateMin"( @"t", @"Finish Timestep" ), "DateMin"( "OffsetDate"( @"t", $ "Clear.Fcst Period" [], "1 days" ), @"Finish Timestep" ) ), @"t", "DateMin"( "OffsetDate"( @"t", $ "Clear.Fcst Period" [], "1 days" ), @"Finish Timestep" ) ), @"t", "DateMin"( "OffsetDate"( @"t", $ "Clear.Fcst Period" [], "1 days" ), @"Finish Timestep" ) )
 ELSE
  $ "Clear.TargetRelease" [@"t - 1"]
 ENDIF;

    END;

    RULE                 "Adjust Clear Target Elevation For Surcharging";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Clear.DailyTargetElevation" [] := $ "Clear.TargetElevation" [];

      END_IF_STATEMENT;

    END;

    RULE                 "Gerber Instream Flow Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Gerber.InstreamFlowRelease" [] := "Max"( "Min"( "Min"( $ "Gerber.Inflow" [], "Min"( $ "Gerber.MinRelease" [], "GetMaxReleaseGivenInflow"( % "Gerber", $ "Gerber.Inflow" [], @"t" ) ) ), "SolveOutflow"( % "Gerber", $ "Gerber.Inflow" [], "ElevationToStorage"( % "Gerber", $ "Gerber.ReservoirAllocations" ["Inactive", "Gerber Reservoir"] ), "PreviousStorage"( % "Gerber" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

      END_IF_STATEMENT;

    END;

    RULE                 "Clear Instream Flow Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period"(  )) THEN
            $ "Clear.InstreamFlowRelease" [] := "Max"( "Min"( "Min"( $ "Clear.Inflow" [], "Min"( $ "Clear.MinRelease" [], "GetMaxReleaseGivenInflow"( % "Clear", $ "Clear.Inflow" [], @"t" ) ) ), "SolveOutflow"( % "Clear", $ "Clear.Inflow" [], "ElevationToStorage"( % "Clear", $ "Clear.ReservoirAllocations" ["Inactive", "Clear Lake"] ), "PreviousStorage"( % "Clear" ), @"t" ) COMMENTED_BY "Check for low reservoir conditions." ), 0.00000000 "cms" );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Lost Res Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("Operations Period - 3"(  )) THEN
            $ "Gerber.Outflow" [@"t + 3"] := $ "Gerber.AverageRelease" [@"t + 3"];

            $ "Clear.Outflow" [@"t + 3"] := $ "Clear.AverageRelease" [@"t + 3"];

      END_IF_STATEMENT;

    END;

  END;

  POLICY_GROUP   "Forecast Computations";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "No Forecast Error";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

      $ "ReservoirData.UpperKlamathLakePercentForecastError" [] := 0.00000000;

      $ "ReservoirData.WilliamsonPercentForecastError" [] := 0.00000000;

    END;

    RULE                 "Save Iron Gate Routed Klamath Inflow";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == "RunStartDate"(  );
    NOTES                "";
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( "RunStartDate"(  ), "RunEndDate"(  ), "1 Days" )) DO
            $ "ReservoirOperations.IGD Routed UKL Inflow" [date] := $ "Keno To Iron Gate Routing.Outflow" [date];

      ENDFOREACH;

    END;

    RULE                 "Initialiize UKL To Iron Gate Routing";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == "RunStartDate"(  );
    NOTES                "";
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( "RunStartDate"(  ), "RunEndDate"(  ), "1 Days" )) DO
            $ "UKL To Keno Gain.Inflow" [date] := $ "UKL.Inflow" [date];

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Planning Specific Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Compute UKL Pool Elevation Projection - Test for Planning";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "";
    BEGIN

    DESCRIPTION          "This is a prototype rule that will project the pool elevation out X number of timesteps, based on <br>the specified inflows, outflows, and diversions. It may be useful in a planning application <br>";
      IF_STATEMENT ("NumberToDate"( $ "KBPMOperationsData.Operation Start" [] ) == @"t") THEN
            WITH_STATEMENT (NUMERIC NumOfProjectionTimesteps = 60.00000000) DO
            WITH_STATEMENT (DATETIME endDate = "OffsetDate"( @"t", NumOfProjectionTimesteps - 1.00000000, "1 Days" )) DO
            WITH_STATEMENT (LIST ListOfIndex = "GetNumbers"( 0.00000000, NumOfProjectionTimesteps - 1.00000000, 1.00000000 )) DO
            WITH_STATEMENT (LIST hypSimResults = "HypSim"( "UKL", "CreateListOfProjectedInAndOut"( endDate ), "ListOfProjectedPE"( endDate ), 0.00000000 )) DO
            FOREACH (NUMERIC index IN ListOfIndex) DO
            $ "UKL.Pool Elevation Projected" ["OffsetDate"( @"t", index, "1 Days" )] := GET @INDEX index FROM hypSimResults;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

  END;

  UTILITY_GROUP "Model Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AdjustedProjectSupply" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "m3", $ "ProjectData.ProjectSupply" [date] - $ "ProjectData.ProjectCumForIronGateMin" [date] );

    END;

    FUNCTION       "AvailableClearLakeWater" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cms";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "NovemberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "VolumeToFlow"( "Max"( $ "Clear.Storage" [@"t - 1"] - "ElevationToStorage"( % "Clear", $ "Clear.ReservoirAllocations" ["Normal Minimum", "Clear Lake"] ), 0.00000000 "m3" ), @"t" )
 ENDIF;

    END;

    FUNCTION       "AvailableGerberReservoirWater" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cms";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "NovemberThruMarch"(  ) )
 THEN
  0.00000000 "cms"
 ELSE
  "VolumeToFlow"( "Max"( "PreviousStorage"( % "Gerber" ) - "ElevationToStorage"( % "Gerber", $ "Gerber.ReservoirAllocations" ["Normal Minimum", "Gerber Reservoir"] ), 0.00000000 "m3" ), @"t" )
 ENDIF;

    END;

    FUNCTION       "AvailableLostRiverStorageWater" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "AvailableGerberReservoirWater"(  ) + "AvailableClearLakeWater"(  );

    END;

    FUNCTION       "AugNovRefugeProportion" ( NUMERIC remainingProjectSupply )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " 1 NONE";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "DecemberThruJuly"(  ) )
 THEN
  0.00000000
 ELSE
  WITH NUMERIC mon = "GetMonth"( @"t" ) DO
   IF ( mon == 8.00000000 )
   THEN
    "TableInterpolation"( $ "Refuge.AugNovRefugeProportions", 0.00000000, 1.00000000, remainingProjectSupply, @"t" )
   ELSE
    IF ( mon == 9.00000000 )
    THEN
     "TableInterpolation"( $ "Refuge.AugNovRefugeProportions", 2.00000000, 3.00000000, remainingProjectSupply, @"t" )
    ELSE
     IF ( mon == 10.00000000 )
     THEN
      "TableInterpolation"( $ "Refuge.AugNovRefugeProportions", 4.00000000, 5.00000000, remainingProjectSupply, @"t" )
     ELSE
      IF ( mon == 11.00000000 )
      THEN
       "TableInterpolation"( $ "Refuge.AugNovRefugeProportions", 6.00000000, 7.00000000, remainingProjectSupply, @"t" )
      ELSE
       0.00000000
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDWITH
 ENDIF;

    END;

    FUNCTION       "ClearLakeIrrigationRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "AvailableLostRiverStorageWater"(  ) > 0.00000000 "cms" )
 THEN
  "Min"( "AvailableClearLakeWater"(  ) / "AvailableLostRiverStorageWater"(  ) * "Max"( $ "Lost River Irrigation Depletions.Diversion Requested" ["DateMin"( @"t + 1", @"Finish Timestep" )] - $ "Lost River Gains.Local Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )], 0.00000000 "cms" ), "GetMaxOutflowGivenInflow"( % "Clear", $ "Clear.Inflow" [], @"t" ) )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    FUNCTION       "ComputeAvgSeepageOverPeriod" ( SLOT SpgRate, STRING column, NUMERIC startingArea, NUMERIC endingArea, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      0.50000000 * ( startingArea + endingArea ) * SpgRate [date, column];

    END;

    FUNCTION       "EstimateSeepage" ( SLOT seepageRate, STRING column, NUMERIC meanArea, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "Estimates furture reservoir evaporation form startDate (usually current time step)<br>thru endDate.  Additional argument of meanArea is estimated average surface<br>area during interval.<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( seepageRate [date, column] * meanArea, date )
 ENDFOR;

    END;

    FUNCTION       "EstimatedWilliamsonForecast" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC inflowNoError = "SumFlowsToVolume"( $ "11502500 Williamson River nr Chiloquin.Gage Outflow", startDate, endDate ) DO
  inflowNoError
 ENDWITH;

    END;

    FUNCTION       "EWARemainingMinimumVolume" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "JuneThruSeptember"(  ) )
 THEN
  IF ( $ "ReservoirOperations.UKL Cumulative Excess Water Release Volume" [@"t - 1"] >= ( $ "UKL.EWARemainMinimumAdjustmentFactors" [@"t", "EWARiverFraction"] * $ "ProjectData.EWARiver" [@"t"] ) )
  THEN
   ( $ "UKL.EWARemainMinimumAdjustmentFactors" [@"t", "AdjustmentFactor"] * $ "ProjectData.EWARiver" [@"t"] )
  ELSE
   0.00000000 "m3"
  ENDIF
 ELSE
  0.00000000 "m3"
 ENDIF;

    END;

    FUNCTION       "IronGateCapacityCheck" ( NUMERIC request )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "Checks a tenative outflow against outlet works and spillway capacities and computes how much spill is required.<br>This function works most of the time but apparantly, when an unregulated spillway is operating with a power plant,<br>function GetMaxOutflowGivenInflow underestimates the capacity.  The only way that this case was resolved<br>was to invoke the Reduce Inflow Outflow method of the Inflow Outflow Adjustment category.  This reduces the<br>outflow to the actual release capacity.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC estEOPElev = "StorageToElevation"( % "IGD", "SolveStorage"( % "IGD", $ "IGD.Inflow" [], request, "PreviousStorage"( % "IGD" ), @"t" ) ) DO
  "Min"( "Max"( "GetMaxOutflowGivenInflow"( % "IGD", $ "IGD.Inflow" [], @"t" ) - ( "TableInterpolation"( $ "IGD.Bypass Table", 0.00000000, 1.00000000, 0.50000000 * ( $ "IGD.Pool Elevation" [@"t - 1"] + estEOPElev ), @"t" ) - $ "ReservoirOperations.IGD Hatchery Release" [] ) COMMENTED_BY "Back out unusable fish hatchery bypass capacity", 0.00000000 "cms" ), "Max"( request, "GetMinSpillGivenInflowRelease"( % "IGD", $ "IGD.Inflow" [], "Min"( "Max"( request - $ "ReservoirOperations.IGD Hatchery Release" [], 0.00000000 "cms" ), "GetMaxReleaseGivenInflow"( % "IGD", $ "IGD.Inflow" [], @"t" ) ), @"t" ) COMMENTED_BY "Flow that we have to spill thru spillways and bypass." ) )
 ENDWITH;

    END;

    FUNCTION       "IronGateMaxRamping" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( $ "ReservoirOperations.IGD Hatchery Release" [date], WITH NUMERIC flowChange = $ "IGD.Outflow" [date] COMMENTED_BY "Effectively, yesterday IG spill" - $ "IGD.Outflow" ["OffsetDate"( date, - 1.00000000, "1 Days" )] DO
  "Max"( $ "ReservoirOperations.IGD ENV Release" [date] + $ "ReservoirOperations.IGD Hatchery Release" [date], IF ( flowChange < 0.00000000 "cms" AND NOT ( "IronGatePreviousUnregulated"( date ) >= 0.00000000 "cfs" AND "IronGatePreviousUnregulated"( "OffsetDate"( date, - 1.00000000, "1 Days" ) ) >= 0.00000000 "cfs" ) )
  THEN
   ( $ "IGD.Outflow" ["OffsetDate"( date, - 1.00000000, "1 Days" )] - "Min"( - 1.00000000 * flowChange, IF ( "Max"( 0.00000000 "cms", $ "IGD.Outflow" [date] - $ "ReservoirOperations.IGD ENV Release" [date] ) COMMENTED_BY "Effectively, yesterday IG spill" <= ( $ "IGD.Iron Gate Ramping Criteria" ["Threshold", "Middle Descending"] + $ "IGD.Iron Gate Ramping Criteria" ["Flow Change", "Middle Descending"] ) AND "Max"( 0.00000000 "cms", $ "IGD.Outflow" [date] - $ "ReservoirOperations.IGD ENV Release" [date] ) COMMENTED_BY "Effectively, yesterday IG spill" > ( $ "IGD.Iron Gate Ramping Criteria" ["Threshold", "Low Descending"] + $ "IGD.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"] ) )
   THEN
    $ "IGD.Iron Gate Ramping Criteria" ["Flow Change", "Middle Descending"]
   ELSE
    IF ( "Max"( 0.00000000 "cms", $ "IGD.Outflow" [date] - $ "ReservoirOperations.IGD ENV Release" [date] ) COMMENTED_BY "Effectively, yesterday IG spill" <= ( $ "IGD.Iron Gate Ramping Criteria" ["Threshold", "Low Descending"] + $ "IGD.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"] ) )
    THEN
     $ "IGD.Iron Gate Ramping Criteria" ["Flow Change", "Low Descending"]
    ELSE
     "Max"( 0.00000000 "cms", $ "IGD.Outflow" [date] - $ "ReservoirOperations.IGD ENV Release" [date] )
    ENDIF
   ENDIF ) ) COMMENTED_BY "Descening limit is, <br>  if (proposed flow > 3000) then rate of decline is net UKL inflow + Keno to IG accretions<br>  else if (1750 < flow <= 3000) then rate of decline is 300 cfs<br>  else if (flow <= 1750) then rate of decline is 150 cfs"
  ELSE
   "Max"( 0.00000000 "cms", $ "IGD.Outflow" [date] - $ "ReservoirOperations.IGD ENV Release" [date] ) COMMENTED_BY "Ascending ramping is not restricted"
  ENDIF )
 ENDWITH );

    END;

    FUNCTION       "IronGateRampingLowerBound" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "cms", "IronGatePreviousUnregulated"( date ) - "Max"( 0.00000000 "cms", $ "IGD.Outflow" [date] - $ "ReservoirOperations.IGD ENV Release" [date] ) - "IronGateMaxRamping"( date ) );

    END;

    FUNCTION       "IronGatePreviousUnregulated" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Min"( "Max"( 0.00000000 "cms", $ "UKL.Outflow" [date] - ( $ "ReservoirOperations.UKL Environmental Release" [date] + $ "ReservoirOperations.UKL Demand Release" [date] ) - $ "ProjectData.ProjectReleaseForIronGateMin" [date] ), "Max"( 0.00000000 "cms", $ "IGD.Outflow" [date] - $ "ReservoirOperations.IGD Hatchery Release" [date] - $ "ReservoirOperations.IGD ENV Release" [date] ) COMMENTED_BY "Effectively, yesterday IG spill" );

    END;

    FUNCTION       "GerberIrrigationRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "AvailableLostRiverStorageWater"(  ) > 0.00000000 "cms" )
 THEN
  "Min"( "Min"( "AvailableGerberReservoirWater"(  ), "Max"( "Max"( $ "Lost River Irrigation Depletions.Diversion Requested" ["DateMin"( @"t + 1", @"Finish Timestep" )] - $ "Lost River Gains.Local Inflow" ["DateMin"( @"t + 1", @"Finish Timestep" )], 0.00000000 "cms" ) - "Min"( $ "Clear.Outflow" [], "ClearLakeIrrigationRelease"(  ) ), 0.00000000 "cms" ) ), "GetMaxOutflowGivenInflow"( % "Gerber", $ "Gerber.Inflow" [], @"t" ) )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    FUNCTION       "KenoToIronGateNetAccretion" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "SumSlotSkipNaN"( $ "Keno to Boyle Gain.Local Inflow", startDate, endDate ) + "SumSlotSkipNaN"( $ "Boyle Bypass Reach.Local Inflow", startDate, endDate ) + "SumSlotSkipNaN"( $ "Boyle Gage to Copco Gain.Local Inflow", startDate, endDate ) + "SumSlotSkipNaN"( $ "Copco to Iron Gate Gain.Local Inflow", startDate, endDate ) + "AverageDailyFlowForVolume"( "SumSlotSkipNaN"( $ "JC Boyle.Precipitation Volume", startDate, endDate ) + "SumSlotSkipNaN"( $ "Copco 1.Precipitation Volume", startDate, endDate ) + "SumSlotSkipNaN"( $ "IGD.Precipitation Volume", startDate, endDate ), startDate, endDate ) - "AverageDailyFlowForVolume"( "SumSlotSkipNaN"( $ "JC Boyle.Evaporation", startDate, endDate ) + "SumSlotSkipNaN"( $ "Copco 1.Evaporation", startDate, endDate ) + "SumSlotSkipNaN"( $ "IGD.Evaporation", startDate, endDate ), startDate, endDate );

    END;

    FUNCTION       "ProjectIsFull" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "DecemberThruFebruary"(  ) )
 THEN
  FALSE
 ELSE
  IF ( "OctoberThruNovember"(  ) )
  THEN
   IF ( $ "ProjectData.UKLSupply" [@"24:00:00 September Max DayOfMonth, Current Year"] - $ "ProjectData.EWARiver" [@"24:00:00 September Max DayOfMonth, Current Year"] >= $ "UKL.ProjectMaximumSupply" [] OR $ "ProjectData.UKLSupply" [@"24:00:00 September Max DayOfMonth, Current Year"] >= $ "UKL.UKLSupplyProjectFullThrehold" [] )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ELSE
   IF ( $ "ProjectData.UKLSupply" [] - $ "ProjectData.EWARiver" [] >= $ "UKL.ProjectMaximumSupply" [] OR $ "ProjectData.UKLSupply" [] >= $ "UKL.UKLSupplyProjectFullThrehold" [] )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDIF
 ENDIF;

    END;

    FUNCTION       "RemainingProjectSupply" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "m3", "AdjustedProjectSupply"( date ) - $ "ProjectData.CumAgMarchThruNovDelivery" ["OffsetDate"( date, - 1.00000000, "1 days" )] );

    END;

    FUNCTION       "SeaonalVolumeFromMonthlySlots" ( SLOT slotToCompute, DATETIME monthlyDatetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "Returns a seasonal volume from monthly flow slots.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC monthNum = "GetMonth"( monthlyDatetime ) DO
  IF ( monthNum > 9.00000000 )
  THEN
   WITH DATETIME firstDatetime = @"24:00:00 October Max DayOfMonth, Current Year" DO
    WITH DATETIME middleDatetime = @"24:00:00 November Max DayOfMonth, Current Year" DO
     WITH DATETIME lastDatetime = @"24:00:00 December Max DayOfMonth, Current Year" DO
      "SumFlowsToVolume"( slotToCompute, firstDatetime, firstDatetime ) + "SumFlowsToVolume"( slotToCompute, middleDatetime, middleDatetime ) + "SumFlowsToVolume"( slotToCompute, lastDatetime, lastDatetime )
     ENDWITH
    ENDWITH
   ENDWITH COMMENTED_BY "Fall"
  ELSE
   IF ( monthNum < 4.00000000 )
   THEN
    WITH DATETIME firstDatetime = @"24:00:00 January Max DayOfMonth, Current Year" DO
     WITH DATETIME middleDatetime = @"24:00:00 February Max DayOfMonth, Current Year" DO
      WITH DATETIME lastDatetime = @"24:00:00 March Max DayOfMonth, Current Year" DO
       "SumFlowsToVolume"( slotToCompute, firstDatetime, firstDatetime ) + "SumFlowsToVolume"( slotToCompute, middleDatetime, middleDatetime ) + "SumFlowsToVolume"( slotToCompute, lastDatetime, lastDatetime )
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "Winter"
   ELSE
    IF ( monthNum > 3.00000000 AND monthNum < 7.00000000 )
    THEN
     WITH DATETIME firstDatetime = @"24:00:00 April Max DayOfMonth, Current Year" DO
      WITH DATETIME middleDatetime = @"24:00:00 May Max DayOfMonth, Current Year" DO
       WITH DATETIME lastDatetime = @"24:00:00 June Max DayOfMonth, Current Year" DO
        "SumFlowsToVolume"( slotToCompute, firstDatetime, firstDatetime ) + "SumFlowsToVolume"( slotToCompute, middleDatetime, middleDatetime ) + "SumFlowsToVolume"( slotToCompute, lastDatetime, lastDatetime )
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "Spring"
    ELSE
     WITH DATETIME firstDatetime = @"24:00:00 July Max DayOfMonth, Current Year" DO
      WITH DATETIME middleDatetime = @"24:00:00 August Max DayOfMonth, Current Year" DO
       WITH DATETIME lastDatetime = @"24:00:00 September Max DayOfMonth, Current Year" DO
        "SumFlowsToVolume"( slotToCompute, firstDatetime, firstDatetime ) + "SumFlowsToVolume"( slotToCompute, middleDatetime, middleDatetime ) + "SumFlowsToVolume"( slotToCompute, lastDatetime, lastDatetime )
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "Summer"
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END;

    FUNCTION       "UKL_FillRateRatioSpring" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "MarchThruMay"(  ) )
 THEN
  "Min"( 1.00000000, ( $ "UKL.Pool Elevation" [@"t - 1"] - $ "UKL.ReservoirAllocations" ["Inactive", "UKL"] ) / ( $ "UKL.ReservoirAllocations" [@"t", "UKL"] - $ "UKL.ReservoirAllocations" ["Inactive", "UKL"] ) )
 ELSE
  1.00000000
 ENDIF;

    END;

    FUNCTION       "UKLToIronGateNetAccretion" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "UKLToKenoNetAccretion"( startDate, endDate ) + "KenoToIronGateNetAccretion"( startDate, endDate );

    END;

    FUNCTION       "UKL_RecentFillRate" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 feet/day";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( date > @"Start Timestep + 5" )
 THEN
  ( $ "UKL.Pool Elevation" [date - 1.00000000 "day"] - $ "UKL.Pool Elevation" [date - 7.00000000 "day"] ) / ( 7.00000000 * 86400.00000000 "sec" )
 ELSE
  0.00000000 "m/s"
 ENDIF COMMENTED_BY "compute mean fill rate over past 7 days - ensure timestep>6";

    END;

    FUNCTION       "UKLToKenoNetAccretion" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "SumSlotSkipNaN"( $ "Lost River To Klamath River.Inflow2", startDate, endDate ) + "SumSlotSkipNaN"( $ "Lake Ewuana Gain.Local Inflow", startDate, endDate ) + "SumSlotSkipNaN"( $ "F and FF Pump.Outflow", startDate, endDate ) - ( "SumSlotSkipNaN"( $ "Miller Hill Pump.Outflow", startDate, endDate ) + "SumSlotSkipNaN"( $ "ProjectData.LostToArea2SpringSummer", startDate, endDate ) );

    END;

    FUNCTION       "UKLRampingLowerBound" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "ReservoirOperations.UKL To IGD IFR Pass Thru" [@"t"] - "IronGateMaxRamping"( @"t" );

    END;

  END;

  UTILITY_GROUP "AggDisagg Averaging Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AddNumericLists" ( LIST firstList, LIST secondList )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns lists of the sum of 2 lists.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( ( LENGTH firstList ) == 0.00000000 OR ( LENGTH firstList ) != LENGTH secondList )
 THEN
  {  }
 ELSE
  FOR ( NUMERIC index IN "MakeForLoopList"( LENGTH firstList ) ) WITH LIST result = {  } DO
   APPEND ( GET @INDEX index FROM firstList ) + GET @INDEX index FROM secondList ONTO result
  ENDFOR
 ENDIF;

    END;

    FUNCTION       "AddUpstreamStorage" ( LIST listOfReservoirs, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Add storages for requested timestep and list of reservoirs.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( OBJECT index IN listOfReservoirs ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + index & "Storage" [datetime]
 ENDFOR;

    END;

    FUNCTION       "AverageDailyFlowForVolume" ( NUMERIC volume, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes average daily flow given a volume and period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "VolumeToFlow"( volume * 1.00000000 "day" / ( "GetJulianDate"( endDate ) * 1.00000000 "day" - "GetJulianDate"( startDate ) * 1.00000000 "day" + 1.00000000 "day" ), @"t" );

    END;

    FUNCTION       "AverageMonthlyFlowForVolume" ( NUMERIC volume, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " acre-feet/month ";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetUnitlessDaysInMonth"( startDate ) * "VolumeToFlow"( volume * 1.00000000 "day" / ( "GetJulianDate"( endDate ) * 1.00000000 "day" - "GetJulianDate"( "BeginOfMonthDate"( startDate ) ) * 1.00000000 "day" + 1.00000000 "day" ), startDate );

    END;

    FUNCTION       "DailyAverageFlowDuringPeriod" ( NUMERIC timeStep, SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Compute average flow for a period and slot.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC numberDays = "GetNumberOfDays"( timeStep, startDate, endDate ) DO
  IF ( numberDays >= 1.00000000 )
  THEN
   "SumFlowsToVolumeSkipNaN"( slot, startDate, endDate ) / ( numberDays * 1.00000000 "day" )
  ELSE
   0.00000000 "cms"
  ENDIF
 ENDWITH;

    END;

    FUNCTION       "FlowFractionComputation" ( DATETIME dailyDateTime, DATETIME monthlyDateTime, SLOT dailySlot, SLOT monthlySlot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Computes daily flow fraction given daily flow and monthly flow.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( monthlySlot [monthlyDateTime] > 0.00000000 "cms" )
 THEN
  dailySlot [dailyDateTime] / monthlySlot [monthlyDateTime] * ( 1.00000000 "day" / "GetDaysInMonth"( monthlyDateTime ) )
 ELSE
  0.00000000 "cms"
 ENDIF;

    END;

    FUNCTION       "FlowFractionDisaggregation" ( DATETIME dailyDateTime, DATETIME monthlyDateTime, SLOT dailyFractionSlot, SLOT monthlySlot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes daily values as a fraction of monthly values.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      dailyFractionSlot [dailyDateTime] * ( monthlySlot [monthlyDateTime] * ( "GetDaysInMonth"( monthlyDateTime ) / 1.00000000 "day" ) );

    END;

    FUNCTION       "MonthlyVolumeFromMonthlyFlow" ( NUMERIC monthlyFlow, DATETIME dateTime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " acre-feet ";
    DESCRIPTION    "Computes monthly flow from monthly volume to deal with monthly data objects flows in a daily model.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "FlowToVolume"( monthlyFlow, dateTime ) * "GetUnitlessDaysInMonth"( dateTime );

    END;

    FUNCTION       "PeriodAverage" ( SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Computes Period Average - can replace this with palette Avg function.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH LIST values = "GetSlotVals"( slot, startDate, endDate ) DO
  "Sum"( values ) / LENGTH values
 ENDWITH;

    END;

    FUNCTION       "ProratedFlowDisaggregation" ( DATETIME dailyDateTime, DATETIME monthlyDateTime, SLOT dailyRefSlot, SLOT monthlyRefSlot, SLOT monthlyItemSlot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Disaggregates by proration of another slot's daily to monthly values.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( monthlyRefSlot [monthlyDateTime] > 0.00000000 "cms" )
 THEN
  dailyRefSlot [dailyDateTime] / monthlyRefSlot [monthlyDateTime] * monthlyItemSlot [monthlyDateTime]
 ELSE
  monthlyItemSlot [monthlyDateTime]
 ENDIF;

    END;

    FUNCTION       "SumDailyFlowsInListToVolume" ( LIST listToSum )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums daily flows in provided list to a volume.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      86400.00000000 "s" * "Sum"( listToSum );

    END;

    FUNCTION       "SumDailyFlowsInSlotToVolume" ( SLOT slotToSum, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums volume of a daily slot.  Intended to be used in monthly models.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      86400.00000000 "s" * "SumSlot"( slotToSum, startDate, endDate );

    END;

    FUNCTION       "SumFlowValueToVolume" ( DATETIME startDate, DATETIME endDate, NUMERIC valueToSum )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "Sum specified flow value to a volume for specified time period.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME dateTime IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( valueToSum, dateTime )
 ENDFOR;

    END;

    FUNCTION       "SumMonthlyFlowTableToVolume" ( OBJECT reservoir, SLOT objectSlot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums columns of months in a table slot to a volume for a specified period.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( objectSlot [STRINGIFY reservoir, "GetMonthAsString"( index )], index )
 ENDFOR;

    END;

    FUNCTION       "SumNegativeDailyFlowsInSlotToVolume" ( SLOT slotToSum, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums negative days flows to a volume.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN "GetDates"( startDate, endDate, "1 Days" ) ) WITH NUMERIC result = 0.00000000 "m3" DO
  IF ( slotToSum [index] < 0.00000000 "cms" )
  THEN
   result + 86400.00000000 "s" * slotToSum [index]
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "SumPeriodicFlowToVolume" ( SLOT slot, DATETIME startDate, DATETIME endDate, STRING column )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums a periodic slot flow to a volume for specified time period.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( slot [date, column], date )
 ENDFOR;

    END;

    FUNCTION       "SumTableFlowToVolume" ( SLOT objectSlot, DATETIME startDate, DATETIME endDate, STRING row, STRING column )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums a table slot flow to a volume for specified time period.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( objectSlot [row, column], date )
 ENDFOR;

    END;

    FUNCTION       "SumUpstreamStorage" ( OBJECT reservoir, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sum upstreams storages for requested timestep.  Subbasin name is specified as AboveReservoirReservoirs.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "AddUpstreamStorage"( "FilterByObjType"( "ListSubbasin"( "Above" CONCAT STRINGIFY reservoir CONCAT "Reservoirs" ), { "StorageReservoir" } ), datetime ) + "AddUpstreamStorage"( "FilterByObjType"( "ListSubbasin"( "Above" CONCAT STRINGIFY reservoir CONCAT "Reservoirs" ), { "SlopePowerReservoir" } ), datetime ) + "AddUpstreamStorage"( "FilterByObjType"( "ListSubbasin"( "Above" CONCAT STRINGIFY reservoir CONCAT "Reservoirs" ), { "LevelPowerReservoir" } ), datetime );

    END;

    FUNCTION       "SumVolumeWithNaNsToVolume" ( SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Sums a volume slot for specified period with NaNs allowed.  Can now use SumSlotSkipNaNs.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  IF ( IsNaN slot [index] )
  THEN
   result
  ELSE
   result + slot [index]
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "TimeRatedStorageDisaggregation" ( SLOT storageSlot, DATETIME dailyDateTime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Distributes a storage by time from starting value to ending value.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC previousStorage = storageSlot ["EndOfPreviousMonthDate"( dailyDateTime )] DO
  previousStorage + ( storageSlot ["EndOfMonthDate"( dailyDateTime )] - previousStorage ) * ( "GetDayOfMonth"( dailyDateTime ) / "GetDaysInMonth"( dailyDateTime ) )
 ENDWITH;

    END;

  END;

  UTILITY_GROUP "Datetime Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AprilThruJuly" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 March 31, Current Year" AND @"t" < @"24:00:00 August 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AprilThruJune" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 March 31, Current Year" AND @"t" < @"24:00:00 July 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AprilThruOctober" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 March 31, Current Year" AND @"t" < @"24:00:00 November 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AugustThruDecember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 July 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AugustThruOctober" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 July 31, Current Year" AND @"t" < @"24:00:00 November 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AugustThruNovember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 July 31, Current Year" AND @"t" < @"24:00:00 December 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "AnnualDatesInDecade" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      { @"24:00:00 December Max DayOfMonth, Current Year - 9 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 8 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 7 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 6 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 5 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 4 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 3 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 2 Year" , @"24:00:00 December Max DayOfMonth, Current Year - 1 Year" };

    END;

    FUNCTION       "BeginOfMonthDate" ( DATETIME dateTime )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns beginning of month date given a date.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "PreviousDate"( dateTime, @"Min DayOfMonth" );

    END;

    FUNCTION       "BigTimestep" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetTimestep"( @"t" ) > 2000000.00000000 "s" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DateIsBetween" ( DATETIME dateA, DATETIME dateB, DATETIME dateC )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Checks if dateA falls between dateB and dateC inclusively.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( dateC > dateB )
 THEN
  IF ( dateA > dateC )
  THEN
   FALSE
  ELSE
   IF ( dateA >= dateB )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDIF
 ELSE
  IF ( dateA > dateB )
  THEN
   FALSE
  ELSE
   IF ( dateA >= dateC )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDIF
 ENDIF;

    END;

    FUNCTION       "DecemberThruFebruary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" > @"24:00:00 November 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DecemberThruJune" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 July 1, Current Year" OR @"t" > @"24:00:00 November 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DecemberThruJuly" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 August 1, Current Year" OR @"t" > @"24:00:00 November 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DecemberThruMay" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 June 1, Current Year" OR @"t" > @"24:00:00 November 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DecisionDate" ( DATETIME datetime, SLOT slot, STRING column )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns true or false given a date, and slot and column of a periodic slot.  If<br>the date of the period slot has a 1, true; otherwise 0.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( slot [datetime, column] == 1.00000000 )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "DecisionPeriod" ( DATETIME datetime, SLOT slot )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines if date is in the period of a periodic slot.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH DATETIME startDate = "OffsetDate"( "GetMinDateInList"( "DatesInPeriod"( slot, datetime ) ), 24.00000000, "1 Hours" ) DO
  WITH DATETIME endDate = "OffsetDate"( "GetMaxDateInList"( "DatesInPeriod"( slot, datetime ) ), 24.00000000, "1 Hours" ) DO
   IF ( "DateIsBetween"( datetime, startDate, endDate ) )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "EndOfMonthDate" ( DATETIME dateTime )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns end of month date given date.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "NextDate"( dateTime, @"Max DayOfMonth" );

    END;

    FUNCTION       "EndOfPreviousMonthDate" ( DATETIME dateTime )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns date corresponding to last day of previous month.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "OffsetDate"( dateTime, "GetDayOfMonth"( dateTime ) / - 1.00000000 "day", "1 DAYS" );

    END;

    FUNCTION       "GetMaxDateInList" ( LIST listToMax )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN listToMax ) WITH DATETIME result = @"24:00:00 January 1, Start Year" DO
  IF ( "GetJulianDate"( index ) > "GetJulianDate"( result ) )
  THEN
   index
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "FillRateAdjustmentPeriod" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" > @"24:00:00 November 15, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "GetMinDateInList" ( LIST listToMin )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN listToMin ) WITH DATETIME result = @"24:00:00 December 31, Finish Year" DO
  IF ( "GetJulianDate"( index ) < "GetJulianDate"( result ) )
  THEN
   index
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetDailyDatesInMonth" ( DATETIME dateTime )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of dates in specified monthly datetime.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDates"( "BeginOfMonthDate"( dateTime ), "EndOfMonthDate"( dateTime ), "1 Days" );

    END;

    FUNCTION       "GetNumberOfPeriods" ( NUMERIC timeStep, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Returns number of periods between dates given dates and time step in seconds.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Div"( 86400.00000000 "sec" * ( "GetJulianDate"( endDate ) - "GetJulianDate"( startDate ) ), 1.00000000 "sec", timeStep, 1.00000000 "sec" ) + 1.00000000;

    END;

    FUNCTION       "GetNumberOfDays" ( NUMERIC timeStep, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Returns number of days in specfied period.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( timeStep > 2000000.00000000 "sec" )
 THEN
  "GetJulianDate"( endDate ) - "GetJulianDate"( startDate ) + "GetUnitlessDaysInMonth"( startDate )
 ELSE
  "GetJulianDate"( endDate ) - "GetJulianDate"( startDate ) + 1.00000000
 ENDIF;

    END;

    FUNCTION       "GetPreviousMonthAsString" ( DATETIME datetime )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetMonthAsString"( "OffsetDate"( datetime, - 1.00000000, "1 Months" ) );

    END;

    FUNCTION       "GetTimeStepAsString" (  )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns time step as a string in format that OffsetDate and GetDates functions require.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetTimestep"( @"t" ) > 3000000.00000000 "s" )
 THEN
  "1 Years"
 ELSE
  IF ( "GetTimestep"( @"t" ) > 2000000.00000000 "s" AND "GetTimestep"( @"t" ) < 3000000.00000000 "s" )
  THEN
   "1 Months"
  ELSE
   IF ( "GetTimestep"( @"t" ) == 604800.00000000 "s" )
   THEN
    "1 Weeks"
   ELSE
    IF ( "GetTimestep"( @"t" ) == 86400.00000000 "s" )
    THEN
     "1 Days"
    ELSE
     IF ( "GetTimestep"( @"t" ) == 43200.00000000 "s" )
     THEN
      "12 Hours"
     ELSE
      IF ( "GetTimestep"( @"t" ) == 21600.00000000 "s" )
      THEN
       "6 Hours"
      ELSE
       IF ( "GetTimestep"( @"t" ) == 3600.00000000 "s" )
       THEN
        "1 Hours"
       ELSE
        "1 Days"
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF;

    END;

    FUNCTION       "GetUnitlessDaysInMonth" ( DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " NONE ";
    DESCRIPTION    "Returns days in month as NONE units.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDaysInMonth"( datetime ) / 1.00000000 "day";

    END;

    FUNCTION       "GetUnitlessDayOfMonth" ( DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Returns day of month as NONE units<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDayOfMonth"( datetime ) / 1.00000000 "day";

    END;

    FUNCTION       "GetUnitlessDayOfYear" ( DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Returns unitless day of year.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDayOfYear"( datetime ) / 1.00000000 "day";

    END;

    FUNCTION       "JanuaryThruApril" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" <= @"24:00:00 April 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JanuaryThruMay" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" <= @"24:00:00 May 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JanuaryThruJuly" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" <= @"24:00:00 July 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JanuaryThruFebruary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" <= @"24:00:00 February Max DayOfMonth, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JanuaryThruMarch" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" <= @"24:00:00 March 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JulyThruOctober" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 June 30, Current Year" AND @"t" < @"24:00:00 November 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JulyThruSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 June 30, Current Year" AND @"t" < @"24:00:00 October 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JulyThruFebruary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" > @"24:00:00 June 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JulyThruNovember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 June 30, Current Year" AND @"t" < @"24:00:00 December 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JuneThruNovember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 May 31, Current Year" AND @"t" < @"24:00:00 December 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "JuneThruSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 May 31, Current Year" AND @"t" < @"24:00:00 October 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruApril" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 May 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruMay" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 June 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruJune" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 July 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruJuly" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 August 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MayThruSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 April 30, Current Year" AND @"t" < @"24:00:00 October 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 October 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MarchThruNovember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 February Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 December 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MayThruAugust" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 April 30, Current Year" AND @"t" < @"24:00:00 September 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MonthlyDatesInCurrentYear" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of monthly dates (last day of each month) in current year.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDates"( @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year", "1 Months" );

    END;

    FUNCTION       "MonthlyDatesInLastYear" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of end of month dates for the last 12 months.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDates"( "EndOfMonthDate"( "OffsetDate"( @"t", - 11.00000000, "1 Months" ) ), "EndOfMonthDate"( @"t" ), "1 Months" );

    END;

    FUNCTION       "MonthlyDatesInPreviousYear" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of monthly dates (last day of each month) in previous year.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetDates"( @"24:00:00 January 31, Previous Year", @"24:00:00 December 31, Previous Year", "1 Months" );

    END;

    FUNCTION       "MonthlyDatesInThisYear" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of end of month dates for the last 12 months including this month.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN "MakeForLoopList"( 12.00000000 ) ) WITH LIST result = {  } DO
  APPEND "OffsetDate"( @"t", index - 11.00000000, "1 Months" ) ONTO result
 ENDFOR;

    END;

    FUNCTION       "MonthlyTimeStep" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "GetTimestep"( @"t" ) > 2000000.00000000 "s" AND "GetTimestep"( @"t" ) < 3000000.00000000 "s" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "NovemberThruDecember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 October 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "NovemberThruFebruary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" > @"24:00:00 October 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "NovemberThruMarch" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 April 1, Current Year" OR @"t" > @"24:00:00 October 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "OctoberThruMarch" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 April 1, Current Year" OR @"t" > @"24:00:00 September 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "SeptemberThruApril" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 May 1, Current Year" OR @"t" > @"24:00:00 August 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "OctoberThruFebruary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" > @"24:00:00 September 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "SeptemberThruFebruary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" > @"24:00:00 August 31, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "OctoberThruDecember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 September 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "OctoberThruJune" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 July 1, Current Year" OR @"t" > @"24:00:00 September 30, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "OctoberThruNovember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" > @"24:00:00 September Max DayOfMonth, Current Year" AND @"t" < @"24:00:00 December 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "StringDay" ( NUMERIC day )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a string version of day of month given diminsionless day of month.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH LIST days = { "1" , "2" , "3" , "4" , "5" , "6" , "7" , "8" , "9" , "10" , "11" , "12" , "13" , "14" , "15" , "16" , "17" , "18" , "19" , "20" , "21" , "22" , "23" , "24" , "25" , "26" , "27" , "28" , "29" , "30" , "31" } DO
  GET @INDEX day - 1.00000000 FROM days
 ENDWITH;

    END;

    FUNCTION       "StringYear" ( NUMERIC numYear )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC firstDigit = "Floor"( numYear / 1000.00000000, 1.00000000 ) DO
  WITH NUMERIC secondDigit = "Floor"( "Mod"( numYear, 0.00000000, 1000.00000000, 0.00000000 ) / 100.00000000, 1.00000000 ) DO
   WITH NUMERIC thirdDigit = "Floor"( "Mod"( numYear, 0.00000000, 100.00000000, 0.00000000 ) / 10.00000000, 1.00000000 ) DO
    WITH NUMERIC fourthDigit = "Floor"( "Mod"( numYear, 0.00000000, 10.00000000, 0.00000000 ) / 1.00000000, 1.00000000 ) DO
     "StringDigit"( firstDigit ) CONCAT "StringDigit"( secondDigit ) CONCAT "StringDigit"( thirdDigit ) CONCAT "StringDigit"( fourthDigit )
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "Operations Period" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "NumberToDate"( $ "Dashboard Controls.Operation Start" [] ) <= @"t";

    END;

    FUNCTION       "Operations Period - 3" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "NumberToDate"( $ "Dashboard Controls.Operation Start" [] ) <= @"t + 3";

    END;

    FUNCTION       "WinterOps" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" < @"24:00:00 March 1, Current Year" OR @"t" >= @"24:00:00 October 1, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "FirstDayOfMonth" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" == @"Min DayOfMonth" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "Operation Start - 7" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "NumberToDate"( $ "Dashboard Controls.Operation Start" [] ) <= @"t + 7";

    END;

  END;

  UTILITY_GROUP "Generic Functions";
  DESCRIPTION   "Functions that support generic rule set.";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AcrePrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "AcreFeetPrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "AcreFeetPerMonthPrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet/month]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "BooleanPrint" ( BOOLEAN booleanToPrint )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      booleanToPrint;

    END;

    FUNCTION       "CFSPrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Dummy function to print a cfs value.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "CountLessThanValuesInPeriod" ( SLOT slot, NUMERIC threshold, STRING timeStep, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Counts the number of values less than a specified threshold in a period.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN "GetDates"( startDate, endDate, timeStep ) ) WITH NUMERIC result = 0.00000000 DO
  IF ( slot [index] < threshold )
  THEN
   result + 1.00000000
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "CountGreaterThanEqualValuesInPeriod" ( SLOT slot, NUMERIC threshold, STRING timeStep, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Counts the number of values greater than or equal a specified threshold in a period.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN "GetDates"( startDate, endDate, timeStep ) ) WITH NUMERIC result = 0.00000000 DO
  IF ( slot [index] >= threshold )
  THEN
   result + 1.00000000
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "DatePrint" ( DATETIME datetime )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      datetime;

    END;

    FUNCTION       "DayPrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[day]";
    DESCRIPTION    "Prints a time period value as number of days.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "DaysToNone" ( NUMERIC duration )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Returns unitless days for a time period.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      duration / 1.00000000 "24 hr";

    END;

    FUNCTION       "EveryDayFullFlowMonth" ( SLOT slotToTest, DATETIME monthlyDateTime )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines if a month is a full flow month.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "CountGreaterThanEqualValuesInPeriod"( slotToTest, 0.00000000 "cms", "GetTimeStepAsString"(  ), "BeginOfMonthDate"( monthlyDateTime ), "EndOfMonthDate"( monthlyDateTime ) ) >= "GetUnitlessDaysInMonth"( monthlyDateTime ) )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "FeetPrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[feet]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "FlowInElevationRange" ( OBJECT reservoir, NUMERIC elev1, NUMERIC elev2, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs]";
    DESCRIPTION    "Computes flow from a change in elevation.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "cms", "VolumeToFlow"( "Abs"( "ElevationToStorage"( reservoir, elev1 ) - "ElevationToStorage"( reservoir, elev2 ) ), datetime ) );

    END;

    FUNCTION       "FlowIsBetween" ( NUMERIC flowA, NUMERIC flowB, NUMERIC flowC )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Checks if flowA falls between flowB and flowC inclusively.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( flowC > flowB )
 THEN
  IF ( flowA > flowC )
  THEN
   FALSE
  ELSE
   IF ( flowA >= flowB )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDIF
 ELSE
  IF ( flowA > flowB )
  THEN
   FALSE
  ELSE
   IF ( flowA >= flowC )
   THEN
    TRUE
   ELSE
    FALSE
   ENDIF
  ENDIF
 ENDIF;

    END;

    FUNCTION       "FullFlowMonth" ( SLOT slotToTest, DATETIME monthlyDateTime )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetMonth"( monthlyDateTime ) < 8.00000000 )
 THEN
  IF ( slotToTest ["OffsetDate"( monthlyDateTime, - 1.00000000, "1 MONTHS" ) + 1.00000000 "day"] > 0.00000000 "cms" )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF
 ELSE
  IF ( slotToTest [monthlyDateTime] > 0.00000000 "cms" )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF
 ENDIF;

    END;

    FUNCTION       "GetChangeInReservoirStorage" ( LIST reservoirs )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Takes a list of reservoirs and sums the change in storages";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( OBJECT index IN reservoirs ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + ( index & "Storage" [] - index & "Storage" [@"t - 1"] )
 ENDFOR;

    END;

    FUNCTION       "GetElementOfFlows" ( LIST flowList, NUMERIC flowToMatch )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Get element at requested flow.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN "MakeForLoopList"( LENGTH flowList ) ) WITH NUMERIC result = - 1.00000000 DO
  IF ( result == - 1.00000000 )
  THEN
   IF ( "Abs"( ( GET @INDEX index FROM flowList ) - flowToMatch ) < 0.00000001 "cms" )
   THEN
    index
   ELSE
    result
   ENDIF
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetElementOfVolumes" ( LIST volumeList, NUMERIC volumeToMatch )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Gets element at requested volume.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN "MakeForLoopList"( LENGTH volumeList ) ) WITH NUMERIC result = - 1.00000000 DO
  IF ( result == - 1.00000000 )
  THEN
   IF ( "Abs"( ( GET @INDEX index FROM volumeList ) - volumeToMatch ) < 0.00000001 "m3" )
   THEN
    index
   ELSE
    result
   ENDIF
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMaxFlowInList" ( LIST listToMax )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listToMax ) WITH NUMERIC result = 0.00000000 "cms" DO
  IF ( IsNaN index )
  THEN
   result
  ELSE
   "Max"( result, index )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMaxFlowInPeriod" ( SLOT slotToUse, LIST datesToUse )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes maximum flow during specified period.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN datesToUse ) WITH NUMERIC result = - 99999999999999.00000000 "cms" DO
  IF ( IsNaN slotToUse [index] )
  THEN
   result
  ELSE
   "Max"( result, slotToUse [index] )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMaxVolumeInList" ( LIST listToMax )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listToMax ) WITH NUMERIC result = 0.00000000 "m3" DO
  IF ( IsNaN index )
  THEN
   result
  ELSE
   "Max"( result, index )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMeanArea" ( OBJECT reservoir, NUMERIC startStorage, NUMERIC endStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 [acre]";
    DESCRIPTION    "Computes mean surface area for 2 storage values.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      ( "StorageToArea"( reservoir, startStorage ) + "StorageToArea"( reservoir, endStorage ) ) * 0.50000000;

    END;

    FUNCTION       "GetMinFlowInList" ( LIST listToMin )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listToMin ) WITH NUMERIC result = 99999999999999.00000000 "cms" DO
  IF ( IsNaN index )
  THEN
   result
  ELSE
   "Min"( result, index )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMinFlowInPeriod" ( SLOT slotToUse, LIST datesToUse )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes minimum flow in a period.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN datesToUse ) WITH NUMERIC result = 99999999999999.00000000 "cms" DO
  IF ( IsNaN slotToUse [index] )
  THEN
   result
  ELSE
   "Min"( result, slotToUse [index] )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "GetMinVolumeInList" ( LIST listToMin )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listToMin ) WITH NUMERIC result = 99999999999999.00000000 "m3" DO
  IF ( IsNaN index )
  THEN
   result
  ELSE
   "Min"( result, index )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "MaximumExists" ( NUMERIC threshold, SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns true if threshold value was exceed in period.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "PeriodMaximum"( slot, startDate, endDate ) > threshold )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MaxOutflowAtStorageOfRequestedFlow" ( OBJECT reservoir, NUMERIC request )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Given a flow, compute max q at storage of flow.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "GetMaxOutflowGivenStorage"( reservoir, "SolveStorage"( reservoir, reservoir & "Inflow" [], request, "PreviousStorage"( reservoir ), @"t" ), @"t" );

    END;

    FUNCTION       "MaxTwoItems" ( LIST list )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns maximum two items in a list.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC max1 = "MaxItem"( list ) DO
  WITH NUMERIC elem1 = FIND max1 WITHIN list DO
   WITH NUMERIC max2 = "MaxItem"( REMOVE ITEM @INDEX elem1 FROM list ) DO
    { max1 , max2 }
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "MeanPoolElevation" ( OBJECT reservoir, NUMERIC outflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Computes mean pool elevation given reservoir and a tenative outflow,<br>taking mean between previous storage and new storage at outflow.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      ( "StorageToElevation"( reservoir, "SolveStorage"( reservoir, reservoir & "Inflow" [], outflow, "PreviousStorage"( reservoir ), @"t" ) ) + "StorageToElevation"( reservoir, "PreviousStorage"( reservoir ) ) ) * 0.50000000;

    END;

    FUNCTION       "MinimumExists" ( NUMERIC threshold, SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns true if period minimum is less than threshold value.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "PeriodMinimum"( slot, startDate, endDate ) < threshold )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MinTwoItems" ( LIST list )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns minimum two items in a list.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC min1 = "MinItem"( list ) DO
  WITH NUMERIC elem1 = FIND min1 WITHIN list DO
   WITH NUMERIC min2 = "MinItem"( REMOVE ITEM @INDEX elem1 FROM list ) DO
    { min1 , min2 }
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "NonePrint" ( NUMERIC valueToPrint )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[NONE]";
    DESCRIPTION    "Prints a value with NONE units.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      valueToPrint;

    END;

    FUNCTION       "PeriodMaximum" ( SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Computes maximum in period.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "MaxItem"( "GetSlotVals"( slot, startDate, endDate ) );

    END;

    FUNCTION       "PeriodMinimum" ( SLOT slot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Computes Period Minimum";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "MinItem"( "GetSlotVals"( slot, startDate, endDate ) );

    END;

    FUNCTION       "PreviousElevation" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[feet]";
    DESCRIPTION    "Returns previous elevation of reservoir.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      reservoir & "Pool Elevation" [@"t - 1"];

    END;

    FUNCTION       "PreviousStorage" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Returns previous storage of reservoir.<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      reservoir & "Storage" [@"t - 1"];

    END;

    FUNCTION       "RegSpillwayCapacityCheck" ( OBJECT reservoir, NUMERIC request )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes max capacity of all outflow points when no unregulated spillway is involved.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "MonthlyTimeStep"(  ) )
 THEN
  request
 ELSE
  "Min"( request, "GetMaxOutflowGivenInflow"( reservoir, reservoir & "Inflow" [], @"t" ) )
 ENDIF;

    END;

    FUNCTION       "StringDigit" ( NUMERIC digit )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a string given a one digit number.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( digit > 9.00000000 )
 THEN
  ( STRINGIFY digit ) CONCAT "is invalid"
 ELSE
  WITH LIST values = { "0" , "1" , "2" , "3" , "4" , "5" , "6" , "7" , "8" , "9" } DO
   GET @INDEX digit FROM values
  ENDWITH
 ENDIF;

    END;

    FUNCTION       "StringPrint" ( STRING stringToPrint )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      stringToPrint;

    END;

    FUNCTION       "UnregSpillwayCapacityCheck" ( OBJECT reservoir, NUMERIC request )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  cfs";
    DESCRIPTION    "Checks a tenative outflow against outlet works and spillway capacities. <br>Also determines if we have to spill thru unregulated spillway.<br>Assumes that monthly spill calc is used for monthly time steps.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Min"( "GetMaxOutflowGivenInflow"( reservoir, reservoir & "Inflow" [], @"t" ), WITH NUMERIC release = "Min"( request, "GetMaxReleaseGivenInflow"( reservoir, reservoir & "Inflow" [], @"t" ) COMMENTED_BY "GetMaxReleaseGivenInflow is only Turbine or Outlet Works" ) DO
  release + "GetMinSpillGivenInflowRelease"( reservoir, reservoir & "Inflow" [], release, @"t" )
 ENDWITH );

    END;

  END;

  UTILITY_GROUP "List Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "FindFlowGivenDateFromLists" ( DATETIME date, LIST flowsList, LIST datesList )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Returns flow for given date from a lists of flows and dates.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC element = FIND date WITHIN datesList DO
  GET @INDEX element FROM flowsList
 ENDWITH;

    END;

    FUNCTION       "InsertValueDateSetIntoList" ( NUMERIC flow, DATETIME date )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Inserts a value and date set into a list of flows and dates.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      INSERT flow INTO INSERT date INTO {  };

    END;

    FUNCTION       "InsertDateValueSetIntoList" ( DATETIME date, NUMERIC value )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Inserts a date and value set into a list of flows and dates.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      INSERT date INTO INSERT value INTO {  };

    END;

    FUNCTION       "InsertFlowDateSetIntoList" ( NUMERIC flow, DATETIME date )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Inserts a flow and date set into a list of flows and dates.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      INSERT flow INTO INSERT date INTO {  };

    END;

    FUNCTION       "InsertSlotValueSetIntoList" ( SLOT slot, NUMERIC value )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Inserts specified slot and value into a list.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      INSERT slot INTO INSERT value INTO {  };

    END;

    FUNCTION       "MakeListFromValueAndDates" ( NUMERIC dailyValue, LIST datesToUse )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Makes a list of daily flows for a month given monthly flow.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN datesToUse ) WITH LIST result = {  } DO
  APPEND dailyValue ONTO result
 ENDFOR;

    END;

    FUNCTION       "MakeForLoopList" ( NUMERIC numberIndices )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Makes a list of indeces for use in a For Loop.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WHILE ( ( GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) < numberIndices - 1.00000000 ) WITH LIST result = { 0.00000000 } DO
  APPEND ( GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) + 1.00000000 ONTO result
 ENDWHILE;

    END;

    FUNCTION       "MakeIncrementalListGivenInitIncrMax" ( NUMERIC initial, NUMERIC increment, NUMERIC maximum )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Creates a list given an initial value, an inrement, and a maximum.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WHILE ( ( GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) + increment <= maximum ) WITH LIST result = { initial } DO
  APPEND ( GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) + increment ONTO result
 ENDWHILE;

    END;

    FUNCTION       "MakeIncrementalListGivenInitIncrPoints" ( NUMERIC initial, NUMERIC increment, NUMERIC numberPoints )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Creates a list of values given an inital value, an incremental value, and number of points.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN "MakeForLoopList"( numberPoints ) ) WITH LIST result = {  } DO
  IF ( index == 0.00000000 )
  THEN
   APPEND initial ONTO result
  ELSE
   APPEND increment + GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ONTO result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "MakeListGivenValuePoints" ( NUMERIC valueToList, NUMERIC numberPoints )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Make a list of values for a given value and number of points.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN "MakeForLoopList"( numberPoints ) ) WITH LIST result = {  } DO
  APPEND valueToList ONTO result
 ENDFOR;

    END;

    FUNCTION       "MakeListOfDatesAndValues" ( LIST values, LIST dates )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of dates and values.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST listOfDays = "GetNumbers"( 0.00000000, ( LENGTH dates ) - 1.00000000, 1.00000000 ) DO
  FOR ( NUMERIC index IN listOfDays ) WITH LIST result = {  } DO
   INSERT "InsertDateValueSetIntoList"( GET @INDEX index FROM dates, GET @INDEX index FROM values ) INTO result
  ENDFOR
 ENDWITH;

    END;

    FUNCTION       "MakeListOfValuesAndDates" ( LIST flows, LIST dates, LIST listOfDays )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of values and dates.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listOfDays ) WITH LIST result = {  } DO
  INSERT "InsertValueDateSetIntoList"( GET @INDEX index FROM flows, GET @INDEX index FROM dates ) INTO result
 ENDFOR;

    END;

    FUNCTION       "MakeListOfFlowsAndDates" ( LIST flows, LIST dates, LIST listOfDays )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a list of values and dates.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN listOfDays ) WITH LIST result = {  } DO
  INSERT "InsertFlowDateSetIntoList"( GET @INDEX index FROM flows, GET @INDEX index FROM dates ) INTO result
 ENDFOR;

    END;

    FUNCTION       "MakeListOfSlotsAndValues" ( LIST slotsList, LIST valuesList, LIST numberInList )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Makes a list of lists of slots and values<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC index IN numberInList ) WITH LIST result = {  } DO
  INSERT "InsertSlotValueSetIntoList"( GET @INDEX index FROM slotsList, GET @INDEX index FROM valuesList ) INTO result
 ENDFOR;

    END;

    FUNCTION       "ProportionDailyFlowList" ( NUMERIC ratio, SLOT slot )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Proportions a list of daily flow values by user provided ratio.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME index IN "GetDates"( @"t - 1" + 1.00000000 "day", @"t", "1 Days" ) ) WITH LIST result = {  } DO
  APPEND slot [index] * ratio ONTO result
 ENDFOR;

    END;

    FUNCTION       "SubsetNumericList" ( LIST listToSubset, NUMERIC firstIndex, NUMERIC lastIndex )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Subsets a list for specified first and last indices.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( lastIndex < 0.00000000 OR firstIndex < 0.00000000 )
 THEN
  {  }
 ELSE
  FOR ( NUMERIC index IN "MakeForLoopList"( LENGTH listToSubset ) ) WITH LIST result = {  } DO
   IF ( index >= firstIndex AND index <= lastIndex )
   THEN
    APPEND GET @INDEX index FROM listToSubset ONTO result
   ELSE
    result
   ENDIF
  ENDFOR
 ENDIF;

    END;

    FUNCTION       "SubtractNumericLists" ( LIST firstList, LIST secondList )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a numeric list after subtracting 2 lists.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( ( LENGTH firstList ) == 0.00000000 OR ( LENGTH firstList ) != LENGTH secondList )
 THEN
  {  }
 ELSE
  FOR ( NUMERIC index IN "MakeForLoopList"( LENGTH firstList ) ) WITH LIST result = {  } DO
   APPEND ( GET @INDEX index FROM firstList ) - GET @INDEX index FROM secondList ONTO result
  ENDFOR
 ENDIF;

    END;

  END;

  UTILITY_GROUP "Operation Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "ComputeAvailableSpace" ( OBJECT reservoir, STRING column, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "ElevationToStorage"( reservoir, $ "ReservoirOperations.TargetElevation" [datetime, column] ) - reservoir & "Storage" [@"t - 1"];

    END;

    FUNCTION       "DailyFloodControlRelease" ( OBJECT reservoir, STRING column, DATETIME endDate, NUMERIC maxRelease, NUMERIC forecastVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "Computes flood control release for a daily time step as function of today's maximum storage<br>and today's flood control storage.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC fcStorage = "DailyFloodControlStorage"( reservoir, column, endDate, maxRelease, forecastVolume ) DO
  WITH NUMERIC fcRelease = "Max"( 0.00000000 "cms", "SolveOutflow"( reservoir, reservoir & "Inflow" [], fcStorage, reservoir & "Storage" [@"t - 1"], @"t" ) ) DO
   IF ( fcRelease > maxRelease )
   THEN
    WITH NUMERIC maxRelStorage = "Max"( 0.00000000 "m3", "SolveStorage"( reservoir, reservoir & "Inflow" [], maxRelease, reservoir & "Storage" [@"t - 1"], @"t" ) ) DO
     WITH NUMERIC maxStorage = "ElevationToStorage"( reservoir, $ "Clear.MaxElevation" ["@t", "MaxElevation"] ) DO
      IF ( maxRelStorage > maxStorage )
      THEN
       "Max"( 0.00000000 "cms", "SolveOutflow"( reservoir, reservoir & "Inflow" [], maxStorage, reservoir & "Storage" [@"t - 1"], @"t" ) )
      ELSE
       maxRelease
      ENDIF
     ENDWITH
    ENDWITH
   ELSE
    fcRelease
   ENDIF
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "DailyFloodControlStorage" ( OBJECT reservoir, STRING column, DATETIME endDate, NUMERIC maxRelease, NUMERIC forecastVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Computes maximum storage that we can be at today given a forecast thru endDate<br>and the maximum daily release (maxRelease).";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC maxEOPContent = "DailyMaximumStorage"( reservoir, column, endDate ) DO
  WITH NUMERIC maxPeriodRelease = "SumFlowValueToVolume"( "DateMin"( @"t + 1", endDate ), endDate, maxRelease ) DO
   "Max"( "DailyMinimumStorage"( reservoir, column, @"t" ), "Min"( maxEOPContent - forecastVolume + maxPeriodRelease, "DailyMaximumStorage"( reservoir, column, @"t" ) ) )
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "DailyMaximumStorage" ( OBJECT reservoir, NUMERIC ResMaxElevSlot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Computes daily maximum storage as a function of daily maximum elevation.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "ElevationToStorage"( reservoir, ResMaxElevSlot );

    END;

    FUNCTION       "DailyMaximumStorageRelease" ( OBJECT reservoir, STRING column, DATETIME datetime, NUMERIC prevStorage, NUMERIC inflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( datetime < @"Start Timestep" )
 THEN
  0.00000000 "cms"
 ELSE
  "Max"( "SolveOutflow"( reservoir, inflow, "DailyMaximumStorage"( reservoir, column, datetime ), prevStorage, datetime ), 0.00000000 "cms" )
 ENDIF;

    END;

    FUNCTION       "DailyMinimumStorage" ( OBJECT reservoir, NUMERIC ResMinElevSlot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Computes daily minimum storage as a function of daily minimum elevation";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "ElevationToStorage"( reservoir, ResMinElevSlot );

    END;

    FUNCTION       "DailyMinimumStorageRelease" ( OBJECT reservoir, STRING column, DATETIME datetime, NUMERIC prevStorage, NUMERIC inflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( datetime < @"Start Timestep" )
 THEN
  0.00000000 "cms"
 ELSE
  "Max"( "SolveOutflow"( reservoir, inflow, "DailyMinimumStorage"( reservoir, column, datetime ), prevStorage, datetime ), 0.00000000 "cms" )
 ENDIF;

    END;

    FUNCTION       "DailyTargetStorage" ( OBJECT reservoir, STRING column, DATETIME datetime )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Computes daily target storage as a function of daily target elevation.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "ElevationToStorage"( reservoir, $ "ReservoirOperations.TargetElevation" [datetime, column] );

    END;

    FUNCTION       "DailyTargetStorageRelease" ( OBJECT reservoir, STRING column, DATETIME datetime, NUMERIC prevStorage, NUMERIC inflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( "SolveOutflow"( reservoir, inflow, "DailyTargetStorage"( reservoir, column, datetime ), prevStorage, datetime ), 0.00000000 "cms" );

    END;

    FUNCTION       "EstimateEvaporation" ( OBJECT reservoir, NUMERIC meanArea, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "Estimates furture reservoir evaporation form startDate (usually current time step)<br>thru endDate.  Additional argument of meanArea is estimated average surface<br>area during interval.<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "m3" DO
  result + "FlowToVolume"( ( reservoir & "Evaporation Rate" [date] - reservoir & "Precipitation Rate" [date] ) * meanArea, date )
 ENDFOR;

    END;

    FUNCTION       "EstimatedInflowForecast" ( SLOT forecastSlot, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC inflowNoError = "SumFlowsToVolume"( forecastSlot, startDate, endDate ) DO
  inflowNoError
 ENDWITH;

    END;

    FUNCTION       "MaxMinElevationCheck" ( OBJECT reservoir, STRING column, NUMERIC request )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1 cfs";
    DESCRIPTION    "Checks for maximum and minimum elevation constraints expressed in table <br>ReservoirData.MinElevation and ReservoirData.MaxElevation.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( "DailyMaximumStorageRelease"( reservoir, column, @"t", reservoir & "Storage" [@"t - 1"], reservoir & "Inflow" [] ), "Min"( "DailyMinimumStorageRelease"( reservoir, column, @"t", reservoir & "Storage" [@"t - 1"], reservoir & "Inflow" [] ), request ) );

    END;

    FUNCTION       "SurplusVolumeBySlotNoEvap" ( OBJECT reservoir, STRING column, SLOT forecastSlot, DATETIME startDate, DATETIME endDate, SLOT ResAvgRelease )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1  acre-feet ";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "m3", "SumFlowsToVolumeSkipNaN"( forecastSlot, startDate, endDate ) - ( "ComputeAvailableSpace"( reservoir, column, startDate ) + "SumPeriodicFlowToVolume"( ResAvgRelease, startDate, endDate, STRINGIFY reservoir ) ) );

    END;

    FUNCTION       "SurplusVolumeBySlot" ( OBJECT reservoir, STRING column, SLOT forecastSlot, DATETIME startDate, DATETIME endDate, SLOT ResAvgRelease )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    " acre-feet ";
    DESCRIPTION    "Computes surplus volume for a reservoir by slot with no forecast error applied.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "m3", "SumFlowsToVolume"( forecastSlot, startDate, endDate ) - ( "ComputeAvailableSpace"( reservoir, column, endDate ) + ( "SumPeriodicFlowToVolume"( ResAvgRelease, @"t", endDate, column ) + "EstimateEvaporation"( reservoir, "GetMeanArea"( reservoir, "PreviousStorage"( reservoir ), "DailyTargetStorage"( reservoir, column, endDate ) ), startDate, endDate ) ) ) );

    END;

    FUNCTION       "SurplusVolumeBySlotWithLosses" ( OBJECT reservoir, STRING column, SLOT inflow, NUMERIC anticipatedLoss, DATETIME startDate, DATETIME endDate, SLOT ResAvgRelease )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "Computes surplus volume from inflows less depletions stored in specified slot.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( 0.00000000 "m3", "SumFlowsToVolume"( inflow, startDate, endDate ) - ( "ComputeAvailableSpace"( reservoir, column, endDate ) + ( "SumPeriodicFlowToVolume"( ResAvgRelease, @"t", endDate, column ) + ( "EstimateEvaporation"( reservoir, "GetMeanArea"( reservoir, "PreviousStorage"( reservoir ), "DailyTargetStorage"( reservoir, column, endDate ) ), startDate, endDate ) + anticipatedLoss ) ) ) );

    END;

    FUNCTION       "Reservoir Outflow at Drawdown to Rule Curve" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Calculates the outflow to drawdown the reservoir to the rule curve storage in one timestep.  The argument is the reservoir object.<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( "SolveOutflow"( reservoir, reservoir & "Inflow" [], $ "Clear.TargetElevation" [@"t - 1", "TargetElevation"], reservoir & "Storage" [@"t - 1"], @"t" ), 0.00000000 "cfs" );

    END;

  END;

  UTILITY_GROUP "HypSimFunctions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "CreateListOfProjectedInAndOut" ( DATETIME endDate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN @"t" TO endDate ) WITH LIST result = {  } DO
  APPEND { $ "UKL.Outflow" , $ "UKL.Outflow" [@"t - 1"] , date } ONTO result
 ENDFOR SET_UNION FOR ( DATETIME date IN @"t" TO endDate ) WITH LIST result = {  } DO
  APPEND { $ "UKL.Diversion" , $ "UKL.Diversion" [@"t - 1"] , date } ONTO result
 ENDFOR;

    END;

    FUNCTION       "ListOfProjectedPE" ( DATETIME endDate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN @"t" TO endDate ) WITH LIST result = {  } DO
  APPEND { $ "UKL.Pool Elevation" , date } ONTO result
 ENDFOR;

    END;

  END;

  UTILITY_GROUP "General Reservoir Operational Definitions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "Contract Season" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      @"t" >= @"May" AND @"t" <= @"October";

    END;

    FUNCTION       "Winter" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      @"t" <= @"March" OR @"t" >= @"November";

    END;

    FUNCTION       "Reservoir Minimum Release" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function gets the minimum release for a reservoir from its minimum release slot on the reservoir data object.<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "GetObject"( ( STRINGIFY res ) CONCAT " Data" ) & "Minimum Release" [];

    END;

    FUNCTION       "Reservoir Maximum Outflow" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function gets the minimum release for a reservoir from its minimum release slot on the reservoir data object.<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "GetMaxOutflowGivenInflow"( res, res & "Inflow" [], @"t" );

    END;

    FUNCTION       "Reservoir Outflow at Maximum Stage Drawdown Rate" ( OBJECT res, NUMERIC drawdown )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "VolumeToFlow"( res & "Storage" [@"t - 1"] - "ElevationToStorage"( res, res & "Pool Elevation" [@"t - 1"] - drawdown ), @"t" );

    END;

    FUNCTION       "Spring" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      @"t" >= @"March" AND @"t" <= @"June";

    END;

    FUNCTION       "Reservoir Outflow at Drawdown to Minimum Pool" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( "SolveOutflow"( res, res & "Inflow" [], "DataObject"( res ) & "Minimum Storage" [], res & "Storage" [@"t - 1"], @"t" ), 0.00000000 "cfs" );

    END;

    FUNCTION       "Reservoir Inflow to Fill to Max Pool" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( "SolveInflow"( res, res & "Inflow" [], "DataObject"( res ) & "Maximum Storage" [], res & "Storage" [@"t - 1"], @"t" ), 0.00000000 "cfs" );

    END;

    FUNCTION       "Reservoir Inflow to Fill to Max Pool Frances" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( "SolveInflow"( res, res & "Inflow" [@"t - 1"], "DataObject"( res ) & "Maximum Storage" [], res & "Storage" [@"t - 1"], @"t" ), 0.00000000 "cfs" );

    END;

    FUNCTION       "Flood Control Allocation" ( OBJECT res, NUMERIC PercentNormal, DATETIME Date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function gets the minimum release for a reservoir from its minimum release slot on the reservoir data object.<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "DataObject"( res ) & "SRD" [Date, PercentNormal];

    END;

    FUNCTION       "Water Year" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns the water year of the current date";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" >= @"October 1" )
 THEN
  "CompletePartialDate"( @"December 31", "OffsetDate"( @"t", 1.00000000, "1 years" ) )
 ELSE
  "CompletePartialDate"( @"December 31", @"t" )
 ENDIF;

    END;

    FUNCTION       "Irrigation Season" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      @"t" >= @"May" AND @"t" <= @"October 15";

    END;

    FUNCTION       "Reservoir Drawdown to Elevation With Diversion" ( OBJECT res, SLOT InflowSlot, SLOT ResDivSlot, DATETIME StartDate, DATETIME EndDate, NUMERIC TargetElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Calculates the drawdown to a specified target elevation as a constant flow rate.  It assumes the current outflow is the value in the dec 31 table.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC StorageStart = res & "Storage" [@"t - 1"] DO
  WITH NUMERIC InflowVolume = "SumFlowsToVolume"( InflowSlot, StartDate, EndDate ) COMMENTED_BY "Sum inflows to a volume over period" DO
   WITH NUMERIC EvapVolume = "FlowToVolume"( ( "ElevationToArea"( res, res & "Pool Elevation" [@"t - 1"] ) + "ElevationToArea"( res, TargetElev ) ) / 2.00000000 * "SumSlot"( res & "Evaporation Rate", StartDate, EndDate ), @"t" ) COMMENTED_BY "Predict evaporation volume as the product of the mean of yesterday's area and <br>the target area and evap rate." DO
    WITH NUMERIC DiversionVolume = "SumFlowsToVolume"( ResDivSlot, StartDate, EndDate ) DO
     WITH NUMERIC TargetVolume = "ElevationToStorage"( res, TargetElev ) DO
      ( StorageStart + InflowVolume - EvapVolume - DiversionVolume - TargetVolume ) COMMENTED_BY "The volume to drawdown is the starting volume plus the inflow volume minus <br>the evap and diversion volume, minus target volume." / ( ( EndDate - StartDate ) + 1.00000000 "day" )
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "Reservoir Fill to Elevation with Diversion" ( OBJECT res, SLOT InflowSlot, SLOT ResDivSlot, DATETIME StartDate, DATETIME EndDate, NUMERIC TargetElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Calculates the drawdown to a specified target elevation as a constant flow rate.  It assumes the current outflow is the value in the dec 31 table.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC StorageStart = res & "Storage" [@"t - 1"] DO
  WITH NUMERIC InflowVolume = "SumFlowsToVolume"( InflowSlot, StartDate, EndDate ) COMMENTED_BY "sum inflow volumes over the period<br>" DO
   WITH NUMERIC EvapVolume = "FlowToVolume"( ( "ElevationToArea"( res, res & "Pool Elevation" [@"t - 1"] ) + "ElevationToArea"( res, TargetElev ) ) / 2.00000000 * "SumSlot"( res & "Evaporation Rate", StartDate, EndDate ), @"t" ) COMMENTED_BY "Predict evaporation volume as the product of the mean of yesterday's area and <br>the target area and evap rate." DO
    WITH NUMERIC DiversionVolume = "SumFlowsToVolume"( ResDivSlot, StartDate, EndDate ) DO
     WITH NUMERIC TargetVolume = "ElevationToStorage"( res, TargetElev ) DO
      "Max"( InflowVolume - ( TargetVolume - StorageStart + DiversionVolume + EvapVolume ) COMMENTED_BY "Delta Storage over time period is the volume to fill<br>", 0.00000000 "acre-feet" ) COMMENTED_BY "Excess volume is the inflow volume minus delta storage<br>" / ( ( EndDate - StartDate ) + 1.00000000 "day" ) COMMENTED_BY "Divide by the number of days to calculate a constant flow rate over the period."
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "Pool Elevation Forecast" ( OBJECT res, SLOT InflowSlot, NUMERIC ReleaseRate, SLOT ResDivSlot, DATETIME StartDate, DATETIME EndDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC StorageStart = res & "Storage" [@"t - 1"] DO
  WITH NUMERIC InflowVolume = "SumFlowsToVolume"( InflowSlot, StartDate, EndDate ) DO
   WITH NUMERIC EvapVolume = "FlowToVolume"( "ElevationToArea"( res, res & "Pool Elevation" [@"t - 1"] ) * "SumSlot"( res & "Evaporation Rate", StartDate, EndDate ), @"t" ) DO
    WITH NUMERIC DiversionVolume = "SumFlowsToVolume"( ResDivSlot, StartDate, EndDate ) DO
     WITH NUMERIC ReleaseVolume = ReleaseRate * ( EndDate - StartDate ) DO
      "StorageToElevation"( res, StorageStart + InflowVolume - EvapVolume - DiversionVolume - ReleaseVolume )
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "Reservoir Fill to Elevation" ( OBJECT res, SLOT InflowSlot, DATETIME StartDate, DATETIME EndDate, NUMERIC TargetElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Calculates the drawdown to a specified target elevation as a constant flow rate.  It assumes the current outflow is the value in the dec 31 table.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC StorageStart = res & "Storage" [@"t - 1"] DO
  WITH NUMERIC InflowVolume = "SumFlowsToVolume"( InflowSlot, StartDate, EndDate ) COMMENTED_BY "sum inflow volumes over the period<br>" DO
   WITH NUMERIC EvapVolume = "FlowToVolume"( ( "ElevationToArea"( res, res & "Pool Elevation" [@"t - 1"] ) + "ElevationToArea"( res, TargetElev ) ) / 2.00000000 * "SumSlot"( res & "Evaporation Rate", StartDate, EndDate ), "NumberToDate"( EndDate - StartDate ) ) COMMENTED_BY "Predict evaporation volume as the product of the mean of yesterday's area and <br>the target area and evap rate." DO
    WITH NUMERIC TargetVolume = "ElevationToStorage"( res, TargetElev ) DO
     "Max"( InflowVolume - ( TargetVolume - StorageStart + EvapVolume ) COMMENTED_BY "Delta Storage over time period is the volume to fill<br>", 0.00000000 "acre-feet" ) COMMENTED_BY "Excess volume is the inflow volume minus delta storage<br>" / ( EndDate - StartDate ) COMMENTED_BY "Divide by the number of days to calculate a constant flow rate over the period."
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "EndOfMonth" ( DATETIME Date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "PreviousDate"( "OffsetDate"( Date, 1.00000000, "1 months" ), @"Max DayOfMonth" );

    END;

    FUNCTION       "BeginningOfMonth" ( DATETIME Date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "PreviousDate"( Date, @"Min DayOfMonth" );

    END;

  END;

  PREDEFINED_GROUP "Numeric / Math";
  DESCRIPTION   "Predefined functions which perform generic numerical computations.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "Floor" ( NUMERIC arg1, NUMERIC arg2 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "Mod" ( NUMERIC arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "SumFlowsToVolume" ( SLOT arg1, DATETIME arg2, DATETIME arg3 )
    SCALE_UNITS    "1  acre-feet ";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "SumFlowsToVolumeSkipNaN" ( SLOT arg1, DATETIME arg2, DATETIME arg3 )
    SCALE_UNITS    "1 acre-feet";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Date / Time";
  DESCRIPTION   "Predefined functions which access and manipulate date/times.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "GetDate" ( STRING arg1 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetDates" ( DATETIME arg1, DATETIME arg2, STRING arg3 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetDaysInMonth" ( DATETIME arg1 )
    SCALE_UNITS    " day ";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetDayOfMonth" ( DATETIME arg1 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetDayOfYear" ( DATETIME arg1 )
    SCALE_UNITS    " day ";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetYear" ( DATETIME arg1 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "NumberToDate" ( NUMERIC arg1 )
    SCALE_UNITS    " FullDateTime ";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Engineering";
  DESCRIPTION   "Predefined functions similar to methods on objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "GetMaxOutflowGivenInflow" ( OBJECT arg1, NUMERIC arg2, DATETIME arg3 )
    SCALE_UNITS    "1  cfs";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetMaxReleaseGivenInflow" ( OBJECT arg1, NUMERIC arg2, DATETIME arg3 )
    SCALE_UNITS    "1 cfs";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "GetMinSpillGivenInflowRelease" ( OBJECT arg1, NUMERIC arg2, NUMERIC arg3, DATETIME arg4 )
    SCALE_UNITS    "1 cfs";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "SolveOutflow" ( OBJECT arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4, DATETIME arg5 )
    SCALE_UNITS    "1 cfs";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "SolveStorage" ( OBJECT arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4, DATETIME arg5 )
    SCALE_UNITS    "1 acre-feet";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Workspace";
  DESCRIPTION   "Predefined functions which access information on slots and objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "ElevationToStorage" ( OBJECT arg1, NUMERIC arg2 )
    SCALE_UNITS    "1 acre-feet";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "StorageToElevation" ( OBJECT arg1, NUMERIC arg2 )
    SCALE_UNITS    "1 feet";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "VolumeToFlow" ( NUMERIC arg1, DATETIME arg2 )
    SCALE_UNITS    "1 cfs";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

  END;

END
